import{i as A,f as Y,j as _,k as f,l as k,m as P,n as I,u as $,q as c,r as G,s as y,v as T}from"./chunk-AGUgPSYp.js";import{I as j,y as E,w as N,b as z,u as B,v as q,l as g,d as V,m as b}from"./chunk-8hK7Z-a9.js";import{t as C}from"./chunk-60T-a_hh.js";import{o as x}from"./chunk-UVR0I-38.js";import"./chunk-oVLQlo07.js";import"./chunk-4e7sbcIe.js";const h="Feature Service",w="feature-layer-utils",H=`${w}-save`,Q=`${w}-save-as`,p=`${w}-saveall`,m=`${w}-saveall-as`;function v(e){return{isValid:G(e)&&(e.type!=="feature"||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function O(e){const a=[],t=[];for(const{layer:n,layerJSON:l}of e)n.isTable?t.push(l):a.push(l);return{layers:a,tables:t}}function F(e){return O([e])}async function J(e,a){return/\/\d+\/?$/.test(e.url)?F(a[0]):M(a,e)}async function M(e,a){if(!a)return e.reverse(),O(e);const{layer:{url:t,customParameters:n,apiKey:l}}=e[0];let s=await a.fetchData("json");s?.layers!=null&&s?.tables!=null||(s=await W(s,{url:t??"",customParameters:n,apiKey:l},e.map(r=>r.layer.layerId)));for(const r of e)R(r.layer,r.layerJSON,s);return s}async function W(e,a,t){e||={},e.layers||=[],e.tables||=[];const{url:n,customParameters:l,apiKey:s}=a,{serviceJSON:r,layersJSON:o}=await C(n,{customParameters:l,apiKey:s}),i=S(e.layers,r.layers,t),u=S(e.tables,r.tables,t);e.layers=i.itemResources,e.tables=u.itemResources;const d=[...i.added,...u.added],K=o?[...o.layers,...o.tables]:[];return await X(e,d,n,K),e}function S(e,a,t){const n=Y(e,a,(s,r)=>s.id===r.id);e=e.filter(s=>!n.removed.some(r=>r.id===s.id));const l=n.added;return l.forEach(({id:s})=>{e.push({id:s})}),{itemResources:e,added:l.filter(({id:s})=>!t.includes(s))}}async function X(e,a,t,n){const l=await Z(a),s=a.map(({id:r,type:o})=>new(l.get(o))({url:t,layerId:r,sourceJSON:n.find(({id:i})=>i===r)}));await Promise.allSettled(s.map(r=>r.load())),s.forEach(r=>{const{layerId:o,loaded:i,defaultPopupTemplate:u}=r;if(!i||u==null)return;const d={id:o,popupInfo:u.toJSON()};r.operationalLayerType!=="ArcGISFeatureLayer"&&(d.layerType=r.operationalLayerType),R(r,d,e)})}async function Z(e){const a=[];e.forEach(({type:l})=>{const s=ee(l),r=_[s];a.push(r())});const t=await Promise.all(a),n=new Map;return e.forEach(({type:l},s)=>{n.set(l,t[s])}),n}function ee(e){let a;switch(e){case"Feature Layer":case"Table":a="FeatureLayer";break;case"Oriented Imagery Layer":a="OrientedImageryLayer"}return a}function R(e,a,t){e.isTable?L(t.tables,a):L(t.layers,a)}function L(e,a){const t=e.findIndex(({id:n})=>n===a.id);t===-1?e.push(a):e[t]=a}function D(e,a){if(!e.length)throw new y(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ae(e,a){const t=e.map(n=>n.portalItem.id);if(new Set(t).size>1)throw new y(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(e,a){const t=e.map(n=>n.layerId);if(new Set(t).size!==t.length)throw new y(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function te(e){D(e,p),await Promise.all(e.map(a=>a.load()));for(const a of e)g(a,p,v),V({layer:a,itemType:h,errorNamePrefix:p});ae(e,p),U(e,p)}async function re(e,a){const{url:t,layerId:n,title:l,fullExtent:s,isTable:r}=e,o=f(t);a.url=o?.serverType==="FeatureServer"?t:`${t}/${n}`,a.title||=l,a.extent=null,r||s==null||(a.extent=await P(s)),I(a,c.METADATA),I(a,c.MULTI_LAYER),T(a,c.SINGLE_LAYER),r&&T(a,c.TABLE)}function se(e,a){for(const s of e){const r=s.parsedUrl.path,o=f(r);if(!o?.url.path)throw new y(`${a}:invalid-parameters`,b(s,`has unsupported url pattern: ${r}`),{layer:s});const u=o?.serverType;if(u!=="FeatureServer"&&u!=="MapServer")throw new y(`${a}:invalid-parameters`,b(s,`has unsupported server type: ${u}`),{layer:s});if(u==="MapServer"&&e.length>1)throw new y(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=f(e[0].parsedUrl.path),n=t?.url.path;if(!e.every(s=>f(s.parsedUrl.path)?.url.path===n))throw new y(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ne(e){D(e,m),await Promise.all(e.map(a=>a.load()));for(const a of e)g(a,m,v);se(e,m),U(e,m)}async function le(e,a){let t=0,n=0;for(const{isTable:r}of a)r?n++:t++;const l=a[0].parsedUrl.path,s=f(l);if(e.url=s?.serverType==="FeatureServer"?s.url.path:l,e.title||=s.title,e.extent=null,t>0){const r=a.map(o=>o.fullExtent).filter(k).reduce((o,i)=>o.clone().union(i));r&&(e.extent=await P(r))}I(e,c.METADATA),$(e,c.MULTI_LAYER,a.length>1),$(e,c.SINGLE_LAYER,a.length===1),$(e,c.TABLE,n>0&&t===0),N(e)}async function me(e,a){return j({layer:e,itemType:h,validateLayer:v,createItemData:(t,n)=>J(n,[t]),errorNamePrefix:H},a)}async function fe(e,a){await te(e);const t=e[0].portalItem,n=x(t),l=await Promise.all(e.map(r=>E(r,n,a))),s=await J(t,e.map((r,o)=>({layer:r,layerJSON:l[o]})));return N(t),await t.update({data:s}),await Promise.all(e.slice(1).map(r=>r.portalItem.reload())),A(n),t.clone()}async function de(e,a,t){return z({layer:e,itemType:h,validateLayer:v,createItemData:(n,l)=>Promise.resolve(F(n)),errorNamePrefix:Q,newItem:a,setItemProperties:re},t)}async function he(e,a,t){await ne(e);const n=B({itemType:h,errorNamePrefix:m,newItem:a}),l=x(n),s=await Promise.all(e.map(o=>E(o,l,t))),r=await M(e.map((o,i)=>({layer:o,layerJSON:s[i]})));await le(n,e),await q(n,r,t);for(const o of e)o.portalItem=n.clone();return A(l),n}export{me as save,fe as saveAll,he as saveAllAs,de as saveAs};
