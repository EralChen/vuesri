import{y as P,pn as V,po as z,dN as L,dO as G,$ as g,a2 as $,a0 as y,ak as B,_ as K,a3 as k,e0 as H,z as O,dQ as Q,dS as J,dk as W,cd as X,q as Y,bK as Z,dn as T,bj as M,pp as D,cb as ee,cc as te,e3 as re}from"./chunk-xdbuWCSg.js";import{_ as ne}from"./chunk-t4TbIqUg.js";import{a as ie,n as oe,b as se}from"./chunk-6Lw6Rkle.js";const le={setAttribute(){},rollback(){},commit(){}};var w;function be(e,t){const r=t.attributes[e.objectIdField];if(r==null)return le;const i=e.sessions.get(r);if(i)return i;const l=P(t.attributes),s=new Set,n=e.i3sOverrides.createInteractiveEditSession(r),o=new Map,u=(f,d)=>{const p=o.get(f);if(p==null){const m=d.indexOf(r);return o.set(f,m),m}return p};let a=w.EDITING;const c={setAttribute(f,d){if(a!==w.EDITING)return;const p=e.fieldsIndex.get(f);if(!p)return;const m=e.attributeStorageInfo.findIndex(b=>b.name===p.name);if(m<0)return;if(!(f in l))throw new Error(`Attribute "${f}" is not an attribute of the edited feature.`);n.setAttribute(m,d);const F=e.attributeStorageInfo[m];let E=!1;s.add(f),e.forEachNode((b,x)=>{const A=u(b,x);if(A===-1)return;const _=e.getAttributeData(b.index);if(_){const v=_[F.name];v&&(v[A]=d,e.setAttributeData(b.index,_,t),E=!0)}}),E&&e.clearMemCache()},rollback(){if(a===w.EDITING){for(const f of s)this.setAttribute(f,l[f]);n.remove(),a=w.ROLLED_BACK,e.sessions.delete(r)}},commit(){a===w.EDITING&&(n.remove(),a=w.COMMITTED,e.sessions.delete(r))}};return e.sessions.set(r,c),c}function ae(e,t,r){const{gidToFeatureInfo:i,oidToFeatureInfo:l,fieldsIndex:s,objectIdField:n,globalIdField:o,featureOrIdentifierList:u}=r;if(!r.featuresResolved&&u!=null){for(const a of u){const c={feature:null,oid:-1,gid:null};if("attributes"in a){c.feature=a;const f=a.attributes;if(f!=null)for(const d in f){if(c.oid!==-1&&c.gid!=null)break;const p=s.normalizeFieldName(d);p===n&&(c.oid=f[d]??-1),p===o&&(c.gid=f[d])}}else c.oid=a.objectId??-1,c.gid=a.globalId;c.gid!=null&&i.set(c.gid,c),c.oid!==-1&&l.set(c.oid,c)}r.featuresResolved=!0}return(e!==-1?l.get(e):null)??(t!=null?i.get(t):null)}function N(e,t,r,i,l=null,s=!0){const n=[],o={gidToFeatureInfo:new Map,oidToFeatureInfo:new Map,featuresResolved:r==null,fieldsIndex:e.fieldsIndex,objectIdField:e.objectIdField,globalIdField:e.globalIdField,featureOrIdentifierList:r};for(const u of t){if(u.error!=null)continue;const a=u.objectId??-1,c=u.globalId,f=(a===-1||s?ae(a,c,o):null)??{feature:null,oid:a,gid:c},d={oid:a===-1?f.oid:a,gid:c??f.gid,feature:f.feature,result:u};if(n.push(d),d.oid===-1&&d.gid!=null&&l!=null&&(d.oid=l.get(d.gid)??-1),d.oid===-1&&d.gid!=null){let p=i.get(d.gid);p==null&&(p=[],i.set(d.gid,p)),p.push(d)}}return n}async function Fe(e,t){const r=new Map,i=N(e,t.addedFeatures,t.edits?.addFeatures,r),l=N(e,t.updatedFeatures,t.edits?.updateFeatures,r),s=N(e,t.deletedFeatures,t.edits?.deleteFeatures,r,t.globalIdToObjectId,!1);return r.size>0&&await de(e,r),{adds:i.filter(n=>n.oid!==-1),updates:l.filter(n=>n.oid!==-1),deletes:s.filter(n=>n.oid!==-1)}}async function de(e,t){const r=e.i3sOverrides.layer.associatedLayer;if(r?.globalIdField==null)return;const i=r.createQuery(),{objectIdField:l,globalIdField:s}=r;i.where=Array.from(t.keys()).map(u=>`${s}='${u}'`).join(" OR "),i.returnGeometry=!1,i.outFields=[l,s],i.cacheHint=!1;const n=await V(z(r,i));if(!n.ok)return;const o=n.value.features;for(const u of o){const a=u.attributes[s],c=u.attributes[l];if(a==null||c==null||c===-1)continue;const f=t.get(a);if(f!=null)for(const d of f)d.oid=c}}function Ie(e,t){const r=new Map,i=t.adds,l=t.updates,s=t.deletes;if(i.length>0)for(const n of i){const o=n.oid,u=n.feature;u?.geometry?.type==="mesh"&&r.set(o,u.geometry)}if(l.length>0)for(const n of l){const o=n.oid,u=n.feature;u?.geometry?.type==="mesh"&&r.set(o,u.geometry)}if(s.length>0)for(const n of s)r.set(n.oid,null);for(const[n,o]of r)e.i3sOverrides.updateGeometry(n,o)}function we(e,t){const r=ce(e,t),i=ue(e,t);if(r.size===0&&i.size===0)return;const l=new Map;for(let d=0;d<e.attributeStorageInfo.length;d++)l.set(e.attributeStorageInfo[d].name,d);let s=!1;r.forEach((d,p)=>{const m=e.getAttributeData(p);let F=!1;d.forEach((E,b)=>{const x=m!=null?m[b]:null,A=l.get(b);for(const{featureIndex:_,value:v,featureId:U}of E)x&&(x[_]=v,F=!0,s=!0),e.i3sOverrides.updateAttributeValue(U,A,v)}),F&&e.setAttributeData(p,m,null)}),s&&e.clearMemCache();const{fieldsIndex:n,i3sOverrides:o,objectIdField:u,globalIdField:a}=e,c=o.layer.associatedLayer?.infoFor3D,f=new Set(c?[...Object.values(c.assetMapFieldRoles),...Object.values(c.transformFieldRoles)]:[]);for(const[d,p]of i){o.featureAdded(d);const{attributes:m}=p;for(const F in m){if(F!==u&&F!==a&&f.has(F))continue;const E=n.normalizeFieldName(F),b=E!=null?l.get(E):null;if(b==null)continue;const x=m[F];o.updateAttributeValue(d,b,x)}}}function ue(e,t){const r=new Map,i=t.adds;if(!i||i.length===0||e.globalIdField==null)return r;for(const l of i){const s=l.oid,n=l.feature;n?.geometry?.type==="mesh"&&r.set(s,n)}return r}function ce(e,t){const r=t.updates;if(!r||r.length===0)return new R;const i=new R,l=new Map;for(let s=0;s<e.attributeStorageInfo.length;s++)l.set(e.attributeStorageInfo[s].name,s);return e.forEachNode((s,n)=>{for(const o of r){if(o.feature==null)continue;const u=o.feature,a=o.oid,c=n.indexOf(a);for(const f in u.attributes){const d=e.fieldsIndex.normalizeFieldName(f),p=fe(i,s.index,d),m=u.attributes[f];p.push({featureIndex:c,featureId:a,value:m})}}}),i}function fe(e,t,r){const i=ge(e,t),l=r!=null&&i.get(r);if(l)return l;const s=new Array;return i.set(r,s),s}function ge(e,t){const r=e.get(t);if(r)return r;const i=new pe;return e.set(t,i),i}(function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"})(w||(w={}));const pe=Map,R=Map;function Ee(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:t},requiredFields:r}=this;return e.outFields?L(t,[...G(t,e.outFields),...r]):L(t,r)}}}}const q=e=>{let t=class extends e{constructor(){super(...arguments),this._numUpdating=0}get updating(){return this._numUpdating>0}autoUpdateAsync(r,i){const l=H(async s=>{++this._numUpdating;try{const n=await s;this.destroyed||this._set(r,n)}catch{O.getLogger(this).warn(`Async update of "${String(r)}" failed. Async update functions should not throw exceptions.`)}--this._numUpdating});return B(i,l,K)}};return g([y({readOnly:!0})],t.prototype,"updating",null),g([y()],t.prototype,"_numUpdating",void 0),t=g([$("esri.core.AsyncUpdate")],t),t};let S=class extends q(k){};S=g([$("esri.core.AsyncUpdate")],S);const C="esri.views.3d.layers.support.SceneLayerViewRequiredFields";let I=class extends q(k){get layer(){return this.layerView.layer}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:t},rendererFields:r,labelingFields:i,viewFilterFields:l}=this;return L(e,[...t??[],...r??[],...i??[],...l??[]])}constructor(e){super(e)}initialize(){this.addHandles([this.autoUpdateAsync("rendererFields",async()=>{const{fieldsIndex:e,renderer:t}=this.layer;return t?j(r=>t.collectRequiredFields(r,e)):null}),this.autoUpdateAsync("labelingFields",async()=>{const{layer:e}=this;return e.labelsVisible?j(t=>Q(t,e)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:e,mergedFilter:t}=this.layerView;return j(r=>J(r,e,t))})])}};async function j(e){const t=new Set;try{return await e(t),Array.from(t).sort()}catch(r){return O.getLogger(C).error(r),null}}g([y()],I.prototype,"layerView",void 0),g([y()],I.prototype,"layer",null),g([y()],I.prototype,"requiredFields",null),g([y()],I.prototype,"rendererFields",void 0),g([y()],I.prototype,"labelingFields",void 0),g([y()],I.prototype,"viewFilterFields",void 0),I=g([$(C)],I);let h=class extends W{constructor(){super(...arguments),this.layer=null,this.filter=null,this._geometryEngine=null,this._projectionEngineLoaded=!1,this._abortController=new AbortController}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}get layerFilter(){return ie(this._layerFilter)}get _layerFilter(){const e=this.layer?.filter;if(e==null||e.geometries.length<1)return null;const t=this._geometryEngine;if(t==null||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine)return oe;const r=e.geometries.at(0).spatialReference,i=e.geometries.toArray().map(o=>{try{o=t.simplify(o)}catch{return O.getLogger(this).warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."),null}if(o==null)return null;if(o.spatialReference.equals(r))return o;try{return X(o,r)}catch{return O.getLogger(this).warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."),null}}).filter(Y).sort((o,u)=>o.extent.xmin-u.extent.xmin),l=new Set,s=new Array,n=new Array;for(let o of i){const u=o.extent.xmin;if(s.length=0,l.forEach(a=>{if(u>=a.extent.xmax)return n.push(a),void l.delete(a);o.extent.ymin<=a.extent.ymax&&o.extent.ymax>=a.extent.ymin&&t.intersects(o,a)&&s.push(a)}),s.length>0){s.push(o);try{o=t.union(s)}catch{O.getLogger(this).warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");continue}s.pop(),s.forEach(a=>l.delete(a))}l.add(o)}return l.forEach(o=>n.push(o)),n.length>0?{spatialRelationship:e.spatialRelationship,geometries:n}:null}get _filterNeedsProjectionEngine(){const e=this.layer.filter;if(e==null||e.geometries.length<=1)return!1;const t=e.geometries.at(0).spatialReference;return e.geometries.some(({spatialReference:r})=>!r.equals(t)&&!Z(r,t))}get layerFilterUpdating(){return se(this._layerFilter)}initialize(){const{signal:e}=this._abortController;T(()=>this.destroyed||!this._geometryEngine&&this.layer?.filter?.geometries?.length,e).then(async()=>{M(e),this._geometryEngine=await ne(()=>import("./chunk-xdbuWCSg.js").then(t=>t.F7),__vite__mapDeps([0,1,2]))}).catch(D),this._projectionEngineLoaded=ee(),T(()=>this.destroyed||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine,e).then(async()=>{M(e),await te(),this._projectionEngineLoaded=!0}).catch(D)}destroy(){this._abortController=re(this._abortController)}highlight(e){throw new Error("Not implemented")}queryFeatures(e,t){throw new Error("Not implemented")}queryObjectIds(e,t){throw new Error("Not implemented")}queryFeatureCount(e,t){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,t){throw new Error("Not implemented")}};g([y()],h.prototype,"layer",void 0),g([y()],h.prototype,"availableFields",null),g([y()],h.prototype,"maximumNumberOfFeatures",null),g([y({readOnly:!0})],h.prototype,"maximumNumberOfFeaturesExceeded",null),g([y()],h.prototype,"filter",void 0),g([y({readOnly:!0})],h.prototype,"layerFilter",null),g([y({readOnly:!0})],h.prototype,"_layerFilter",null),g([y()],h.prototype,"_geometryEngine",void 0),g([y()],h.prototype,"_projectionEngineLoaded",void 0),g([y()],h.prototype,"_filterNeedsProjectionEngine",null),g([y()],h.prototype,"layerFilterUpdating",null),h=g([$("esri.views.layers.SceneLayerView")],h);const _e=h;export{Ee as a,I as c,Ie as d,we as f,be as i,Fe as u,_e as w};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/chunks/chunk-xdbuWCSg.js","assets/chunks/chunk-t4TbIqUg.js","assets/static/ShadedColorMaterial.LVqRbJ38.css"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
