import{jT as P,b$ as D,jU as $,jV as q,B as z,jW as E,jX as G,jY as B,jZ as W,j_ as A,cM as H}from"./chunk-ERvgPDZ8.js";async function M(a,d,l,m,o){const{elevationProvider:f,renderCoordsHelper:i}=a,{elevationInfo:u}=d,{pointsInFeatures:b,spatialReference:g}=m,h=D.fromJSON(g),y=$(u,!0),j=await q(y,h,o);z(o);const c=[],e=new Set,t=new Set;p.spatialReference=h;const s=a.elevationProvider.spatialReference??a.spatialReference;for(const{objectId:n,points:r}of b){const I=l(n);if(I==null){for(const w of r)c.push(w.z??0);e.add(n);continue}I.isDraped&&t.add(n);const C=I.graphic.geometry;R.setFromElevationInfo(E(C,u)),R.updateFeatureExpressionInfoContext(j,I.graphic,d);for(const{x:w,y:F,z:O}of r)p.x=w,p.y=F,p.z=O??0,await G(p,v,s,0,{signal:o}),B(v,f,R,i,S),c.push(S.z)}return{elevations:c,drapedObjectIds:t,failedObjectIds:e}}const R=new W,p=P(0,0,0,D.WGS84),S=new A,v=[0,0,0];async function N(a,d,l){if(a==null||d.candidates.length===0)return x;const m=a.graphics3DGraphicsByObjectID??a.graphics3DGraphics,o=[],f=[],{renderer:i}=a,u=i!=null&&"arcadeRequired"in i&&i.arcadeRequired?H():null,b=async(e,{graphic:t,graphics3DSymbol:s})=>{const n=await u,r=await a.getRenderingInfoAsync(t,i,n,{signal:l});return r==null?[]:s.queryForSnapping(e,h,r,l)},{candidates:g,spatialReference:h}=d;for(let e=0;e<g.length;++e){const t=g[e],{objectId:s}=t,n=typeof s=="number"?m?.get(s):void 0;if(n==null)continue;const{graphics3DSymbol:r}=n;r.symbologySnappingSupported&&(o.push(b(t,n)),f.push(e))}if(o.length===0)return x;const y=await Promise.all(o);z(l);const j=[],c=[];for(let e=0;e<y.length;++e){const t=y[e],s=f[e];for(const n of t)j.push(n),c.push(s)}return{candidates:j,sourceCandidateIndices:c}}const x={candidates:[],sourceCandidateIndices:[]};export{M as c,N as r};
