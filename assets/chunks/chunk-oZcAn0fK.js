import{sU as ke,hg as fe,ke as Ge,h6 as pe,iy as He,hn as je,sV as We,sW as Qe,sX as ze,mQ as B,b8 as k,b6 as z,sY as Ce,b7 as _,sZ as Xe,L as ne,aK as C,d$ as te,s as y,lx as ye,ah as Ze,i_ as et,ge as me,s_ as Me,hC as tt,s$ as st,l as it,t0 as rt,t1 as nt,qG as xe,G as at,t2 as ge,t3 as _e,t4 as be,t5 as Ee,t6 as H,t7 as j,t8 as Te,t9 as ot,qI as lt,qH as ut,ta as dt,km as Oe,dA as Ve,tb as De,kt as Ie,qJ as J,kn as ct,kp as ht,tc as ft}from"./chunk-m3jlTyOz.js";import{d as pt,n as yt,l as mt,f as Re}from"./chunk-CtkSqn65.js";import{n as xt}from"./chunk-nu9VKcdO.js";import"./chunk-VnQNafr9.js";import{e as Le}from"./chunk-tQs07CpE.js";class T{constructor(e){if(this.next=null,!Array.isArray(e))return void(this.data=e);this.data=e[0];let t=this;for(let s=1;s<e.length;s++)t.next=new T([e[s]]),t=t.next}*values(){let e=this;for(;e;)yield e.data,e=e.next}forEach(e){let t=this;for(;t;)e(t.data),t=t.next}find(e){return e(this.data)?this:this.next?.find(e)}max(e,t=this){const s=e(this.data)>e(t.data)?this:t;return this.next?this.next.max(e,s):s}remove(e,t=null){return this===e?t?(t.next=this.next,t):this.next:this.next?.remove(e,this)??null}get last(){return this.next?this.next.last:this}}let Xt=class{constructor(e){this._head=null,e!=null&&(this._head=new T(e))}get head(){return this._head}maxAvailableSpace(){if(this._head==null)return 0;const e=this._head.max(t=>t.end-t.start);return e.data.end-e.data.start}firstFit(e){if(this._head==null)return null;let t=null,s=this._head;for(;s;){const r=s.data.end-s.data.start;if(r===e)return t?t.next=s.next:this._head=s.next,s.data.start;if(r>e){const n=s.data.start;return s.data.start+=e,n}t=s,s=s.next}return null}free(e,t){const s=e+t;if(this._head==null){const o=new T({start:e,end:s});return void(this._head=o)}if(s<=this._head.data.start){if(s===this._head.data.start)return void(this._head.data.start-=t);const o=new T({start:e,end:s});return o.next=this._head,void(this._head=o)}let r=this._head,n=r.next;for(;n;){if(n.data.start>=s){if(r.data.end===e){if(r.data.end+=t,r.data.end===n.data.start){const l=n.data.end-n.data.start;return r.data.end+=l,void(r.next=n.next)}return}if(n.data.start===s)return void(n.data.start-=t);const o=new T({start:e,end:s});return o.next=r.next,void(r.next=o)}r=n,n=n.next}if(e===r.data.end)return void(r.data.end+=t);const a=new T({start:e,end:s});r.next=a}},gt=class{acquire(e){return{refCount:1,version:-1,labelMat2d:ke(),tileMat3:fe(),dvs:fe()}}release(e){}},_t=class se extends Ge{constructor(e,t,s,r){super(e,t,s,r,pe,pe)}destroy(){super.destroy(),this._transforms&&se.TransformCache.release(this.key.hash)}setTransform(e){const t=this.resolution/e.resolution,s=this.transforms.tileMat3,[r,n]=e.toScreenNoRotation([0,0],[this.x,this.y]),a=this.width/this.rangeX*t,o=this.height/this.rangeY*t;He(s,a,0,0,0,o,0,r,n,1),je(this.transforms.dvs,e.displayViewMat3,s);const l=this.transforms.labelMat2d,u=window.devicePixelRatio,d=We(ke(),a*u,0,0,o*u,r*u,n*u);Qe(l,e.viewMat2d,d)}_createTransforms(){return se.TransformCache.acquire(this.key.hash)}};_t.TransformCache=new gt;let L=class{constructor(e,t,s,r,n){this.target=e,this.geometryType=t,this.materialKey=s,this.indexFrom=r,this.indexCount=n}get indexEnd(){return this.indexFrom+this.indexCount}extend(e){this.indexCount+=e}},ss=class Ne{constructor(e,t){this.geometryType=0,this._target=e,this.geometryType=t}static from(e,t,s,r){const n=new Ne(e,t);if(r!=null)for(const a of r)s.seekIndex(a),n.addRecord(s);else for(;s.next();)n.addRecord(s);return n}addRecord(e){const t=this._target,s=this.geometryType,r=e.materialKey;let n=e.indexFrom,a=e.indexCount;const o=e.vertexFrom,l=e.vertexCount;if(a||(n=o,a=l),this._head==null){const c=new L(t,s,r,n,a);return void(this._head=new T(c))}let u=null,d=this._head;for(;d;){if(n<d.data.indexFrom)return this._insert(r,n,a,u,d);u=d,d=d.next}this._insert(r,n,a,u,null)}forEach(e){this._head!=null&&this._head.forEach(e)}*infos(){if(this._head!=null)for(const e of this._head.values())yield e}_insert(e,t,s,r,n){if(r==null&&n==null){const a=new L(this._target,this.geometryType,e,t,s);this._head=new T(a)}return r==null&&n!=null?this._insertAtHead(e,t,s,n):r!=null&&n==null?this._insertAtEnd(e,t,s,r):r!=null&&n!=null?this._insertAtMiddle(e,t,s,r,n):void 0}_insertAtHead(e,t,s,r){const n=t+s;if(e===r.data.materialKey&&n===r.data.indexFrom)r.data.indexFrom=t,r.data.indexCount+=s;else{const a=new L(this._target,this.geometryType,e,t,s);this._head=new T(a),this._head.next=r}}_insertAtEnd(e,t,s,r){if(r.data.materialKey===e&&r.data.indexEnd===t)r.data.indexCount+=s;else{const n=new L(this._target,this.geometryType,e,t,s),a=new T(n);r.next=a}}_insertAtMiddle(e,t,s,r,n){const a=t+s;if(r.data.materialKey===e&&r.data.indexEnd===t)r.data.indexCount+=s,r.data.materialKey===n.data.materialKey&&r.data.indexEnd===n.data.indexFrom&&(r.data.indexCount+=n.data.indexCount,r.next=n.next);else if(e===n.data.materialKey&&a===n.data.indexFrom)n.data.indexFrom=t,n.data.indexCount+=s;else{const o=new L(this._target,this.geometryType,e,t,s),l=new T(o);r.next=l,l.next=n}}};const q=2147483647;class N{constructor(e){this._head=e,this._cursor=e}static from(e,t=0,s=e.byteLength/w.BYTES_PER_RECORD-t){const r=new w(new Int32Array(e,t*w.BYTES_PER_RECORD,s*w.ELEMENTS_PER_RECORD));return new N(r)}size(){let e=this._cursor,t=0;for(;e;)t+=e.size(),e=e._link;return t}get id(){return this._cursor.id}set id(e){this._cursor.id=e}get materialKey(){return this._cursor.materialKey}set materialKey(e){this._cursor.materialKey=e}get insertAfter(){return this._cursor.insertAfter}get indexFrom(){return this._cursor.indexFrom}set indexFrom(e){this._cursor.indexFrom=e}get indexCount(){return this._cursor.indexCount}set indexCount(e){this._cursor.indexCount=e}get vertexFrom(){return this._cursor.vertexFrom}set vertexFrom(e){this._cursor.vertexFrom=e}get vertexCount(){return this._cursor.vertexCount}set vertexCount(e){this._cursor.vertexCount=e}get sortKey(){return this._cursor.sortKey}set sortKey(e){this._cursor.sortKey=e}get index(){return this._cursor._indexStart+this._cursor._index}seekIndex(e){let t=e;for(this._cursor=this._head;this._cursor;){const s=this._cursor.size();if(t<s)return this._cursor._index=t,!0;t-=s,this._cursor=this._cursor._link}return!1}forEach(e){const t=this.getCursor();for(;t.next();)e(t)}link(e){if(!this._head)return void(this._head=e._head);let t=this._head;for(;t._link;)t=t._link;t._link=e._head,t._link._indexStart=t._indexStart+t.size()}getCursor(){return this.copy()}getDrawInfo(e,t){return new L(e,t,this.materialKey,this.indexFrom,this.indexCount)}lookup(e){for(this._cursor=this._head;this._cursor&&!this._cursor.lookup(e);){if(!this._cursor._link)return!1;this._cursor=this._cursor._link}return!!this._cursor}copy(){const e=new N(this._head?.copy());if(!e._head)return e;let t=e._head,s=e._head._link;for(;s;)t._link=s.copy(),t=s,s=t._link;return e}next(){return!!this._cursor&&(!!this._cursor.next()||!!this._cursor._link&&(this._cursor=this._cursor._link,this.next()))}peekId(){return this._cursor.peekId()??this._cursor._link.peekId()}delete(e){let t=this._head,s=null;for(;t;){if(t.delete(e))return t.isEmpty()&&(s!=null&&(s._link=t._link),t===this._head&&(this._head=t._link),t===this._cursor&&(this._cursor=t._link)),!0;s=t,t=t._link}return!1}}N.ELEMENTS_PER_RECORD=ze,N.BYTES_PER_RECORD=N.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT;let w=class f{constructor(e){this._link=null,this._index=-1,this._indexStart=0,this._packedRecordsF32=null,this._deletedCount=0,this._offsets={instance:null},this._packedRecords=e}static from(e,t=0,s=e.byteLength/this.BYTES_PER_RECORD-t){return new f(new Int32Array(e,t*this.BYTES_PER_RECORD,s*this.ELEMENTS_PER_RECORD))}delete(e){const t=this._index,s=this.lookup(e);if(s)for(this.id=q,++this._deletedCount;this.next()&&this.id===e;)this.id=q,++this._deletedCount;return this._index=t,s}isEmpty(){return this._deletedCount===this.size()}link(e){this._link?this._link.link(e):this._link=e}lookup(e){if(this._offsets.instance==null){this._offsets.instance=new Map;const s=this.copy();s._index=-1;let r=0;for(;s.next();)s.id!==r&&(this._offsets.instance.set(s.id,s._index),r=s.id)}if(!this._offsets.instance.has(e))return!1;const t=this._index;return this._index=this._offsets.instance.get(e),this.id!==q||(this._index=t,!1)}get id(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD]}set id(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD]=e}get materialKey(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+1]}set materialKey(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+1]=e}get insertAfter(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+2]}get indexFrom(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+3]}set indexFrom(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+3]=e}get indexCount(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+4]}set indexCount(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+4]=e}get vertexFrom(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+5]}set vertexFrom(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+5]=e}get vertexCount(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+6]}set vertexCount(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+6]=e}get sortKey(){return this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*f.ELEMENTS_PER_RECORD+7]}set sortKey(e){this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*f.ELEMENTS_PER_RECORD+7]=e}get index(){return this._index}size(){return this._packedRecords.length/f.ELEMENTS_PER_RECORD}next(){for(;++this._index<this.size()&&this.id===q;);return this._index<this.size()}peekId(){const e=(this._index+1)*f.ELEMENTS_PER_RECORD;return e>=this._packedRecords.length?0:this._packedRecords[e]}getCursor(){return this.copy()}copy(){const e=new f(this._packedRecords);return e._indexStart=this._indexStart,e._link=this._link,e._index=this._index,e._offsets=this._offsets,e._deletedCount=this._deletedCount,e}};w.ELEMENTS_PER_RECORD=ze,w.BYTES_PER_RECORD=w.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT;function $e(i){if(!i)return B.NONE;let e=0;for(const t of i)if(t.type==="size"){const s=pt(t);e|=s,t.target==="outline"&&(e|=s<<4)}else t.type==="color"?e|=B.COLOR:t.type==="opacity"?e|=B.OPACITY:t.type==="rotation"&&(e|=B.ROTATION);return e}function M(i){return i.type==="line-marker"?{type:"line-marker",color:i.color?.toJSON(),placement:i.placement,style:i.style}:i.constructor.fromJSON(i.toJSON()).toJSON()}function O(i){return Xe(i)}function g(i,e,t=!1){if(!i)return null;switch(i.type){case"simple-fill":case"picture-fill":return Et(i,e,t);case"simple-marker":case"picture-marker":return Rt(i,e,t);case"simple-line":return Tt(i,e,t);case"text":return vt(i,e,t);case"label":return bt(i,e,t);case"cim":return{type:"cim",rendererKey:e.vvFlags,data:i.data,maxVVSize:e.maxVVSize};case"CIMSymbolReference":return{type:"cim",rendererKey:e.vvFlags,data:i,maxVVSize:e.maxVVSize};case"web-style":return{...M(i),type:"web-style",hash:i.hash(),rendererKey:e.vvFlags,maxVVSize:e.maxVVSize};default:throw new Error(`symbol not supported ${i.type}`)}}function bt(i,e,t){const s=i.toJSON(),r=k(z.LABEL,{...e,placement:s.labelPlacement});return{materialKey:t?O(r):r,hash:i.hash(),...s,labelPlacement:s.labelPlacement}}function Et(i,e,t){const s=k(z.FILL,e),r=t?O(s):s,n=i.clone(),a=n.outline,o=Ce(e.symbologyType);o||(n.outline=null);const l={materialKey:r,hash:n.hash(),...M(n)};if(o)return l;const u=[];if(u.push(l),a){const d=k(z.LINE,{...e,isOutline:!0}),c={materialKey:t?O(d):d,hash:a.hash(),...M(a)};u.push(c)}return{type:"composite-symbol",layers:u,hash:u.reduce((d,c)=>c.hash+d,"")}}function Tt(i,e,t){const s=Ce(e.symbologyType)?_.DEFAULT:e.symbologyType,r=k(z.LINE,{...e,symbologyType:s}),n=t?O(r):r,a=i.clone(),o=a.marker;a.marker=null;const l=[];if(l.push({materialKey:n,hash:a.hash(),...M(a)}),o){const u=k(z.MARKER,e),d=t?O(u):u;o.color=o.color??a.color,l.push({materialKey:d,hash:o.hash(),lineWidth:a.width,...M(o)})}return{type:"composite-symbol",layers:l,hash:l.reduce((u,d)=>d.hash+u,"")}}function Rt(i,e,t){if(i.type==="simple-marker"&&(i.style==="path"||i.outline&&i.outline.style!=="solid"&&i.outline.style!=="none"))return g({type:"CIMSymbolReference",symbol:xt.fromSimpleMarker(i)},e,t);const s=k(z.MARKER,e),r=t?O(s):s,n=M(i);return{materialKey:r,hash:i.hash(),...n,angle:i.angle,maxVVSize:e.maxVVSize}}function vt(i,e,t){const s=k(z.TEXT,e),r=t?O(s):s,n=M(i);return{materialKey:r,hash:i.hash(),...n,angle:i.angle,maxVVSize:e.maxVVSize}}const is=Object.freeze(Object.defineProperty({__proto__:null,createSymbolSchema:g},Symbol.toStringTag,{value:"Module"}));function St(i,e){if(!("visualVariables"in i)||!i.hasVisualVariables("size"))return 0;const t=i.getVisualVariablesForType("size");if(!t[0])return 0;const s=t[0];if(e&&s.field==="cluster_count"&&e.type==="cluster")return e.clusterMaxSize;if(s.target==="outline")return 0;if(s.transformationType==="stops")return s.stops.map(r=>r.size).reduce(W,0);if(s.transformationType==="clamped-linear"){let r=-1/0,n=-1/0;return r=typeof s.maxSize=="number"?s.maxSize:s.maxSize.stops.map(a=>a.size).reduce(W,0),n=typeof s.minSize=="number"?s.minSize:s.minSize.stops.map(a=>a.size).reduce(W,0),Math.max(r,n)}return s.transformationType==="real-world-size"?30:void 0}function W(i,e){return Math.max(i,e)}const Y=8,Ae=Y-2,G=ne.getLogger("esri.views.2d.layers.features.support.rendererUtils"),rs=i=>{if(!("visualVariables"in i)||!i.visualVariables?.length)return i;const e=i.clone(),t=e.visualVariables.map(s=>Pe(s)?Ue(s):s);return e.visualVariables=t,e};function wt(i){return i.map(e=>Pe(e)?Ue(e.clone()):e)}function Pe(i){return(i.type==="size"||i.type==="color"||i.type==="opacity")&&i.stops!=null}function Ue(i){return i.stops=zt(i.type,i.stops??[]),i}function I(i,e,t){return(1-t)*i+t*e}function Ft(i,e){const[t,...s]=e,r=s.pop(),n=s[0].value,a=s[s.length-1].value,o=(a-n)/Ae,l=[];for(let u=n;u<a;u+=o){let d=0;for(;u>=s[d].value;)d++;const c=s[d],p=e[d-1],R=u-p.value,b=c.value===p.value?1:R/(c.value-p.value);if(i==="color"){const m=s[d],E=e[d-1],h=m.color.clone();h.r=I(E.color.r,h.r,b),h.g=I(E.color.g,h.g,b),h.b=I(E.color.b,h.b,b),h.a=I(E.color.a,h.a,b),l.push({value:u,color:h,label:m.label})}else if(i==="size"){const m=s[d],E=e[d-1],h=ye(m.size),S=I(ye(E.size),h,b);l.push({value:u,size:S,label:m.label})}else{const m=s[d],E=I(e[d-1].opacity,m.opacity,b);l.push({value:u,opacity:E,label:m.label})}}return[t,...l,r]}function kt(i){const[e,...t]=i,s=t.pop();for(;t.length>Ae;){let r=0,n=0;for(let a=1;a<t.length;a++){const o=t[a-1],l=t[a],u=Math.abs(l.value-o.value);u>n&&(n=u,r=a)}t.splice(r,1)}return[e,...t,s]}function zt(i,e){return e.length<=Y?e:(G.warn(`Found ${e.length} Visual Variable stops, but MapView only supports ${Y}. Displayed stops will be simplified.`),e.length>2*Y?Ft(i,e):kt(e))}function ae(){if(C("heatmap-force-raster"))return"raster";const{supportsTextureFloat:i,supportsTextureHalfFloat:e,supportsColorBufferFloat:t,supportsColorBufferFloatBlend:s,supportsColorBufferHalfFloat:r}=te("2d");return i&&t&&s||e&&r?"symbol":C("heatmap-allow-raster-fallback")?"raster":"none"}function ns(i){if(!i)return!0;switch(i.type){case"dot-density":if(!te("2d").supportsTextureFloat)return G.error(new y("webgl-missing-extension","Missing WebGL extension OES_Texture_Float which is required for DotDensity")),!1;break;case"heatmap":{const e=ae();if(e==="none"||e==="raster"&&!C("heatmap-force-raster")){const t=te("2d"),s=["supportsTextureFloat","supportsTextureHalfFloat","supportsColorBufferFloat","supportsColorBufferFloatBlend","supportsColorBufferHalfFloat"].filter(r=>!t[r]).join(", ");if(e==="none")return G.errorOnce(new y("webgl-missing-extension",`Missing WebGL${t.type} requirements for Heatmap: ${s}`)),!1;e==="raster"&&G.warnOnce(`Missing WebGL${t.type} requirements for accelerated Heatmap: ${s}. Feature support may be limited.`)}break}}return!0}const V=ne.getLogger("esri.views.2d.layers.features.schemaUtils"),x="ValidationError";function ie(i,e){let t=0,s=0,r=_.DEFAULT;if(i!=null){if(s=St(i,e),"visualVariables"in i&&(t=$e(i.visualVariables||[]),i.type==="dot-density"&&(r=_.DOT_DENSITY)),i.type==="heatmap"&&(r=_.HEATMAP),i.type==="dictionary")return{maxVVSize:s,vvFlags:t,symbologyType:_.DEFAULT};if(i.type==="pie-chart")return{maxVVSize:s,vvFlags:t,symbologyType:_.PIE_CHART};if(r!==_.DOT_DENSITY&&r!==_.HEATMAP){const n=i.getSymbols();"backgroundFillSymbol"in i&&i.backgroundFillSymbol&&n.push(i.backgroundFillSymbol);let a=!0,o=!0;for(const l of n)if(l.type!=="cim"&&l.type!=="web-style"||(o=!1),l.type==="simple-fill"||l.type==="picture-fill"){const u=l.outline,d=u&&u.style!=="none"&&u.style!=="solid",c=l.type==="simple-fill"&&l.style!=="none"&&l.style!=="solid";d&&(a=!1),(l.type==="picture-fill"||c||d)&&(o=!1)}a?r=o?_.OUTLINE_FILL_SIMPLE:_.OUTLINE_FILL:o&&(r=_.SIMPLE)}}return{vvFlags:t,maxVVSize:s,symbologyType:r}}let ve=null;function as(i){if(C("esri-2d-update-debug")){const e=Se(i,!0);console.debug("Created new schema",e),console.debug("Schema diff",Ze(ve,e)),ve=e}return Se(i)}function Se(i,e=!1){try{const t=Vt(i,e),s=Lt(i),r={};t.map(o=>Ct(r,i,o));const n=i.subtypeCode!=null?`${i.subtypeField} = ${i.subtypeCode}`:null;return{source:{definitionExpression:et(i.definitionExpression,n),fields:i.fields.map(o=>o.toJSON()),gdbVersion:i.gdbVersion,historicMoment:i.historicMoment?.getTime(),outFields:i.availableFields,pixelBuffer:i.pixelBuffer,spatialReference:i.spatialReference.toJSON(),timeExtent:i.timeExtent?.toJSON(),customParameters:i.customParameters},attributes:{fields:{},indexCount:0},processors:t,tileRenderer:s,targets:r}}catch(t){if(t.fieldName===x)return V.error(t),null;throw t}}function Ct(i,e,t){switch(t.target){case"feature":return void X(i,Q(e),t);case"aggregate":{if(!("featureReduction"in e))return;const s=e.featureReduction;switch(s?.type){case"selection":throw new y(x,"Mapview does not support `selection` reduction type",s);case"binning":return X(i,Q(e),t),void Mt(i,s,e.fields.map(r=>r.toJSON()),t);case"cluster":return X(i,Q(e),t),void Ot(i,s,e.fields.map(r=>r.toJSON()),t)}}}}function oe(i,e){for(const t in e){const s=e[t];if(s.target!==i.name)continue;const r=i.attributes[t];if(r?.context){const n=r.context;n.mesh=n.mesh||s.context?.mesh,n.storage=n.storage||s.context?.storage}else i.attributes[t]=s}return i}function Q(i){return[i.filter?.toJSON()??null,i.featureEffect?.filter?.toJSON()??null]}function X(i,e,t){return i.feature||(i.feature={name:"feature",input:"source",filters:e,attributes:{}}),oe(i.feature,t.attributes.fields),i}function Ke(i,e){const{onStatisticExpression:t,onStatisticField:s,statisticType:r}=i;switch(r){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(t){const{returnType:a}=t;return a?a==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(V.error(new y(x,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",i)),"esriFieldTypeString")}const n=e.find(a=>a.name===s);return n?n.type:(V.error(new y(x,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",i)),"esriFieldTypeString")}}}function Mt(i,e,t,s){return i.aggregate||(i.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:e.fixedBinLevel,fields:(e.fields??[]).map(r=>({...r.toJSON(),type:Ke(r,t)}))},attributes:{}}),oe(i.aggregate,s.attributes.fields),i}function Ot(i,e,t,s){const r=s.aggregateFields??[],n=new Set;for(const a of r)n.add(a.name);for(const a of e?.fields??[])n.has(a.name)||r.push(a);return i.aggregate||(i.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:me(e.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(me(e.clusterMaxSize)/64),fields:r.map(a=>({...a.toJSON(),type:Ke(a,t)}))}}),oe(i.aggregate,s.attributes.fields),i}function v(i,e){return e.field?F(i,{...e,type:"field",field:e.field}):e.valueExpression?F(i,{...e,type:"expression",valueExpression:e.valueExpression}):{field:void 0,fieldIndex:void 0}}function F(i,e){switch(e.type){case"expression":{const t=e.valueExpression;if(!i.fields[t]){const s=i.indexCount++;i.fields[t]={...e,name:t,fieldIndex:s}}return{fieldIndex:i.fields[t].fieldIndex}}case"label-expression":{const t=JSON.stringify(e.label);if(!i.fields[t]){const s=i.indexCount++;i.fields[t]={...e,name:t,fieldIndex:s}}return{fieldIndex:i.fields[t].fieldIndex}}case"field":{const t=e.field;return e.target==="aggregate"&&i.fields[t]||(i.fields[t]={...e,name:t}),{field:t}}case"statistic":return i.fields[e.name]={...e},{field:e.name}}}function Vt(i,e=!1){const t=new Array;let s=0;return t.push(It(i,s++,e)),t}function Z(i,e,t,s,r,n=!1){const a=F(i,{type:"label-expression",target:t,context:{mesh:!0},resultType:"string",label:{labelExpression:e.labelExpression,labelExpressionInfo:e.labelExpressionInfo?{expression:e.labelExpressionInfo.expression}:null,symbol:!!e.symbol,where:e.where}}),{fieldIndex:o}=a;return{...g(e,r,n),fieldIndex:o,target:t,index:s}}function Dt(i,e,t){const s="featureReduction"in e&&e.featureReduction;if(!s)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const r="aggregate",n=[];let a=null,o=Le(e.geometryType),l=[],u=null;if(s)switch(s.type){case"selection":return V.error(new y(x,"Mapview does not support `selection` reduction type",s)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case"cluster":case"binning":if(n.push(...s.fields??[]),s.type==="cluster"?o="esriGeometryPoint":s.type==="binning"&&(o="esriGeometryPolygon"),s.renderer&&!s.renderer.authoringInfo?.isAutoGenerated){if(s.type==="cluster"){const{renderer:c}=rt(s.renderer,s,null);u=c}else u=s.renderer;const d=ie(s.renderer,s);a=re(i,r,s.renderer,d,t),l=s&&s.labelsVisible&&s.labelingInfo||[]}else if(s.type==="cluster"){if(u=nt(n,e.renderer,s,null,!0),s.symbol){const d=ie(u,s);a={type:"simple",symbol:g(s.symbol,d,t),symbologyType:d.symbologyType}}l=s&&s.labelsVisible&&s.labelingInfo||[]}}return $t(i,n),{labels:Me(l,s.type==="binning"?"esriGeometryPolygon":o),matcher:a,fields:n,rendererOverride:u}}function It(i,e,t=!1){const s={indexCount:0,fields:{}},r="featureReduction"in i?i.featureReduction??void 0:void 0,n=r?"aggregate":"feature";if("sublayers"in i){const h={type:"subtype",subtypeField:i.subtypeField,renderers:{},symbologyType:_.DEFAULT},S={type:"subtype",mapping:{},target:"feature",subtypeField:i.subtypeField},U={type:"subtype",classes:{}},Be={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:S,mesh:{matcher:h,aggregateMatcher:null,labels:U,sortKey:null}},ue=new Set;let Je=0;for(const{renderer:D,subtypeCode:$,labelingInfo:qe,labelsVisible:Ye}of i.sublayers){let de=0;"visualVariables"in D&&D.visualVariables&&(D.visualVariables.some(P=>P.type!=="rotation")&&V.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),de=$e(D.visualVariables.filter(P=>P.type!=="size")));const ce={symbologyType:_.DEFAULT,vvFlags:de,maxVVSize:0},A=re(s,n,D,ce,t),K=we(s,n,D),he=Ye&&qe;if(A.type==="dictionary")throw new y(x,"Dictionary renderer is not supported in subtype layers");if(A.type==="subtype")throw new y(x,"Nested subtype renderers is not supported");if(K!=null&&K.type==="subtype")throw new y(x,"Nested subtype storage is not supported");if(K?.attributeMapping!=null)throw new y(x,"Non-visual-variable attributes are not supported in subtype layers");if(A.type==="heatmap")throw new y(x,"Heatmaps are not supported in subtype layers");if(A.type==="pie-chart")throw new y(x,"Pie-charts are not supported in subtype layers");if(ue.has($))throw new y(x,"Subtype codes for sublayers must be unique");ue.add($),h.renderers[$]=A,S.mapping[$]=K,he&&(U.classes[$]=he.map(P=>Z(s,P,"feature",Je++,ce,t)))}return Be}if(i.renderer?.type==="heatmap"&&ae()==="raster"){const{radius:h,fieldOffset:S,field:U}=i.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:n,storage:null,mesh:{radius:h,fieldOffset:S,field:v(s,{target:n,field:U,resultType:"numeric"}).field}}}const a=Dt(s,i,t),o=Le(i.geometryType),l=a.rendererOverride??i.renderer,u=ie(l,r),d=re(s,n,l,u,t),c=we(s,n,l),p=Nt(s,i.orderBy,i.renderer,r),R=i.labelsVisible&&i.labelingInfo||[],b=Me(R,o);let m=0;const E=[...b.map(h=>Z(s,h,"feature",m++,u,t)),...a.labels.map(h=>Z(s,h,"aggregate",m++,u,t))];return{type:"symbol",target:n,attributes:s,aggregateFields:a.fields,storage:c,mesh:{matcher:d,labels:{type:"simple",classes:E},aggregateMatcher:a.matcher,sortKey:p}}}function Lt(i){return i.renderer?.type==="heatmap"&&ae()==="raster"?{type:"heatmap"}:{type:"symbol"}}function Nt(i,e,t,s){if(s!=null)return null;if(e!=null&&e.length){e.length>1&&V.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${e.length}. All but the first will be discarded`);const r=e[0],n=r.order==="ascending"?"asc":"desc";return r.field?{field:r.field,order:n}:r.valueExpression?{fieldIndex:F(i,{type:"expression",target:"feature",valueExpression:r.valueExpression,resultType:"numeric"}).fieldIndex,order:n}:(V.error(new y(x,"Expected to find a field or valueExpression for OrderByInfo",r)),null)}return t!=null&&t.type==="unique-value"&&t.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function $t(i,e){const t={mesh:!0,storage:!0};for(const s of e){const{name:r,onStatisticField:n,onStatisticExpression:a,statisticType:o}=s;let l,u;const d="numeric",c="feature";a?u=F(i,{type:"expression",target:c,valueExpression:a.expression,resultType:d}).fieldIndex:l=F(i,{type:"field",target:c,field:n}).field,F(i,{type:"statistic",target:"aggregate",name:r,context:t,inField:l,inFieldIndex:u,statisticType:o})}}function we(i,e,t){let s;switch(t.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":s={visualVariables:!0,attributes:null};break;default:s=tt(t).getStorageSpec(t)}return At(i,e,s,t)}function At(i,e,t,s){if(t==null)return null;const{visualVariables:r,attributes:n}=t;let a=null;r&&"visualVariables"in s&&(a=Pt(i,e,s.visualVariables));const o=a!=null?4:0;let l=null;return n!=null&&(l=n.map((u,d)=>{const{field:c,fieldIndex:p}=v(i,{valueExpression:u.valueExpression,field:u.field,resultType:"numeric",target:e});return{binding:d+o,field:c,fieldIndex:p}})),{type:"simple",target:e,attributeMapping:l,vvMapping:a}}function Pt(i,e,t){if(!t?.length)return[];const s={storage:!0},r="numeric";return wt(t).map(n=>{const a=st(n.type),{field:o,fieldIndex:l}=v(i,{target:e,valueExpression:n.valueExpression,field:n.field,context:s,resultType:r});switch(n.type){case"size":return n.valueExpression==="$view.scale"?null:{type:"size",binding:a,field:o,fieldIndex:l,normalizationField:v(i,{target:e,field:n.normalizationField,context:s,resultType:r}).field,valueRepresentation:n.valueRepresentation??null};case"color":return{type:"color",binding:a,field:o,fieldIndex:l,normalizationField:v(i,{target:e,field:n.normalizationField,context:s,resultType:r}).field};case"opacity":return{type:"opacity",binding:a,field:o,fieldIndex:l,normalizationField:v(i,{target:e,field:n.normalizationField,context:s,resultType:r}).field};case"rotation":return{type:"rotation",binding:a,field:o,fieldIndex:l}}}).filter(it)}function re(i,e,t,s,r=!1){const n=i??{indexCount:0,fields:{}};switch(t.type){case"simple":case"dot-density":return Ut(n,t,s,r);case"class-breaks":return Bt(n,e,t,s,r);case"unique-value":return Jt(n,e,t,s,r);case"dictionary":return qt(n,t,s,r);case"heatmap":return Yt(n,t,s,r);case"pie-chart":return Kt(n,t,s,r)}}function Ut(i,e,t,s=!1){const r=e.getSymbols(),n=r.length?r[0]:null;return{type:"simple",symbol:g(n,t,s),symbologyType:t.symbologyType}}function Kt(i,e,t,s=!1){const r=e.getSymbols(),n=r[0],a=r.length>1?r[1]:null;return{type:"pie-chart",markerSymbol:g(n,t,s),fillSymbol:g(a,t,s),symbologyType:t.symbologyType}}function Bt(i,e,t,s,r=!1){const n={mesh:!0,use:"renderer.field"},a=t.backgroundFillSymbol,{field:o,fieldIndex:l}=v(i,{target:e,field:t.field,valueExpression:t.valueExpression,resultType:"numeric",context:n}),u=t.normalizationType,d=u==="log"?"esriNormalizeByLog":u==="percent-of-total"?"esriNormalizeByPercentOfTotal":u==="field"?"esriNormalizeByField":null,c=t.classBreakInfos.map(p=>({symbol:g(p.symbol,s,r),min:p.minValue,max:p.maxValue})).sort((p,R)=>p.min-R.min);return{type:"interval",attributes:i.fields,field:o,fieldIndex:l,backgroundFillSymbol:g(a,s,r),defaultSymbol:g(t.defaultSymbol,s,r),intervals:c,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,normalizationType:d,isMaxInclusive:t.isMaxInclusive,symbologyType:s.symbologyType}}function Jt(i,e,t,s,r=!1){const n=[],a=t.backgroundFillSymbol,o={target:e,context:{mesh:!0},resultType:"string"};if(t.field&&typeof t.field!="string")throw new y(x,"Expected renderer.field to be a string",t);const{field:l,fieldIndex:u}=v(i,{...o,field:t.field,valueExpression:t.valueExpression});for(const d of t.uniqueValueInfos??[])n.push({value:""+d.value,symbol:g(d.symbol,s,r)});return{type:"map",attributes:i.fields,field:l,fieldIndex:u,field2:v(i,{...o,field:t.field2}).field,field3:v(i,{...o,field:t.field3}).field,fieldDelimiter:t.fieldDelimiter??void 0,backgroundFillSymbol:g(a,s),defaultSymbol:g(t.defaultSymbol,s),map:n,symbologyType:s.symbologyType}}function qt(i,e,t,s=!1){return{type:"dictionary",config:e.config,fieldMap:e.fieldMap,scaleExpression:e.scaleExpression,url:e.url,symbolOptions:t,symbologyType:t.symbologyType}}function Yt(i,e,t,s=!1){const r=e.getSymbols(),n=r.length?r[0]:null;return{type:"heatmap",symbol:g(n,t,s),symbologyType:t.symbologyType}}const le=ne.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),ee=yt(mt,le);class Fe{constructor(e,t,s){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:r,pixelType:n,textureOnly:a}=e,o=J(n);this.shared=s,this.pixelType=n,this.size=t,this.textureOnly=a,a||(this.data=new o(r)),this._resetRange()}destroy(){this._texture?.dispose();for(const e in this._fbos){const t=this._fbos[e];t&&(e==="0"&&t.detachColorTexture(),t.dispose()),this._fbos[e]=null}this._texture=null}get _textureDesc(){const e=new Oe;return e.wrapMode=Ve.CLAMP_TO_EDGE,e.samplingMode=De.NEAREST,e.dataType=this.pixelType,e.width=this.size,e.height=this.size,e}setData(e,t,s){const r=Re(e),n=this.data,a=r*this.texelSize+t;!n||a>=n.length||(n[a]=s,this.dirtyStart=Math.min(this.dirtyStart,r),this.dirtyEnd=Math.max(this.dirtyEnd,r))}getData(e,t){if(this.data==null)return null;const s=Re(e)*this.texelSize+t;return!this.data||s>=this.data.length?null:this.data[s]}getTexture(e){return this._texture??this._initTexture(e)}getFBO(e,t=0){if(!this._fbos[t]){const s=t===0?this.getTexture(e):this._textureDesc;this._fbos[t]=new ct(e,s)}return this._fbos[t]}get locked(){return!(this.pixelType!==ht.UNSIGNED_BYTE||!this.shared||this.textureOnly||!C("esri-atomics")||!this.data)&&Atomics.load(this.data,0)===1}get hasDirty(){const e=this.dirtyStart;return this.dirtyEnd>=e}updateTexture(e,t){if(!this.locked){try{const s=this.dirtyStart,r=this.dirtyEnd;if(!this.hasDirty)return;this._resetRange();const n=this.data.buffer,a=this.getTexture(e),o=4,l=(s-s%this.size)/this.size,u=(r-r%this.size)/this.size,d=l,c=this.size,p=u,R=l*this.size*o,b=(c+p*this.size)*o-R,m=J(this.pixelType),E=new m(n,R*m.BYTES_PER_ELEMENT,b),h=this.size,S=p-d+1;if(S>this.size)return void le.error(new y("mapview-webgl","Out-of-bounds index when updating AttributeData"));a.updateData(0,0,d,h,S,E)}catch{}t()}}update(e){const{data:t,start:s,end:r}=e;if(t!=null&&this.data!=null){const n=this.data,a=s*this.texelSize;for(let o=0;o<t.length;o++){const l=1<<o%this.texelSize;e.layout&l&&(n[a+o]=t[o])}}this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,r)}resize(e,t){const s=this.size;if(this.size=t,this.textureOnly)return void(s!==this.size&&(this._lastTexture=this._texture,this._texture=null));const r=J(this.pixelType);this.destroy(),this.data=new r(e.buffer)}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}_initTexture(e){const t=new Ie(e,this._textureDesc,this.data??void 0);if(this._lastTexture!=null&&this._fbos[0]){const s=this._lastTexture.descriptor.width,r=this._lastTexture.descriptor.height,n=this._lastTexture.descriptor.dataType,a=this._lastTexture.descriptor.pixelFormat,o=this.getFBO(e),l=ft(n),u=new(J(n))(new ArrayBuffer(s*r*l*this.texelSize)),d=e.getBoundFramebufferObject(),{x:c,y:p,width:R,height:b}=e.getViewport();e.bindFramebuffer(o),o.readPixels(0,0,s,r,a,n,u),t.updateData(0,0,0,2*s,r/2,u),e.setViewport(c,p,R,b),e.bindFramebuffer(d)}return this.destroy(),this._texture=t,this._texture}}class os{constructor(e){this._onUpdate=e,this._initialized=!1,this._forceNextUpload=!1,this._locked=!1}initialize(e){const{blocks:t,shared:s,size:r}=e;if(this.shared=s,this.size=r,ee("Initializing AttributeStoreView",e),this._data==null)this._data=t.map(n=>n!=null?new Fe(n,r,s):null);else for(let n=0;n<this._data.length;n++){const a=this._data[n],o=t[n];o!=null&&(a==null?this._data[n]=new Fe(o,r,s):a.resize(o,r))}this._initialized=!0}destroy(){for(const e of this._data??[])e?.destroy();this._defaultTexture?.dispose()}isEmpty(){return this._data==null}isUpdating(){const e=this._pendingAttributeUpdate!=null,t=e;return C("esri-2d-log-updating")&&console.log(`Updating AttributeStoreView ${t}
  -> hasPendingUpdate ${e}`),t}getBlock(e){return this._data==null?null:this._data[e]}setLabelMinZoom(e,t){this.setData(e,0,1,t)}getLabelMinZoom(e){return this.getData(e,0,1,255)}getFilterFlags(e){return this.getData(e,0,0,0)}getVVSize(e){return this.getData(e,xe,0,0)}getData(e,t,s,r){if(!this._data)return 0;const n=this._data[t];if(n==null)return 0;const a=n.getData(e,s);return a??r}setData(e,t,s,r){this._data[t].setData(e,s,r)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}async requestUpdate(e){if(this._pendingAttributeUpdate)return void le.error(new y("mapview-webgl","Tried to update attribute data with a pending update"));const t=at();return ee("AttributeStoreView Update Requested",e),this._pendingAttributeUpdate={data:e,resolver:t},this._onUpdate(),t.promise}update(){if(this._initialized&&this._pendingAttributeUpdate!=null){C("esri-2d-update-debug")&&console.debug("AttributeStoreView::update");const{data:e,resolver:t}=this._pendingAttributeUpdate,s=this._data;for(let r=0;r<e.blocks.length;r++){const n=e.blocks[r],a=s[r];a!=null&&n!=null&&(ee(`Updating block ${r}`,n),a.update(n))}this._pendingAttributeUpdate=null,t(),this._onUpdate()}}bindTextures(e,t=!0){const s=this._getDefaultTexture(e);if(!this._initialized)return e.bindTexture(s,ge),void(t&&(e.bindTexture(s,_e),e.bindTexture(s,be),e.bindTexture(s,Ee),e.bindTexture(s,H),e.bindTexture(s,j),e.bindTexture(s,Te)));const r=this._data;if(!this._locked||this._forceNextUpload){for(const n of r)n?.updateTexture(e,()=>this._onUpdate());this._forceNextUpload=!1}e.bindTexture(r[ot]?.getTexture(e)??s,ge),t&&(e.bindTexture(r[lt]?.getTexture(e)??s,Te),e.bindTexture(r[ut]?.getTexture(e)??s,_e),e.bindTexture(r[xe]?.getTexture(e)??s,be),e.bindTexture(r[dt]?.getTexture(e)??s,Ee),e.bindTexture(r[H]?.getTexture(e)??s,H),e.bindTexture(r[j]?.getTexture(e)??s,j))}_getDefaultTexture(e){if(this._defaultTexture==null){const t=new Oe;t.wrapMode=Ve.CLAMP_TO_EDGE,t.samplingMode=De.NEAREST,t.width=1,t.height=1,this._defaultTexture=new Ie(e,t,new Uint8Array(4))}return this._defaultTexture}}export{ie as T,re as _,Xt as a,rs as b,is as c,ns as h,g as i,os as j,_t as m,ss as n,N as r,as as w};
