import{gb as G,A as j,gc as J,gd as _,ge as S,gf as U,y as q,a4 as Q,gg as V,gh as X}from"./chunk-m3jlTyOz.js";import{r as B,b as K,n as Y,e as Z,j as $,V as ee,Q as te}from"./chunk-nu9VKcdO.js";import{i as ae}from"./chunk-7E2feUeF.js";import{c as ie}from"./chunk-2jZtXZN9.js";import"./chunk-bntHIBZM.js";import"./chunk-8z8MVveq.js";import"./chunk-YyPMF0Is.js";import"./chunk-CEMOhUyj.js";import"./chunk-pT1ASav_.js";import"./chunk-8PqiWDwx.js";const T=R=>R?.scaleFactor?R.scaleFactor:1,re=96/72;class pe{constructor(t,e){this._spatialReference=t,this._avoidSDF=e,this._resourceCache=new Map,this._lazyImageDataCanvas=null,this._pictureMarkerCache=new Map,this._textRasterizer=new B,this._cimResourceManager=new ae,this._rasterizer=new ie(this._cimResourceManager)}get _imageDataCanvas(){return this._lazyImageDataCanvas??=document.createElement("canvas"),this._lazyImageDataCanvas}get _imageDataContext(){return this._imageDataCanvas.getContext("2d",{willReadFrequently:!0})}get resourceManager(){return this._cimResourceManager}async rasterizeCIMSymbolAsync(t,e,s,i,a,r,l,n,d){if(!t)return null;const{data:g}=t;if(!g||g.type!=="CIMSymbolReference"||!g.symbol)return null;const{symbol:u}=g;r||(r=G(u));const f=await K.resolveSymbolOverrides(g,e,this._spatialReference,a,r,l,n),c=this._imageDataCanvas,y=this._cimResourceManager,w=[];Y.fetchResources(f,y,w),Y.fetchFonts(f,y,w),w.length>0&&await Promise.all(w);const{width:h,height:m}=s,b=se(r,h,m,i),o=Y.getEnvelope(f,b,y);if(!o)return null;const v=(window.devicePixelRatio||1)*re;let p=1,z=0,I=0;switch(u.type){case"CIMPointSymbol":case"CIMTextSymbol":{let P=1;o.width>h&&(P=h/o.width);let C=1;o.height>m&&(C=m/o.height),i==="preview"&&(o.width<h&&(P=h/o.width),o.height<m&&(C=m/o.height)),p=Math.min(P,C),z=o.x+o.width/2,I=o.y+o.height/2}break;case"CIMLineSymbol":{(d||o.height>m)&&(p=m/o.height),I=o.y+o.height/2;const P=o.x*p+h/2,C=(o.x+o.width)*p+h/2,{paths:M}=b;M[0][0][0]-=P/p,M[0][2][0]-=(C-h)/p}break;case"CIMPolygonSymbol":{z=o.x+o.width/2,I=o.y+o.height/2;const P=o.x*p+h/2,C=(o.x+o.width)*p+h/2,M=o.y*p+m/2,F=(o.y+o.height)*p+m/2,{rings:x}=b;P<0&&(x[0][0][0]-=P,x[0][3][0]-=P,x[0][4][0]-=P),M<0&&(x[0][0][1]+=M,x[0][1][1]+=M,x[0][4][1]+=M),C>h&&(x[0][1][0]-=C-h,x[0][2][0]-=C-h),F>m&&(x[0][2][1]+=F-m,x[0][3][1]+=F-m)}}c.width=h*v,c.height=m*v;const D=1;c.width+=2*D,c.height+=2*D;const k=this._imageDataContext,A=te.createIdentity();return A.translate(-z,-I),A.scale(p*v,-p*v),A.translate(h*v/2+D,m*v/2+D),k.clearRect(0,0,c.width,c.height),new Z(k,y,A,!0).drawSymbol(f,b),k.getImageData(0,0,c.width,c.height)}async analyzeCIMSymbol3D(t,e,s,i,a){const r=[],l=e?{geometryType:i,spatialReference:this._spatialReference,fields:e}:null,n=[];Y.fetchFonts(t.data.symbol,this._cimResourceManager,n),await Promise.all(n);const d=new $(this._cimResourceManager,l);let g;await d.analyzeSymbolReference(t.data,this._avoidSDF,r),j(a);for(const u of r)u.cim.type!=="CIMPictureMarker"&&u.cim.type!=="CIMPictureFill"&&u.cim.type!=="CIMPictureStroke"||(g||(g=[]),g.push(this._fetchPictureMarkerResource(u,a))),s&&u.type==="text"&&typeof u.text=="string"&&u.text.includes("[")&&(u.text=J(s,u.text,u.cim.textCase));return g&&await Promise.all(g),r}rasterizeCIMSymbol3D(t,e,s,i,a,r){const l=[];for(const n of t){i&&typeof i.scaleFactor=="function"&&(i.scaleFactor=i.scaleFactor(e,a,r));const d=this._getRasterizedResource(n,e,s,i,a,r);if(!d)continue;let g=0,u=d.anchorX||0,f=d.anchorY||0,c=!1,y=0,w=0;if(s==="esriGeometryPoint"){const h=T(i);if(y=_(n.offsetX,e,a,r)*h||0,w=_(n.offsetY,e,a,r)*h||0,n.type==="marker")g=_(n.rotation,e,a,r)||0,c=n.rotateClockwise??!1;else if(n.type==="text"){if(g=_(n.angle,e,a,r)||0,n.horizontalAlignment!==void 0)switch(n.horizontalAlignment){case"left":u=-.5;break;case"right":u=.5;break;default:u=0}if(n.verticalAlignment!==void 0)switch(n.verticalAlignment){case"top":f=.5;break;case"bottom":f=-.5;break;case"baseline":f=-.25;break;default:f=0}}}d!=null&&l.push({angle:g,rotateClockWise:c,anchorX:u,anchorY:f,offsetX:y,offsetY:w,rasterizedResource:d})}return this.getSymbolImage(l)}getSymbolImage(t){const e=document.createElement("canvas"),s=e.getContext("2d");let i=0,a=0,r=0,l=0;const n=[];for(let f=0;f<t.length;f++){const c=t[f],y=c.rasterizedResource;if(!y)continue;const w=y.size,h=c.offsetX,m=c.offsetY,b=c.anchorX,o=c.anchorY,v=c.rotateClockWise||!1;let p=c.angle,z=S(h)-w[0]*(.5+b),I=S(m)-w[1]*(.5+o),D=z+w[0],k=I+w[1];if(p){v&&(p=-p);const C=Math.sin(p*Math.PI/180),M=Math.cos(p*Math.PI/180),F=z*M-I*C,x=z*C+I*M,O=z*M-k*C,H=z*C+k*M,L=D*M-k*C,W=D*C+k*M,N=D*M-I*C,E=D*C+I*M;z=Math.min(F,O,L,N),I=Math.min(x,H,W,E),D=Math.max(F,O,L,N),k=Math.max(x,H,W,E)}i=z<i?z:i,a=I<a?I:a,r=D>r?D:r,l=k>l?k:l;const A=s.createImageData(y.size[0],y.size[1]);A.data.set(new Uint8ClampedArray(y.image.buffer));const P={offsetX:h,offsetY:m,rotateClockwise:v,angle:p,rasterizedImage:A,anchorX:b,anchorY:o};n.push(P)}e.width=r-i,e.height=l-a;const d=-i,g=l;for(let f=0;f<n.length;f++){const c=n[f],y=this._imageDataToCanvas(c.rasterizedImage),w=c.rasterizedImage.width,h=c.rasterizedImage.height,m=d-w*(.5+c.anchorX),b=g-h*(.5-c.anchorY);if(c.angle){const o=(360-c.angle)*Math.PI/180;s.save(),s.translate(S(c.offsetX),-S(c.offsetY)),s.translate(d,g),s.rotate(o),s.translate(-d,-g),s.drawImage(y,m,b),s.restore()}else s.drawImage(y,m+S(c.offsetX),b-S(c.offsetY))}const u=new U({x:d/e.width-.5,y:g/e.height-.5});return{imageData:e.width!==0&&e.height!==0?s.getImageData(0,0,e.width,e.height):s.createImageData(1,1),anchorPosition:u}}async _fetchPictureMarkerResource(t,e){const s=t.materialHash;if(!this._pictureMarkerCache.get(s)){const i=(await q(t.cim.url,{responseType:"image",signal:e?.signal})).data;this._pictureMarkerCache.set(s,i)}}_imageDataToCanvas(t){const e=this._imageDataCanvas,s=this._imageDataContext;return e.width=t.width,e.height=t.height,s.putImageData(t,0,0),e}_imageTo32Array(t,e,s,i){const a=this._imageDataCanvas,r=this._imageDataContext;if(a.width=e,a.height=s,r.drawImage(t,0,0,e,s),i){r.save();const l=new Q(i);r.fillStyle=l.toHex(),r.globalCompositeOperation="multiply",r.fillRect(0,0,e,s),r.globalCompositeOperation="destination-atop",r.drawImage(t,0,0,e,s),r.restore()}return new Uint32Array(r.getImageData(0,0,e,s).data.buffer)}_getRasterizedResource(t,e,s,i,a,r){let l,n,d;if(t.type==="text")return this._rasterizeTextResource(t,e,i,a,r);({analyzedCIM:l,hash:n}=ne(t,e,a,r));const f=T(i);if(t.cim.type==="CIMPictureMarker"){const w=_(t.size,e,a,r)*f,{image:h,width:m,height:b}=this._getPictureResource(t,w,_(t.color,e,a,r));return d={image:h,size:[m,b],sdf:!1,simplePattern:!1,anchorX:t.anchorPoint?t.anchorPoint.x:0,anchorY:t.anchorPoint?t.anchorPoint.y:0},d}V(l,f,{preserveOutlineWidth:!1});const c=l;n+=s,i&&(n+=JSON.stringify(i));const y=this._resourceCache;return y.has(n)?y.get(n):(d=this._rasterizer.rasterizeJSONResource({cim:c,type:t.type,url:t.url,mosaicHash:n,size:null,path:null},window.devicePixelRatio||1,this._avoidSDF),y.set(n,d),d)}_rasterizeTextResource(t,e,s,i,a){const r=T(s),l=_(t.text,e,i,a);if(!l||l.length===0)return null;const n=t.cim,d=_(n?.fontFamilyName||t.fontName,e,i,a),g=_(n?.font?.style||t.style,e,i,a),u=_(n?.font?.weight||t.weight,e,i,a),f=_(n?.font?.decoration||t.decoration,e,i,a),c=_(t.size,e,i,a)*r,y=_(t.horizontalAlignment,e,i,a),w=_(t.verticalAlignment,e,i,a),h=X(_(t.color,e,i,a)),m=X(_(t.outlineColor,e,i,a)),b=_(t.outlineSize,e,i,a),o=t.backgroundColor!=null?X(t.backgroundColor):null,v=t.borderLineColor!=null?X(t.borderLineColor):null,p=t.borderLineWidth!=null?t.borderLineWidth:null,z={color:h,size:c,horizontalAlignment:y,verticalAlignment:w,font:{family:d,style:g,weight:u,decoration:f},halo:{size:b||0,color:m,style:g},backgroundColor:o,borderLine:v!=null&&p!=null?{color:v,size:p}:null,pixelRatio:1,premultiplyColors:!this._avoidSDF};return this._textRasterizer.rasterizeText(l,z)}_getPictureResource(t,e,s){const i=this._pictureMarkerCache.get(t.materialHash);if(!i)return null;const a=i.height/i.width,r=e?a>1?S(e):S(e)/a:i.width,l=e?a>1?S(e)*a:S(e):i.height;return{image:this._imageTo32Array(i,r,l,s),width:r,height:l}}}function se(R,t,e,s){const a=-t/2+1,r=t/2-1,l=e/2-1,n=-e/2+1;switch(R){case"esriGeometryPoint":return{x:0,y:0};case"esriGeometryPolyline":return{paths:[[[a,0],[0,0],[r,0]]]};default:return s==="legend"?{rings:[[[a,l],[r,0],[r,n],[a,n],[a,l]]]}:{rings:[[[a,l],[r,l],[r,n],[a,n],[a,l]]]}}}function ne(R,t,e,s){let i,a;return typeof R.materialHash=="function"?(i=(0,R.materialHash)(t,e,s),a=ee(R.cim,R.materialOverrides)):(i=R.materialHash,a=R.cim),{analyzedCIM:a,hash:i}}export{pe as CIMSymbolRasterizer};
