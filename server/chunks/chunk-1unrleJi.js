import { aV as e$4, aX as y$3, a_ as c$6, bZ as S$2, fb as d$2, tC as h$4, cU as s$2, ce as d$3, eV as v$1, cm as e$5, b$ as u$3, ty as R$4, tw as G$3, tx as q$3, lu as a$8, lp as b$2, xB as e$6, iy as o$2, nJ as v$2, nH as l$2, uf as _$1, nG as u$5, nP as c$7, vv as H$2, C0 as $, o3 as L$3, kR as h$5, gk as n$4, C1 as h$6, sV as w$3, ls as i$4, C2 as l$3, aW as n$5, cl as A$7, C3 as a$9, h3 as g$4, gs as l$4, bO as G$4, l2 as h$7, C4 as U$2, C5 as V$2, tu as E$2, qH as h$8, C6 as t$2, kU as e$7, ds as o$3, xN as r$4, vO as c$8, lh as E$3, li as a$a, xO as t$3, fF as o$4, aG as u$6, nQ as g$5, l1 as H$3, C7 as l$5, fm as m$5, l7 as b$3, fk as e$8, ku as t$4, aJ as n$6, yx as c$9, C8 as p$5, kY as o$5, jW as h$9, jB as i$5, j3 as W$1, g9 as a$b, vJ as p$6, C9 as u$7, fg as r$5, u_ as L$4, Ca as l$6, Cb as c$a, xG as O$2, Cc as r$6, Cd as C$5, xb as f$4, f6 as p$7, cf as C$6, bX as P$3, c8 as u$8, ug as r$7, Ce as e$9, uP as ee, Cf as o$6, fh as i$6, Cg as t$5, eP as r$8, dh as i$7, vR as x$4, fB as n$7, fA as P$4, Ch as R$5, lr as c$b, Ci as w$4, Cj as S$3, Ck as w$5, nF as e$a, qs as x$5, Cl as C$7, Cm as D$4, Cn as h$a, Co as P$5, Cp as wt$1, Cq as mt, l3 as q$5, qC as f$5, uR as e$b, uS as t$6, uE as R$6, qF as c$c, qB as p$8, aE as r$9, qE as d$5, uU as _$2, lk as e$c, im as e$d, Cr as v$3, v4 as Y$1, Cs as ft, vN as d$6, g8 as l$7, Ct as k$2, Cu as pt, uY as at, vI as U$3, aF as e$e, fE as z$3, qu as P$6, fD as _$3, Cv as L$5, pn as i$8, uL as l$8, uF as f$6, es as e$f, b0 as has, Cw as N$2, Cx as D$5, sG as l$9, bQ as V$3, gm as l$a, bW as h$b, Cy as o$7, Cz as P$7, CA as O$3, CB as R$7, CC as q$6, gl as m$6, CD as g$6, gt as e$g, gr as V$4, xL as f$7, vQ as g$7, CE as Z, CF as Y$2, f$ as F$2, uD as j$4, qy as E$4, CG as J$1, CH as t$7, nN as x$6, f_ as v$4, CI as f$8, CJ as v$5, v1 as E$5, CK as Z$1, tX as y$5, vX as o$8, kH as s$3, CL as C$8, CM as A$8, ll as st, h_ as I$1, nO as A$9, CN as y$6, vP as t$8, CO as J$2, le as u$b, l9 as i$9, aB as f$9, uB as u$c, gb as m$8, CP as M$6, CQ as l$c, CR as n$a, m6 as A$a, sC as l$d, CS as b$4, tv as F$3, m4 as t$9, qt as O$4, qA as b$5, CT as r$c, aD as M$7, uZ as it, vy as p$a, CU as p$b, CV as v$7, CW as y$7, CX as z$4, cY as x$7, CY as A$b, cr as q$7, uH as x$8, qr as m$9, qz as S$5, aI as r$d, v5 as e$h, qq as Z$2, qk as W$3, iH as z$5, t0 as J$3, fX as q$8 } from "./chunk-ejFG4zJ0.js";
import { q as q$4 } from "./chunk-TCdzNZ_N.js";
import { x as x$3 } from "./chunk-D8vtbm22.js";
import { u as u$4, y as y$4, m as m$7, R as R$8, c as c$e, g as g$8 } from "./chunk-MIHgBujt.js";
import { d as d$4 } from "./chunk-l9MdE61v.js";
import { J, W as W$2, v as v$6, d as d$7, F as F$4, E as E$6 } from "./chunk-nDggrq6U.js";
import { n as n$8 } from "./chunk-Fnn8HIGG.js";
import { S as S$4 } from "./chunk-KUOhxWR4.js";
import { u as u$9, r as r$b } from "./chunk-IhjTEMBX.js";
import { a as a$c, l as l$b, r as r$a, n as n$9, c as c$d, p as p$9 } from "./chunk-H9yM79cA.js";
import { u as u$a } from "./chunk-Dwvm8fnS.js";
import { I as I$2, H as H$4, S as Si, g as g$9, l as li, _ as _i, v as v$8, i as gi, E as Ei, B as Ii, d as ci, D as Hi, U as Ui } from "./chunk-25Z-gFzh.js";
import { l as l$e } from "./chunk-dLtbcH7z.js";
import { i as i$a, o as o$9, p as p$c } from "./chunk-6eToMQsk.js";
import "luxon";
import "@esri/arcgis-html-sanitizer";
import "@esri/calcite-components/dist/components/index.js";
import "./chunk-V0WGYzWu.js";
import "./chunk-OKVnMJUL.js";
import "./chunk-19x7Cx8s.js";
import "./chunk-cRQzjRBY.js";
import "./chunk--_aQKBqP.js";
import "./chunk-feYAbK6R.js";
const G$2 = 3025, M$5 = { default: 15, far: 25 };
let A$6 = class A extends S$2 {
  constructor(t2) {
    super(t2), this.context = null, this.stagedVertex = null, this.visible = true, this.edgeDistance = "default", this._messagesUnits = null, this._labelInfos = [], this._nextLabelIndex = 0;
  }
  initialize() {
    const t2 = d$2(async (t3) => {
      const e4 = await h$4("esri/core/t9n/Units");
      s$2(t3), this._messagesUnits = e4;
    });
    this.addHandles([d$3(() => [null != this.context && this.getCameraOrExtent(this.context), this.visible, this._edgeDistancePixels, this.stagedVertex, this._messagesUnits], () => this._update()), ...["vertex-add", "vertex-update", "vertex-remove"].map((t3) => v$1(() => this.context?.editGeometryOperations, t3, () => this._update())), e$5(() => t2.abort()), d$3(() => this._colors, (t3) => this._updateStyle(t3))]);
  }
  destroy() {
    for (this._nextLabelIndex = 0; this._labelInfos.length; )
      this._destroyLabel(this._labelInfos.pop());
  }
  get updating() {
    return null == this._messagesUnits;
  }
  get test() {
    return { labelContents: this._labelInfos.slice(0, this._nextLabelIndex).map((t2) => t2.label.text) };
  }
  get _edgeDistancePixels() {
    return M$5[this.edgeDistance];
  }
  get _colors() {
    const t2 = this.context?.view.effectiveTheme.textColor ?? u$3.fromArray([255, 255, 255]);
    return { textColor: t2, backgroundColor: R$4(G$3(t2, q$3.Low), 0.6) };
  }
  _update() {
    if (this.destroyed)
      return;
    this._nextLabelIndex = 0;
    const { context: t2, stagedVertex: e4 } = this;
    if (!t2)
      return this._destroyUnusedLabels();
    const { editGeometryOperations: o2 } = t2, { components: s2, geometry: r3, coordinateHelper: i2 } = o2.data;
    if (!r3)
      return this._destroyUnusedLabels();
    const n2 = s2.length;
    for (let l2 = 0; l2 < n2; ++l2) {
      const s3 = R$3(r3, o2, e4, i2, l2);
      if (s3.length < 2 || !q$2(s3, t2.view, t2.elevationInfo, i2.spatialReference))
        continue;
      const a4 = 1 === n2 && !a$8(s3);
      let c2 = T$2, p4 = X;
      this.toScreenPointArray(t2, s3[0], c2);
      for (let e5 = 1; e5 < s3.length; ++e5) {
        const o3 = s3[e5 - 1], r4 = s3[e5];
        this.toScreenPointArray(t2, r4, p4), this._addLabel(t2, o3, c2, r4, p4, a4), [c2, p4] = [p4, c2];
      }
    }
    this._destroyUnusedLabels();
  }
  _updateStyle({ textColor: t2, backgroundColor: e4 }) {
    const o2 = this._nextLabelIndex, s2 = this._labelInfos;
    for (let r3 = 0; r3 < o2; ++r3) {
      const { label: o3 } = s2[r3];
      o3.textColor = t2, o3.backgroundColor = e4;
    }
  }
  _addLabel(t2, e4, o2, s2, r3, i2) {
    const { label: n2 } = this._getOrCreateLabel(t2);
    if (!this.visible || b$2(o2, r3) < G$2)
      return void (n2.visible = false);
    const { spatialReference: l2 } = t2.editGeometryOperations.data, a4 = u$4(e4, s2, l2), c2 = this._messagesUnits, h3 = e$6(t2.view);
    n2.text = null != c2 && null != a4 ? q$4(c2, a4, h3) : "", n2.visible = true;
    const m3 = r3[0] - o2[0], d2 = r3[1] - o2[1];
    i2 ? o$2(F$1, -d2, m3) : o$2(F$1, d2, -m3), v$2(F$1, F$1), l$2(F$1, F$1, this._edgeDistancePixels), _$1(H$1, o2, r3, 0.5), u$5(H$1, H$1, F$1), n2.position = [H$1[0], H$1[1]], Math.abs(F$1[0]) > Math.abs(F$1[1]) ? n2.anchor = F$1[0] > 0 ? "left" : "right" : n2.anchor = -F$1[1] < 0 ? "top" : "bottom";
  }
  _getOrCreateLabel(t2) {
    const e4 = this._labelInfos.length > this._nextLabelIndex, { textColor: o2, backgroundColor: s2 } = this._colors;
    if (e4) {
      const t3 = this._labelInfos[this._nextLabelIndex++], { label: e5 } = t3;
      return e5.textColor = o2, e5.backgroundColor = s2, t3;
    }
    const r3 = new x$3({ anchor: "center", fontSize: 8, textColor: o2, backgroundColor: s2 });
    t2.view.overlay?.items.add(r3);
    const i2 = { label: r3 };
    return this._labelInfos.push(i2), this._nextLabelIndex = this._labelInfos.length, i2;
  }
  _destroyUnusedLabels() {
    for (; this._labelInfos.length > this._nextLabelIndex; )
      this._destroyLabel(this._labelInfos.pop());
  }
  _destroyLabel({ label: t2 }) {
    this.context?.view.overlay?.items.remove(t2), t2.destroy();
  }
};
function R$3(t2, e4, o2, s2, r3) {
  const i2 = [];
  if (e4.data.components[r3].iterateVertices((t3) => {
    i2.push(s2.toXYZ(t3.pos, c$7.get()));
  }), 0 === r3 && null != o2 && i2.push(s2.toXYZ(o2, c$7.get())), i2.length < 2)
    return i2;
  const n2 = i2[0], l2 = i2[i2.length - 1];
  return "polygon" === t2.type && i2.length > 2 && !H$2(n2, l2) && i2.push(n2), i2;
}
function q$2(t2, e4, o2, s2) {
  if ("2d" === e4.type)
    return true;
  const r3 = $(s2) ?? 1, i2 = L$3(s2), n2 = (t3) => h$6(e4, t3, s2, o2, w$3) ?? 0;
  for (let l2 = 1; l2 < t2.length; ++l2) {
    const e5 = t2[l2 - 1], o3 = t2[l2], s3 = (o3[0] - e5[0]) * r3, a4 = (o3[1] - e5[1]) * r3, c2 = (n2(o3) - n2(e5)) * i2;
    if (Math.abs(c2) / Math.sqrt(s3 * s3 + a4 * a4) > z$2)
      return false;
  }
  return true;
}
e$4([y$3()], A$6.prototype, "context", void 0), e$4([y$3()], A$6.prototype, "stagedVertex", void 0), e$4([y$3()], A$6.prototype, "visible", void 0), e$4([y$3()], A$6.prototype, "edgeDistance", void 0), e$4([y$3()], A$6.prototype, "updating", null), e$4([y$3()], A$6.prototype, "_messagesUnits", void 0), e$4([y$3()], A$6.prototype, "_edgeDistancePixels", null), e$4([y$3()], A$6.prototype, "_colors", null), A$6 = e$4([c$6("esri.views.interactive")], A$6);
const z$2 = h$5(5), F$1 = n$4(), H$1 = n$4(), T$2 = i$4(), X = i$4();
let a$7 = class a extends A$6 {
  getCameraOrExtent({ view: e4 }) {
    return e4.state.camera;
  }
  toScreenPointArray({ view: e4, elevationInfo: t2, editGeometryOperations: o2 }, s2, a4 = i$4()) {
    const { spatialReference: m3 } = o2.data.coordinateHelper;
    return l$3(s2, m3, t2, e4, c$5), e4.state.camera.projectToScreen(c$5, a4), a4;
  }
};
a$7 = e$4([c$6("esri.views.3d.interactive.SegmentLabels3D")], a$7);
const c$5 = n$5();
function a$6(o2, s2) {
  const { graphic: i2 } = o2;
  return [d$3(() => o2.displaying, (e4) => {
    e4 ? c$4(i2, s2) : p$4(i2, s2);
  }, { ...A$7 }), e$5(() => p$4(i2, s2))];
}
function c$4(e4, t2) {
  const { geometry: r3 } = e4;
  f$3(r3, t2) && e4.notifyMeshTransformChanged({ action: a$9.EnableFastUpdates });
}
function p$4(e4, t2) {
  const { geometry: r3 } = e4;
  f$3(r3, t2) && e4.notifyMeshTransformChanged({ action: a$9.DisableFastUpdates });
}
function f$3(e4, { state: { viewingMode: t2 }, spatialReference: r3 }) {
  if ("mesh" !== e4?.type)
    return false;
  const { vertexSpace: i2, spatialReference: a4 } = e4;
  if (!g$4(i2))
    return false;
  const { type: c2 } = i2;
  return t2 === l$4.Global && "local" === c2 || t2 === l$4.Local && G$4(r3, a4) && "georeferenced" === c2 && !a4.isGeographic;
}
const d$1 = 0.3;
function u$2(o2, t2) {
  t2 && Object.assign(o2, t2);
}
let g$3 = class g {
  constructor(o2) {
    this.height = 90, this.coneHeight = 40, this.coneWidth = 23, this.width = 3, this.renderOccluded = h$7.Opaque, this.color = o2.accent;
  }
};
let f$2 = class f {
  constructor({ colors: o2, ...t2 }) {
    this.size = 11, this.outlineSize = 1, this.collisionPadding = 9, this.color = o2.accent, this.outlineColor = o2.outline, this.renderOccluded = h$7.Opaque, this.hoverOutlineColor = o2.selectedOutline, u$2(this, t2);
  }
  applyColor(o2) {
    this._apply(this.color, o2);
  }
  applyOutline(o2) {
    this._apply(this.outlineColor, o2);
  }
  applyHoverOutline(o2) {
    this._apply(this.hoverOutlineColor, o2);
  }
  _apply(o2, t2) {
    t2.setParameters({ color: E$2(o2), renderOccluded: this.renderOccluded });
  }
};
let w$2 = class w {
  constructor({ colors: o2, ...t2 }) {
    this.size = 40, this.height = 0.2, this.offset = 0.25, this.collisionPadding = 2, this.renderOccluded = h$7.Transparent, this.minSquaredEdgeLength = 900, this.color = R$4(o2.accent, 0.5), this.hoverColor = o2.accent, u$2(this, t2);
  }
  applyColor(o2) {
    this._apply(this.color, o2);
  }
  applyHover(o2) {
    this._apply(this.hoverColor, o2);
  }
  _apply(o2, t2) {
    t2.setParameters({ color: E$2(o2), renderOccluded: this.renderOccluded });
  }
};
let C$4 = class C {
  constructor(o2) {
    this.vertex = new f$2({ colors: o2, color: o2.accent, outlineColor: o2.outline }), this.edge = new f$2({ colors: o2, color: U$2(R$4(o2.accent, 2 / 3), 0.5), outlineColor: R$4(o2.outline, 0.5), size: 8, collisionPadding: 8 }), this.selected = new f$2({ colors: o2, color: o2.selected, outlineColor: o2.outline }), this.edgeOffset = new w$2({ colors: o2 });
  }
};
let m$4 = class m {
  constructor({ colors: o2, ...t2 }) {
    this.width = 1.5, this.stipplePattern = h$8(3.3), this.falloff = 0, this.innerWidth = 1.5, this.renderOccluded = h$7.OccludeAndTransparent, this.color = o2.selected, this.stippleOffColor = o2.outline, this.innerColor = o2.selected, u$2(this, t2);
  }
  apply(o2) {
    o2.color = E$2(this.color), o2.width = this.width, o2.stipplePattern = this.stipplePattern, o2.stippleOffColor = E$2(this.stippleOffColor), o2.falloff = this.falloff, o2.innerWidth = this.innerWidth, o2.innerColor = E$2(this.innerColor), o2.renderOccluded = this.renderOccluded;
  }
};
let O$1 = class O {
  constructor({ colors: o2, ...t2 }) {
    this.size = 4, this.outlineSize = 1, this.shape = "square", this.color = o2.selected, this.outlineColor = o2.outline, u$2(this, t2);
  }
  apply(o2) {
    o2.color = E$2(this.color), o2.size = this.size, o2.outlineSize = this.outlineSize, o2.outlineColor = E$2(this.outlineColor), o2.primitive = this.shape;
  }
};
let y$2 = class y {
  constructor({ colors: o2, ...t2 }) {
    this.innerWidth = 1, this.glowWidth = 8, this.glowFalloff = 8, this.globalAlpha = d$1, this.globalAlphaContrastBoost = 1.5, this.radius = 3, this.innerColor = o2.selected, this.glowColor = o2.accent, this.heightFillColor = o2.accent, u$2(this, t2);
  }
  apply(o2, e4 = 1) {
    const l2 = { glowColor: u$3.toUnitRGB(this.glowColor), glowFalloff: this.glowFalloff, glowWidth: this.glowWidth, innerColor: u$3.toUnitRGB(this.innerColor), innerWidth: this.innerWidth, globalAlpha: this.globalAlpha * e4 * this.glowColor.a, globalAlphaContrastBoost: this.globalAlphaContrastBoost, intersectsLineRadius: this.radius };
    "style" in o2 ? o2.style = l2 : o2.laserlineStyle = l2;
  }
};
let A$5 = class A2 {
  constructor(o2) {
    this.outline = new m$4({ colors: o2, color: o2.stippleOff, renderOccluded: h$7.OccludeAndTransparentStencil, stippleOffColor: o2.stippleOn, innerWidth: 0 }), this.staged = new m$4({ colors: o2, color: o2.stippleOn, renderOccluded: h$7.OccludeAndTransparentStencil, innerColor: o2.stagedSolid, stippleOffColor: o2.stippleOff }), this.shadowStyle = new y$2({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 8, glowWidth: 8, innerColor: o2.selected, innerWidth: 1 });
  }
};
class W {
  constructor(o2) {
    this.outline = new O$1({ colors: o2, color: o2.selected, outlineColor: o2.outline, outlineSize: 1, shape: "circle", size: 4 }), this.shadowStyle = new y$2({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 1.5, glowWidth: 6, innerColor: o2.selected, innerWidth: 1, radius: 2 });
  }
}
let S$1 = class S extends m$4 {
  constructor({ colors: o2, ...t2 }) {
    super({ colors: o2 }), this.extensionType = V$2.GROUND_RAY, u$2(this, t2);
  }
};
let b$1 = class b {
  constructor(o2) {
    this.laserlineAlphaMultiplier = 1.5, this.heightPlaneAngleCutoff = 20, this.lineGraphics = new A$5(o2), this.pointGraphics = new W(o2), this.heightPlane = new y$2({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 8, glowWidth: 8, innerColor: o2.selected, innerWidth: 1 }), this.heightBox = new y$2({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 8, glowWidth: 8, innerColor: o2.selected, innerWidth: 0, heightFillColor: o2.accent }), this.zVerticalLine = new S$1({ colors: o2, color: R$4(o2.accent, 5 * d$1 / 3), falloff: 2, innerColor: R$4(o2.selected, 0), renderOccluded: h$7.OccludeAndTransparent, stipplePattern: null, width: 5, extensionType: V$2.GROUND_RAY });
  }
};
let z$1 = class z extends S$2 {
  constructor(o2) {
    super(o2);
  }
  get colors() {
    const o2 = this.getTheme().accentColor, e4 = o2.a;
    return { accent: o2, contrast: G$3(o2), selected: u$3.fromArray([255, 255, 255, e4]), selectedOutline: u$3.fromArray([255, 255, 255, e4]), staged: u$3.fromArray([12, 207, 255, e4]), stagedSolid: u$3.fromArray([12, 207, 255, 1]), outline: u$3.fromArray([0, 0, 0, 0.5 * e4]), stippleOn: u$3.fromArray([255, 255, 255, 1]), stippleOff: u$3.fromArray([0, 0, 0, 0.5]) };
  }
  get visualElements() {
    return new b$1(this.colors);
  }
  get manipulators() {
    return new C$4(this.colors);
  }
  get zManipulator() {
    return new g$3(this.colors);
  }
};
e$4([y$3()], z$1.prototype, "colors", null), e$4([y$3()], z$1.prototype, "visualElements", null), e$4([y$3()], z$1.prototype, "manipulators", null), e$4([y$3()], z$1.prototype, "zManipulator", null), e$4([y$3()], z$1.prototype, "getTheme", void 0), z$1 = e$4([c$6("esri.views.3d.interactive.editingTools.settings.Settings")], z$1);
let w$1 = class w2 extends t$2 {
  constructor(t2) {
    super(t2), this._attachmentOrigin = e$7(0, 0, 0, null), this._attachmentOriginDirty = true, this.events = new o$3(), this._geometry = null, this._width = 1, this._color = r$4(1, 0, 1, 1), this._innerWidth = 0, this._innerColor = r$4(1, 1, 1, 1), this._stipplePattern = null, this._stippleOffColor = null, this._falloff = 0, this._elevationInfo = null, this._laserlineStyle = null, this._laserlineEnabled = false, this._renderOccluded = h$7.OccludeAndTransparentStencil, this._attachmentOrigin.spatialReference = t2.view.spatialReference, this._laserline = new c$8({ view: t2.view, isDecoration: t2.isDecoration }), this.applyProperties(t2), this.attached = t2.attached ?? true;
  }
  destroy() {
    this._laserline.destroy(), super.destroy();
  }
  createObject3DResourceFactory(e4) {
    return { view: e4, createResources: (e5) => this._createObject3DResources(e5), destroyResources: (e5) => this._destroyExternalResources(e5), recreateGeometry: (e5, t2) => {
      e5.geometries.length = 0, this._recreateGeometry(t2, e5.material, e5.geometries);
    } };
  }
  createDrapedResourceFactory(e4) {
    return { view: e4, createResources: () => this._createDrapedResources(), destroyResources: (e5) => this._destroyExternalResources(e5), recreateGeometry: (e5) => {
      e5.geometries = this._createRenderGeometriesDraped(e5.material), this._attachmentOriginChanged();
    } };
  }
  get _laserlineAttached() {
    return this.attached && this.visible && null != this._laserlineStyle && !this.isDraped && this.laserlineEnabled;
  }
  onAttachedChange(e4) {
    this._laserline.attached = this._laserlineAttached, e4 && this._attachmentOriginChanged();
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e4) {
    this._geometry = e4, this.recreateGeometry();
  }
  get width() {
    return this._width;
  }
  set width(e4) {
    e4 !== this._width && (this._width = e4, this._updateMaterial());
  }
  get color() {
    return this._color;
  }
  set color(e4) {
    E$3(e4, this._color) || (a$a(this._color, e4), this._updateMaterial());
  }
  get innerWidth() {
    return this._innerWidth;
  }
  set innerWidth(e4) {
    e4 !== this._innerWidth && (this._innerWidth = e4, this._updateMaterial());
  }
  get innerColor() {
    return this._innerColor;
  }
  set innerColor(e4) {
    E$3(e4, this._innerColor) || (a$a(this._innerColor, e4), this._updateMaterial());
  }
  get stipplePattern() {
    return this._stipplePattern;
  }
  set stipplePattern(e4) {
    const t2 = null != e4 != (null != this._stipplePattern);
    this._stipplePattern = e4, t2 ? this.recreate() : this._updateMaterial();
  }
  get stippleOffColor() {
    return this._stippleOffColor;
  }
  set stippleOffColor(e4) {
    e4 && this._stippleOffColor && E$3(e4, this._stippleOffColor) || (this._stippleOffColor = e4 ? t$3(e4) : null, this._updateMaterial());
  }
  get falloff() {
    return this._falloff;
  }
  set falloff(e4) {
    e4 !== this._falloff && (this._falloff = e4, this._updateMaterial());
  }
  get elevationInfo() {
    return this._elevationInfo;
  }
  set elevationInfo(e4) {
    this._elevationInfo = e4, this.recreateGeometry();
  }
  get laserlineStyle() {
    return this._laserlineStyle;
  }
  set laserlineStyle(e4) {
    this._laserlineStyle = e4, this._laserline.attached = this._laserlineAttached, null != e4 && (this._laserline.style = e4);
  }
  get laserlineEnabled() {
    return this._laserlineEnabled;
  }
  set laserlineEnabled(e4) {
    this._laserlineEnabled !== e4 && (this._laserlineEnabled = e4, this._laserline.attached = this._laserlineAttached);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e4) {
    e4 !== this._renderOccluded && (this._renderOccluded = e4, this._updateMaterial());
  }
  get attachmentOrigin() {
    if (!this._attachmentOriginDirty)
      return this._attachmentOrigin;
    const e4 = this.object3dResources.resources?.geometries;
    if (!e4 || 0 === e4.length)
      return null;
    o$4(P$2, 0, 0, 0);
    let s2 = 0;
    for (const t2 of e4)
      t2.computeAttachmentOrigin(D$3) && (u$6(P$2, P$2, D$3), s2++);
    return 0 === s2 ? null : (g$5(P$2, P$2, 1 / s2), this.view.renderCoordsHelper.fromRenderCoords(P$2, this._attachmentOrigin), this._attachmentOriginDirty = false, this._attachmentOrigin);
  }
  _updateMaterial() {
    null != this.object3dResources.resources && this.object3dResources.resources.material.setParameters(this._materialParameters), null != this.drapedResources.resources && this.drapedResources.resources.material.setParameters(this._materialParameters);
  }
  get _isClosed() {
    return null != this.geometry && "polygon" === this.geometry.type;
  }
  get _materialParameters() {
    return { width: this._width, color: this._color, stippleOffColor: this._stippleOffColor, stipplePattern: this._stipplePattern, stipplePreferContinuous: false, isClosed: this._isClosed, falloff: this._falloff, innerColor: this._innerColor, innerWidth: this._innerWidth, join: "round", hasPolygonOffset: true, renderOccluded: this._normalizedRenderOccluded, isDecoration: this.isDecoration };
  }
  get _normalizedRenderOccluded() {
    return this.isDraped && this._renderOccluded === h$7.OccludeAndTransparentStencil ? h$7.OccludeAndTransparent : this._renderOccluded;
  }
  _recreateGeometry(e4, t2, r3) {
    this._createRenderGeometries(t2, r3);
    for (const i2 of r3)
      e4.addGeometry(i2);
    this._attachmentOriginChanged();
  }
  _attachmentOriginChanged() {
    this._attachmentOriginDirty = true, this.events.emit("attachment-origin-changed");
  }
  _destroyExternalResources(e4) {
    e4.geometries = [];
  }
  _createObject3DResources(e4) {
    const t2 = new H$3(this._materialParameters), r3 = new Array();
    return this._recreateGeometry(e4, t2, r3), { material: t2, geometries: r3, forEach: (e5) => {
      e5(t2), r3.forEach(e5);
    } };
  }
  _createDrapedResources() {
    const e4 = new H$3(this._materialParameters);
    return { material: e4, geometries: this._createRenderGeometriesDraped(e4) };
  }
  _createRenderGeometriesDraped(e4) {
    const { geometry: t2, view: r3 } = this, i2 = r3.basemapTerrain.spatialReference;
    if (null == t2 || null == i2)
      return [];
    return l$5(t2, i2).lines.map(({ position: t3 }) => {
      const s2 = { overlayInfo: { spatialReference: i2, renderCoordsHelper: r3.renderCoordsHelper }, attributeData: { position: t3 }, removeDuplicateStartEnd: this._isClosed };
      return new m$5(b$3(e4, s2));
    });
  }
  calculateMapBounds(e4) {
    if (null == this.object3dResources.resources)
      return false;
    const t2 = this.view.renderCoordsHelper;
    for (const r3 of this.object3dResources.resources.geometries) {
      const i2 = r3.attributes.get(e$8.POSITION), s2 = t$4(i2.data.length);
      n$6(i2.data, t2.spatialReference, 0, s2, this.view.spatialReference, 0, i2.data.length / 3), c$9(e4, s2);
    }
    return true;
  }
  _createRenderGeometries(e4, t2) {
    const r3 = this.geometry;
    if (null == r3)
      return;
    const i2 = p$5(r3, this.view.elevationProvider, this.view.renderCoordsHelper, o$5.fromElevationInfo(this.elevationInfo ?? new h$9({ mode: i$5(r3, null) }))), s2 = new Array();
    for (const { position: n2, mapPositions: o2 } of i2.lines) {
      const r4 = { mapPositions: o2, attributeData: { position: n2 }, removeDuplicateStartEnd: this._isClosed };
      t2.push(b$3(e4, r4)), s2.push(n2);
    }
    this._laserline.pathVerticalPlane = s2;
  }
};
const D$3 = n$5(), P$2 = n$5();
let e$3 = class e extends o$3.EventedAccessor {
  constructor(r3) {
    super(r3), this.tracking = false, this.displaying = false, this.isDraped = false;
  }
};
e$4([y$3({ constructOnly: true })], e$3.prototype, "graphic", void 0), e$4([y$3()], e$3.prototype, "tracking", void 0), e$4([y$3()], e$3.prototype, "displaying", void 0), e$4([y$3()], e$3.prototype, "isDraped", void 0), e$3 = e$4([c$6("esri.views.3d.layers.graphics.GraphicState")], e$3);
function i$3(o2, i2) {
  const l2 = o2?.geometry;
  if (!o2 || "mesh" !== l2?.type || !i2)
    return;
  const { renderCoordsHelper: p4, elevationProvider: u2 } = i2, { camera: h3 } = i2.state, { extent: d2 } = l2, { center: x3, spatialReference: g3 } = d2, v2 = W$1(g3), j2 = L$3(g3), z3 = W$1(p4.spatialReference), y4 = d2.width * v2, C4 = d2.height * j2, R3 = (d2.zmax ?? 0) * j2, U2 = R3 - (d2.zmin ?? 0) * j2, b3 = Math.max(y4, C4, U2) / z3, { x: w4, y: P2 } = x3, S3 = x3.z ?? 0;
  o$4(f$1, w4, P2, S3), p4.toRenderCoords(f$1, g3, f$1);
  const T2 = b3 / h3.computeScreenPixelSizeAt(f$1);
  if (T2 > h3.width * a$5)
    return "meshTooClose";
  if (T2 < m$3)
    return "meshTooFar";
  const k2 = a$b(o2), { absoluteZ: A4 } = p$6(w4, P2, R3, g3, i2, k2);
  return A4 < (u2.getElevation(w4, P2, S3, g3, "ground") ?? 0) * j2 + U2 * c$3 ? "meshUnderground" : "mesh";
}
const m$3 = 20, a$5 = 1, c$3 = 0.1, f$1 = n$5();
let z2 = class extends J {
  constructor(e4) {
    super(e4), this._activeVertexVisualElement = null, this._createGraphicState = null, this._outlineVisualElement = null, this._verticesVisualElement = null, this._verticalLineVisualElement = null, this._settings = new z$1({ getTheme: () => this.view.effectiveTheme }), this.geometryType = null, this.type = "draw-3d";
  }
  initialize() {
    const { mode: e4, offset: t2, unit: i2 } = this.elevationInfo;
    this.internalGraphicsLayer.elevationInfo = new h$9({ mode: e4, offset: t2, unit: i2 });
    const s2 = this.geometryToPlace;
    s2 && this.addHandles([d$3(() => s2.vertexSpace.origin, () => this.graphic?.notifyMeshTransformChanged(), C$6), d$3(() => ({ vertexAttributes: s2.vertexAttributes, alwaysUpdate: {} }), () => this.graphic?.notifyGeometryChanged(), C$6)]);
  }
  normalizeCtorArgs(e4) {
    if (!e4.elevationInfo) {
      const t2 = e4.hasZ ?? true;
      return { ...e4, elevationInfo: u$7(t2) };
    }
    return e4;
  }
  initializeGraphic(e4) {
    const { view: t2 } = this, s2 = this._createGraphicState = new e$3({ graphic: e4 });
    return r$5([t2.maskOccludee(e4), t2.trackGraphicState(s2), d$3(() => ({ element: this._outlineVisualElement, isDraped: s2.isDraped }), ({ element: e5, isDraped: t3 }) => {
      e5 && (e5.isDraped = t3);
    }, A$7), this._setupLoadingIndicator(s2), ...a$6(s2, t2)]);
  }
  updateDrawMeshTooltipInfo(e4) {
    const { graphic: t2, sketchOptions: i2, view: s2 } = this;
    e4.sketchOptions = i2, e4.viewType = s2.type, e4.helpMessage = i$3(t2, this.view), this.updateElevation(e4.elevation);
  }
  makeDrawOperation() {
    const { geometryType: e4 } = this, t2 = "circle" !== e4 && "rectangle" !== e4;
    return new L$4({ view: this.view, manipulators: this.manipulators, geometryType: W$2(e4), drawingMode: this.mode, hasZ: this.hasZ, defaultZ: this.defaultZ, snapToSceneEnabled: this.snapToScene, drawSurface: new l$6(this.view, this.elevationInfo, [this.internalGraphicsLayer]), elevationDrawSurface: new c$a(this.elevationInfo, this.defaultZ, this.view, this.internalGraphicsLayer), hasM: false, elevationInfo: this.elevationInfo, snappingManager: this.snappingManager, snappingVisualizer: new O$2(), segmentLabels: t2 ? new a$7() : null, labelOptions: this.sketchOptions.labels, isDraped: this._createGraphicState ? this._createGraphicState.isDraped : "on-the-ground" === r$6(this.hasZ, this.elevationInfo), cursor: this.cursor, constraintsEnabled: true });
  }
  onActiveVertexChanged(e4) {
    const { view: a4 } = this;
    if (this._activeVertexVisualElement)
      return this._activeVertexVisualElement.vertices = [e4], this._activeVertexVisualElement.recreate(), this._updateVerticalLineVisualElement(e4), e$5();
    const n2 = this._settings, l2 = n2.manipulators.vertex, p4 = new d$4({ view: a4, spatialReference: a4.spatialReference, vertices: [e4], elevationInfo: this.internalGraphicsLayer.elevationInfo, size: l2.size, outlineSize: l2.outlineSize, renderOccluded: l2.renderOccluded, attached: false, isDecoration: true });
    this._activeVertexVisualElement = p4;
    const h3 = n2.visualElements.zVerticalLine, m3 = new C$5({ view: a4, extensionType: h3.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: h$7.OccludeAndTransparent, isDecoration: true });
    this._verticalLineVisualElement = m3;
    const u2 = r$5([d$3(() => n2.visualElements.zVerticalLine, (e5) => e5.apply(m3), P$3), d$3(() => ({ selectedColor: E$2(n2.colors.selected), outlineColor: E$2(n2.manipulators.vertex.outlineColor) }), ({ selectedColor: e5, outlineColor: t2 }) => {
      p4.color = e5, p4.outlineColor = t2;
    }, P$3), e$5(() => {
      this._activeVertexVisualElement = u$8(this._activeVertexVisualElement), this._verticalLineVisualElement = u$8(this._verticalLineVisualElement);
    })]);
    return p4.attached = true, this._updateVerticalLineVisualElement(e4), u2;
  }
  _updateVerticalLineVisualElement(e4) {
    const t2 = this._verticalLineVisualElement;
    if (!t2)
      return;
    const { renderCoordsHelper: i2, elevationProvider: s2 } = this.view;
    o$4(M$4, e4[0], e4[1], e4[2]), A$4.setFromElevationInfo(this.elevationInfo), M$4[2] = f$4(M$4, s2, A$4, i2);
    i2.toRenderCoords(M$4, this.view.spatialReference, M$4) ? (t2.setStartEndFromWorldDownAtLocation(M$4), t2.attached = true) : t2.attached = false;
  }
  onOutlineChanged(e4) {
    if (this._outlineVisualElement)
      return this._outlineVisualElement.geometry = e4, e$5();
    const t2 = this.internalGraphicsLayer.elevationInfo, { view: a4 } = this, n2 = this._settings, l2 = new w$1({ view: a4, geometry: e4, elevationInfo: t2, isDraped: this._createGraphicState ? this._createGraphicState.isDraped : "on-the-ground" === r$6(this.hasZ, t2), attached: false, isDecoration: true });
    this._outlineVisualElement = l2;
    const p4 = r$5([d$3(() => n2.visualElements.lineGraphics.outline, (e5) => e5.apply(l2), P$3), d$3(() => n2.visualElements.lineGraphics.shadowStyle, (e5) => e5.apply(l2), P$3), e$5(() => {
      this._outlineVisualElement = u$8(this._outlineVisualElement);
    })]);
    return l2.attached = true, l2.laserlineEnabled = true, p4;
  }
  onRegularVerticesChanged(e4) {
    if (this._verticesVisualElement)
      return this._verticesVisualElement.vertices = e4, e$5();
    const { view: a4 } = this, n2 = this._settings, l2 = n2.manipulators.vertex, p4 = new d$4({ view: a4, spatialReference: a4.spatialReference, vertices: e4, elevationInfo: this.internalGraphicsLayer.elevationInfo, size: l2.size, outlineSize: l2.outlineSize, renderOccluded: l2.renderOccluded, attached: false, isDecoration: true }), h3 = r$5([d$3(() => ({ color: E$2(n2.manipulators.vertex.color), outlineColor: E$2(n2.manipulators.vertex.outlineColor) }), ({ color: e5, outlineColor: t2 }) => {
      p4.color = e5, p4.outlineColor = t2;
    }, P$3), e$5(() => {
      this._verticesVisualElement = u$8(this._verticesVisualElement);
    })]);
    return p4.attached = true, this._verticesVisualElement = p4, h3;
  }
  updateGraphicGeometry(e4) {
    if ("mesh" !== this.geometryType || "point" !== e4?.type)
      super.updateGraphicGeometry(e4);
    else {
      const t2 = this.geometryToPlace;
      t2?.centerAt(e4);
      const i2 = this._graphic;
      t2 && i2.geometry === t2 || (i2.geometry = t2);
    }
  }
  _setupLoadingIndicator(e4) {
    const { drawOperation: t2 } = this;
    if (!this.geometryToPlace)
      return t2.loading = false, null;
    t2.loading = true;
    const r3 = e$5(() => {
      t2.loading = false;
    });
    let o2;
    const l2 = () => o2 && cancelAnimationFrame(o2);
    return r$5([p$7(() => e4.displaying, () => {
      l2(), o2 = requestAnimationFrame(() => r3.remove());
    }, { ...A$7, once: true }), e$5(l2), r3]);
  }
};
e$4([y$3({ constructOnly: true })], z2.prototype, "elevationInfo", void 0), e$4([y$3({ constructOnly: true })], z2.prototype, "geometryType", void 0), e$4([y$3()], z2.prototype, "type", void 0), e$4([y$3({ constructOnly: true })], z2.prototype, "view", void 0), z2 = e$4([c$6("esri.views.3d.interactive.editingTools.draw.DrawGraphicTool3D")], z2);
const A$4 = new o$5(), M$4 = n$5();
function n$3(o2) {
  const n2 = r$3(o2);
  return r$7(Math.cos(n2), Math.sin(n2));
}
function r$3(t2) {
  if (null == t2 || "polyline" !== t2.type && "polygon" !== t2.type)
    return 0;
  const n2 = "polyline" === t2.type ? t2.paths : t2.rings, r3 = e$9();
  for (const o2 of n2)
    for (let t3 = 0; t3 < o2.length - 1; t3++) {
      const n3 = o2[t3], e4 = o2[t3 + 1], i2 = n3[0] - e4[0], l2 = n3[1] - e4[1];
      if (i2 * i2 + l2 * l2 > r3)
        return Math.atan2(e4[1] - n3[1], e4[0] - n3[0]);
    }
  return 0;
}
var N$1;
!function(N2) {
  N2[N2.NONE = 0] = "NONE", N2[N2.ANY = 1] = "ANY", N2[N2.Z = 2] = "Z", N2[N2.XY = 4] = "XY";
}(N$1 || (N$1 = {}));
var A$3;
!function(A4) {
  A4[A4.TRANSLATE_Z = 0] = "TRANSLATE_Z", A4[A4.TRANSLATE_XY = 1] = "TRANSLATE_XY", A4[A4.SCALE = 2] = "SCALE", A4[A4.ROTATE = 3] = "ROTATE", A4[A4.SCALE_ROTATE = 4] = "SCALE_ROTATE";
}(A$3 || (A$3 = {}));
let a$4 = class a2 {
  constructor() {
    this.grabbingState = N$1.NONE, this.zManipulator = null, this.firstSelected = null, this.numSelected = 0, this.firstGrabbedXY = null;
  }
  update(a4) {
    this.grabbingState = N$1.NONE, this.zManipulator = null, this.numSelected = 0, this.firstSelected = null, this.firstGrabbedXY = null, a4.forEachManipulator((a5, s2) => {
      if (s2 === A$3.TRANSLATE_Z && (this.zManipulator = a5), a5 instanceof ee && (a5.selected && (0 === this.numSelected && (this.firstSelected = a5), this.numSelected++), null == this.firstGrabbedXY && a5.grabbing && s2 === A$3.TRANSLATE_XY && (this.firstGrabbedXY = a5)), a5.grabbing)
        switch (this.grabbingState |= N$1.ANY, s2) {
          case A$3.TRANSLATE_Z:
            this.grabbingState |= N$1.Z;
            break;
          case A$3.TRANSLATE_XY:
            this.grabbingState |= N$1.XY;
        }
    });
  }
};
function j$3(t2) {
  const { view: a4, graphic: n2 } = t2, i2 = new e$3({ graphic: n2 }), l2 = M$3(t2, i2), o2 = [l2, T$1(t2, l2.visualElement, i2), a4.maskOccludee(n2), a4.trackGraphicState(i2)];
  return { visualElement: l2.visualElement, remove: () => o$6(o2) };
}
function M$3(e4, n2) {
  const { view: i2, graphic: r3 } = e4, s2 = new w$1({ view: i2, geometry: L$2(r3) ? r3.geometry : null, elevationInfo: a$b(r3), attached: false, isDecoration: true }), p4 = new z$1({ getTheme: () => i2.effectiveTheme }), c2 = () => {
    s2.attached = n2.displaying;
  }, h3 = r$5([d$3(() => p4.visualElements.lineGraphics.outline, (e5) => e5.apply(s2), P$3), d$3(() => p4.visualElements.lineGraphics.shadowStyle, (e5) => e5.apply(s2), P$3), d$3(() => n2.displaying, c2), d$3(() => n2.isDraped, (e5) => {
    s2.isDraped = e5;
  }), n2.on("changed", () => s2.geometry = L$2(r3) ? r3.geometry : null), i$6(s2)]);
  return c2(), { visualElement: s2, remove: () => h3.remove() };
}
function T$1(s2, p4, c2) {
  const { graphic: h3, view: u2 } = s2, f3 = [], w4 = a$b(h3), S3 = "on-the-ground" === w4.mode || !w4.offset && "absolute-height" !== w4.mode, j2 = new a$4(), M2 = new z$1({ getTheme: () => u2.effectiveTheme }), T2 = M2.visualElements, A4 = new C$5({ view: u2, extensionType: T2.zVerticalLine.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: h$7.OccludeAndTransparent, isDecoration: true }), x3 = h$5(T2.heightPlaneAngleCutoff), C4 = new c$8({ view: u2, attached: false, angleCutoff: x3, isDecoration: true }), O3 = r$8(1);
  f3.push(d$3(() => ({ lineShadowStyle: M2.visualElements.lineGraphics.shadowStyle, pointShadowStyle: M2.visualElements.pointGraphics.shadowStyle, alpha: O3.value }), ({ lineShadowStyle: e4, pointShadowStyle: t2, alpha: a4 }) => {
    e4.apply(p4, a4), t2.apply(A4, a4);
  }, P$3));
  const V2 = r$8(1);
  f3.push(d$3(() => ({ heightPlane: M2.visualElements.heightPlane, alpha: V2.value }), ({ heightPlane: e4, alpha: t2 }) => e4.apply(C4, t2), P$3));
  const P2 = () => {
    if (j2.update(s2), !c2.displaying || S3 && (c2.isDraped || !L$2(h3) || !h3.geometry.hasZ))
      return p4.laserlineEnabled = false, A4.attached = false, void (C4.attached = false);
    p4.laserlineEnabled = true;
    const e4 = j2.grabbingState & N$1.XY ? T2.laserlineAlphaMultiplier : 1;
    O3.value = e4;
    const t2 = j2.grabbingState & N$1.Z ? T2.laserlineAlphaMultiplier : 1;
    V2.value = t2, D$2(A4, j2), G$1(s2, p4, C4, j2);
  };
  f3.push(d$3(() => M2.visualElements.zVerticalLine, (e4) => e4.apply(A4), P$3)), f3.push(c2.on("changed", P2), d$3(() => c2.displaying, P2), p4.events.on("attachment-origin-changed", P2), i$6(A4), i$6(C4));
  const U2 = [], X2 = () => {
    o$6(U2), U2.length = 0, s2.forEachManipulator((e4) => U2.push(e4.events.on("grab-changed", P2))), s2.forEachManipulator((e4) => U2.push(e4.events.on("select-changed", P2))), P2();
  };
  return X2(), f3.push(s2.onManipulatorsChanged(X2), t$5(() => r$5(U2))), r$5(f3);
}
function D$2(e4, t2) {
  const a4 = 1 === t2.numSelected ? t2.firstSelected : t2.numSelected > 1 && null != t2.firstGrabbedXY ? t2.firstGrabbedXY : null;
  null != a4 ? (e4.setStartEndFromWorldDownAtLocation(a4.renderLocation), e4.attached = true) : e4.attached = false;
}
function G$1(e4, t2, a4, n2) {
  if (n2.numSelected > 0) {
    o$4(A$2, 0, 0, 0);
    let t3 = 0;
    e4.forEachManipulator((e5, a5) => {
      a5 === A$3.TRANSLATE_XY && e5.selected && e5 instanceof ee && (u$6(A$2, A$2, e5.renderLocation), t3++);
    }), t3 > 0 ? (a4.heightManifoldTarget = g$5(A$2, A$2, 1 / t3), a4.attached = true) : a4.attached = false;
  } else {
    const n3 = t2.attachmentOrigin;
    null != n3 && e4.view.renderCoordsHelper.toRenderCoords(n3, A$2) ? (a4.heightManifoldTarget = A$2, a4.attached = true) : a4.attached = false;
  }
}
function L$2(e4) {
  return null != e4.geometry && ("polygon" === e4.geometry.type || "polyline" === e4.geometry.type);
}
const A$2 = n$5();
function D$1(t2) {
  const { view: n2, graphic: o2 } = t2, i2 = new e$3({ graphic: o2 }), a4 = [], r3 = V$1(t2, i2, a4);
  return P$1(t2, i2, a4, r3), a4.push(n2.trackGraphicState(i2)), { visualElement: r3, remove: () => o$6(a4) };
}
function P$1(e4, n2, l2, p4) {
  const { view: m3, graphic: f3 } = e4, E2 = new z$1({ getTheme: () => m3.effectiveTheme }), T2 = new C$5({ view: m3, extensionType: E2.visualElements.zVerticalLine.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: h$7.OccludeAndTransparent, isDecoration: true });
  l2.push(d$3(() => E2.visualElements.zVerticalLine, (e5) => e5.apply(T2), P$3));
  const D2 = new c$8({ view: m3, intersectsLineInfinite: true, attached: false, isDecoration: true }), P2 = h$5(E2.visualElements.heightPlaneAngleCutoff), V2 = new c$8({ view: m3, attached: false, angleCutoff: P2, isDecoration: true }), L2 = a$b(e4.graphic), M2 = o$5.fromElevationInfo(L2), C4 = "on-the-ground" === L2.mode || !L2.offset && "absolute-height" !== L2.mode, G2 = new a$4(), B2 = r$8(1);
  l2.push(d$3(() => ({ heightPlane: E2.visualElements.heightPlane, alpha: B2.value }), ({ heightPlane: e5, alpha: t2 }) => e5.apply(V2, t2), P$3));
  const I2 = r$8(1);
  l2.push(d$3(() => ({ shadowStyle: E2.visualElements.pointGraphics.shadowStyle, alpha: I2.value }), ({ shadowStyle: e5, alpha: t2 }) => e5.apply(D2, t2), P$3));
  const H2 = () => {
    G2.update(e4);
    const t2 = A$1(f3), o2 = C4 && (n2.isDraped || null == t2 || !t2.hasZ);
    let i2 = true;
    if (o2 || null == t2)
      i2 = false;
    else {
      const e5 = f$4(t2, m3.elevationProvider, M2, m3.renderCoordsHelper);
      o$4(R$2, t2.x, t2.y, e5), n$7(R$2, t2.spatialReference, R$2, m3.renderCoordsHelper.spatialReference), T2.setStartEndFromWorldDownAtLocation(R$2), D2.intersectsWorldUpAtLocation = R$2;
    }
    const a4 = G2.grabbingState & N$1.Z ? E2.visualElements.laserlineAlphaMultiplier : 1;
    B2.value = a4;
    const r3 = P$4(U$1);
    !o2 && n2.displaying && p4.calculateMapBounds(r3) && n$7(R$5(r3, R$2), m3.spatialReference, R$2, m3.renderCoordsHelper.spatialReference) ? (V2.heightManifoldTarget = R$2, V2.attached = true) : V2.attached = false;
    const l3 = G2.grabbingState & N$1.XY ? E2.visualElements.laserlineAlphaMultiplier : 1;
    I2.value = l3;
    const d2 = i2 && n2.displaying && !o2;
    D2.attached = d2, T2.attached = d2;
  };
  l2.push(d$3(() => [n2.displaying, n2.isDraped], H2), n2.on("changed", H2)), e4.forEachManipulator((e5) => {
    l2.push(e5.events.on("grab-changed", H2));
  }), l2.push(i$6(D2)), l2.push(i$6(T2)), l2.push(i$6(V2)), H2();
}
function V$1(e4, n2, o2) {
  const { view: i2, graphic: a4 } = e4, r3 = new x$4({ view: i2, geometry: A$1(a4), elevationInfo: a$b(a4), isDecoration: true });
  return L$1(e4, r3, n2, o2), o2.push(i$6(r3)), r3;
}
function A$1(e4) {
  const t2 = e4.geometry;
  return null == t2 ? null : "point" === t2.type ? t2 : "mesh" === t2.type ? t2.anchor.clone() : null;
}
function L$1(e4, t2, n2, o2) {
  const r3 = () => {
    t2.attached = n2.displaying;
  }, s2 = new z$1({ getTheme: () => e4.view.effectiveTheme });
  M$2(e4, t2, n2, o2), s2.visualElements.pointGraphics.outline.apply(t2), o2.push(d$3(() => n2.displaying, r3, P$3));
}
function M$2(e4, t2, o2, i2) {
  const { view: a4, graphic: r3 } = e4;
  let s2 = null;
  const l2 = (e5) => {
    null != s2 && (s2.remove(), s2 = null), o2.isDraped && null != e5 && (s2 = C$3(a4, e5, () => {
      t2.geometry = e5;
    }));
  }, p4 = () => {
    const e5 = A$1(r3);
    l2(e5), t2.geometry = e5;
  };
  i2.push(o2.on("changed", p4), t$5(() => s2)), p4();
}
function C$3(e4, t2, n2) {
  const o2 = e4.elevationProvider.spatialReference;
  c$b(t2, R$2, o2);
  const i2 = R$2[0], a4 = R$2[1];
  return e4.elevationProvider.on("elevation-change", (e5) => {
    w$4(e5.extent, i2, a4) && n2();
  });
}
const R$2 = n$5(), U$1 = i$7();
function i$2(i2) {
  switch (i2.graphic.geometry.type) {
    case "point":
    case "mesh":
      return D$1(i2);
    case "polygon":
    case "polyline":
      return j$3(i2);
    default:
      return null;
  }
}
const t$1 = 128, a$3 = 70, e$2 = 80, h$3 = 0.02, M$1 = 54, c$2 = 100, o$1 = Math.ceil(a$3 / 3 * 2), I = 160, P = 0.5, i$1 = 24, l$1 = 9, n$2 = I + 30, p$3 = I + 53, r$2 = 60, s$1 = 23, x$2 = 5 * Math.PI / 12, b2 = 1 * Math.PI / 3, d = 10, f2 = 0.2, g$2 = 30, j$2 = 53, k$1 = 0.2, m$2 = 0.3, q$1 = 200, u$1 = 3, v = 1e6;
class t {
  constructor() {
    this._available = true;
  }
  set location(a4) {
    this._forEachManipulator3D((t2) => t2.location = a4);
  }
  set elevationAlignedLocation(a4) {
    this._forEachManipulator3D((t2) => t2.elevationAlignedLocation = a4);
  }
  set elevationInfo(a4) {
    this._forEachManipulator3D((t2) => t2.elevationInfo = a4);
  }
  get renderLocation() {
    let a4;
    return this._forEachManipulator3D((t2) => {
      a4 || (a4 = t2.renderLocation);
    }), a4;
  }
  get available() {
    return this._available;
  }
  set available(a4) {
    this._available = a4, this._forEachManipulator3D((t2) => t2.available = a4);
  }
  get hovering() {
    return this.someManipulator((a4) => a4.hovering);
  }
  get grabbing() {
    return this.someManipulator((a4) => a4.grabbing);
  }
  get dragging() {
    return this.someManipulator((a4) => a4.dragging);
  }
  hasManipulator(a4) {
    return this.someManipulator((t2) => t2 === a4);
  }
  someManipulator(a4) {
    let t2 = false;
    return this.forEachManipulator((i2) => {
      !t2 && a4(i2) && (t2 = true);
    }), t2;
  }
  _forEachManipulator3D(t2) {
    this.forEachManipulator((i2, o2) => {
      i2 instanceof ee && t2(i2, o2);
    });
  }
}
function n$1(n2, a4, r3) {
  const c2 = (t2, e4) => a4({ action: t2, graphic: n2, dxScreen: e4.screenDeltaX, dyScreen: e4.screenDeltaY });
  return r3((a5, r4, s2) => (r4.next((t2) => ("start" === t2.action && c2("start", t2), t2)).next(S$3(n2)).next((t2) => {
    switch (t2.action) {
      case "start":
      case "update":
        (t2.translationX || t2.translationY || t2.translationZ) && c2("update", t2);
        break;
      case "end":
        c2("end", t2);
    }
    return t2;
  }), { steps: r4, cancel: s2 = s2.next(w$5(n2)).next((t2) => (c2("end", { screenDeltaX: 0, screenDeltaY: 0 }), t2)) }));
}
function a$2(t2) {
  if (null == t2?.axis)
    return 1;
  const { mapStart: e4, mapEnd: n2, axis: a4 } = t2, r3 = [n2.x - e4.x, n2.y - e4.y];
  return r3[0] * a4[0] + r3[1] * a4[1] > 0 ? 1 : -1;
}
let C$2 = class C2 extends t {
  constructor(t2) {
    super(), this._handles = new e$a(), this._arrowManipulatorInfos = new Array(), this._angle = 0, this._scale = 1, this._radius = a$3, this._updateAfterDrag = false, this.events = new o$3(), this._tool = t2.tool, this._view = t2.view, this._opaqueMaterial = this._createMaterial(), this._transparentMaterial = this._createMaterial(0.5), null != t2.radius && (this._radius = t2.radius), this._createManipulators(), this.forEachManipulator((t3) => this._tool.manipulators.add(t3));
  }
  set orthogonalAvailable(t2) {
    this._arrowManipulatorInfos.length >= 3 && (this._arrowManipulatorInfos[1].manipulator.available = t2, this._arrowManipulatorInfos[3].manipulator.available = t2);
  }
  destroy() {
    this._handles = u$8(this._handles), this.forEachManipulator((t2) => {
      this._tool.manipulators.remove(t2), t2.destroy();
    }), this._tool = null, this._view = null, this._arrowManipulatorInfos.length = 0;
  }
  forEachManipulator(t2) {
    for (const { manipulator: r3 } of this._arrowManipulatorInfos)
      t2(r3, A$3.TRANSLATE_XY);
  }
  createGraphicDragPipeline(t2, r3, a4) {
    const e4 = r3.graphic, i2 = a$b(e4), o2 = e4.geometry.spatialReference;
    return n$1(e4, a4, (r4) => this.createDragPipeline((a5, e5, i3, o3, s2) => ({ steps: e5, cancel: i3 } = t2(a5, e5, i3, o3, s2), r4(a5, e5, i3)), i2, o2, e4));
  }
  createDragPipeline(t2, r3, a4, i2) {
    return r$5(this._arrowManipulatorInfos.map(({ manipulator: e4 }, o2) => x$5(e4, (e5, s2, n2, l2, p4) => {
      const u2 = s2.next((t3) => ({ ...t3, manipulatorType: A$3.TRANSLATE_XY })).next(C$7(this._view, e5.elevationAlignedLocation)).next(D$4(this._view, e5.elevationAlignedLocation, r3, a4, i2)).next(h$a(e5.location, this.angle + (o2 + 1) * Math.PI * 0.5)).next(P$5());
      t2(e5, u2, n2, l2, p4);
    })));
  }
  get angle() {
    return this._angle;
  }
  set angle(t2) {
    this._angle = t2, this.dragging ? this._updateAfterDrag = true : this._updateManipulatorTransform();
  }
  get displayScale() {
    return this._scale;
  }
  set displayScale(t2) {
    this._scale = t2, this._updateManipulatorTransform();
  }
  get radius() {
    return this._radius;
  }
  set radius(t2) {
    this._radius !== t2 && (this._radius = t2, this._updateManipulators());
  }
  _updateManipulators() {
    for (let t2 = 0; t2 < this._arrowManipulatorInfos.length; t2++)
      this._updateArrowManipulator(this._arrowManipulatorInfos[t2], t2);
    this._updateManipulatorTransform();
  }
  _updateArrowManipulator({ manipulator: t2, transform: r3 }, a4) {
    const e4 = this._radius / a$3, i2 = M$1 * e4, o2 = i2 * Math.sqrt(3) / 2, s2 = wt$1(this._opaqueMaterial, o2, i2 / 2, i2 / 2, h$3);
    mt(s2, q$5(f$5.get(), o$4(c$7.get(), 0, -o2 / 3, 0))), t2.renderObjects = [new e$b(s2, t$6.Focused), new e$b(s2.instantiate({ material: this._transparentMaterial }), t$6.Unfocused)], t2.radius = o2 / 3 * 2 * 1.2;
    const u2 = R$6(f$5.get(), a4 * Math.PI / 2), h3 = q$5(f$5.get(), o$4(c$7.get(), 0, c$2 * e4, 0));
    c$c(r3, u2, h3);
  }
  _createManipulators() {
    for (let t2 = 0; t2 < 4; t2++) {
      const r3 = this._createArrowManipulator(t2);
      this._arrowManipulatorInfos.push(r3);
    }
    this._updateManipulatorTransform();
  }
  _updateManipulatorTransform() {
    const t2 = this.angle, r3 = p$8(f$5.get(), t2, r$9(0, 0, 1));
    if (null == r3)
      return;
    const a4 = d$5(f$5.get(), o$4(c$7.get(), this.displayScale, this.displayScale, this.displayScale)), e4 = c$c(f$5.get(), a4, r3);
    for (const i2 of this._arrowManipulatorInfos) {
      const t3 = c$c(f$5.get(), e4, i2.transform);
      i2.manipulator.modelTransform = t3;
    }
  }
  _createArrowManipulator(t2) {
    const r3 = new ee({ view: this._view, autoScaleRenderObjects: false, worldOriented: true, focusMultiplier: 1, touchMultiplier: 1, collisionType: { type: "disc", direction: r$9(0, 0, 1) } }), a4 = { manipulator: r3, transform: e$d() };
    return this._updateArrowManipulator(a4, t2), this._handles.add(r3.events.on("drag", (t3) => {
      this._updateAfterDrag && "end" === t3.action && !this.dragging && (this._updateManipulatorTransform(), this._updateAfterDrag = false);
    })), a4;
  }
  _createMaterial(r3 = 1) {
    const a4 = new _$2({ cullFace: e$c.Back, renderOccluded: h$7.Transparent, isDecoration: true });
    return this._handles.add(d$3(() => u$3.toUnitRGBA(this._view.effectiveTheme.accentColor), (t2) => {
      t2[3] *= r3, a4.setParameters({ color: t2 });
    }, P$3)), a4;
  }
  get test() {
    return { arrowManipulators: this._arrowManipulatorInfos.map(({ manipulator: t2 }) => t2) };
  }
};
let e$1 = class e2 {
  constructor() {
    this._view = null, this._elevationInfo = null, this._lastDragEvent = null, this._next = null, this._enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t2) {
    if (this._enabled !== t2 && null != this._lastDragEvent && null != this._next) {
      const n2 = this._lastDragEvent.mapEnd, e4 = this._snap(this._lastDragEvent.screenEnd);
      if (null != e4) {
        const s2 = { action: "update", mapStart: this._lastDragEvent.mapStart, mapEnd: true === t2 ? e4 : n2, screenStart: this._lastDragEvent.screenEnd, screenEnd: this._lastDragEvent.screenEnd };
        this._next.execute(s2);
      }
    }
    this._enabled = t2;
  }
  _snap(n2) {
    const e4 = null != this._view ? this._view.toMap(n2, { exclude: [] }) : null;
    return null != e4 && null != this._view && (e4.z = v$3(e4, this._view, this._elevationInfo)), e4;
  }
  createDragEventPipelineStep(t2, e4) {
    this._view = t2, this._elevationInfo = e4, this._lastDragEvent = null;
    const s2 = new Y$1();
    this._next = s2;
    return [(t3) => {
      if (this._lastDragEvent = "end" !== t3.action ? { ...t3 } : null, this._enabled) {
        const n2 = this._snap(t3.screenEnd);
        return null != n2 ? { action: t3.action, mapStart: t3.mapStart, mapEnd: n2, screenStart: t3.screenStart, screenEnd: t3.screenEnd } : null;
      }
      return { action: t3.action, mapStart: t3.mapStart, mapEnd: t3.mapEnd, screenStart: t3.screenStart, screenEnd: t3.screenEnd };
    }, s2];
  }
};
let R$1 = class R extends t {
  constructor(t2) {
    super(), this._handles = new e$a(), this._snapToScene = new e$1(), this._scale = 1, this._radius = a$3, this._view = t2.view, this._tool = t2.tool, this._discMaterial = this._createMaterial(), this._discMaterialTransparent = this._createMaterial(0.5), null != t2.snapToScene && (this.snapToScene = t2.snapToScene), null != t2.radius && (this._radius = t2.radius), this._createManipulator(), this.forEachManipulator((t3) => this._tool.manipulators.add(t3));
  }
  destroy() {
    this._handles = u$8(this._handles), this.forEachManipulator((t2) => {
      this._tool.manipulators.remove(t2), t2.destroy();
    }), this._tool = null, this._view = null, this._manipulator = null;
  }
  forEachManipulator(t2) {
    t2(this._manipulator, A$3.TRANSLATE_XY);
  }
  get displayScale() {
    return this._scale;
  }
  set displayScale(t2) {
    this._scale = t2, this._updateManipulatorTransform();
  }
  get snapToScene() {
    return this._snapToScene.enabled;
  }
  set snapToScene(t2) {
    this._snapToScene.enabled = t2;
  }
  get radius() {
    return this._radius;
  }
  set radius(t2) {
    t2 !== this._radius && (this._radius = t2, this._updateManipulator());
  }
  createGraphicDragPipeline(t2, e4, i2) {
    const r3 = e4.graphic, a4 = a$b(r3), s2 = r3.geometry.spatialReference;
    return n$1(r3, i2, (e5) => this.createDragPipeline((i3, r4, a5, s3, o2) => ({ steps: r4, cancel: a5 } = t2(i3, r4, a5, s3, o2), e5(i3, r4, a5)), a4, s2, r3));
  }
  createDragPipeline(t2, e4, i2, r3) {
    const a4 = this._view;
    return x$5(this._manipulator, (s2, o2, n2, l2, p4) => {
      const c2 = o2.next(C$7(a4, s2.elevationAlignedLocation)).next(D$4(a4, s2.elevationAlignedLocation, e4, i2, r3)).next(...this._snapToScene.createDragEventPipelineStep(a4, e4)).next((t3) => ({ ...t3, manipulatorType: A$3.TRANSLATE_XY })).next(P$5());
      t2(s2, c2, n2, l2, p4);
    });
  }
  _updateManipulatorTransform() {
    const t2 = d$5(f$5.get(), o$4(c$7.get(), this.displayScale, this.displayScale, this.displayScale));
    this._manipulator.modelTransform = t2;
  }
  _createManipulator() {
    const t2 = this._view;
    this._manipulator = new ee({ view: t2, worldSized: false, autoScaleRenderObjects: false, focusMultiplier: 1, touchMultiplier: 1, collisionType: { type: "disc", direction: r$9(0, 0, 1) }, worldOriented: true }), this._updateManipulator();
  }
  _updateManipulator() {
    const t2 = ft(this._discMaterial, h$3, 1, t$1, r$9(0, 0, 1), r$9(0, 0, 0));
    t2.transformation = d$5(e$d(), r$9(this._radius, this._radius, this._radius)), this._manipulator.renderObjects = [new e$b(t2, t$6.Focused), new e$b(t2.instantiate({ material: this._discMaterialTransparent }), t$6.Unfocused)], this._manipulator.radius = e$2 * (this._radius / a$3);
  }
  _createMaterial(e4 = 1) {
    const i2 = new _$2({ cullFace: e$c.Back, renderOccluded: h$7.Transparent, isDecoration: true });
    return this._handles.add(d$3(() => u$3.toUnitRGBA(this._view.effectiveTheme.accentColor), (t2) => {
      t2[3] *= e4, i2.setParameters({ color: t2 });
    }, P$3)), i2;
  }
  get test() {
    return { discManipulator: this._manipulator };
  }
};
let x$1 = class x extends t {
  constructor(e4) {
    super(), this._radius = a$3, this.events = new o$3(), this._tool = e4.tool, this._view = e4.view;
    const t2 = new z$1({ getTheme: () => this._view.effectiveTheme });
    this._settings = t2, null != e4.radius && (this._radius = e4.radius);
    const i2 = this._view.effectiveTheme.accentColor;
    this._materials = { materialUnfocused: d$6(this._createDarkenedColor(i2, 1, 0.25), h$7.Occlude), materialFocused: d$6(this._createDarkenedColor(i2, 1, 0), h$7.Occlude), materialOccludedUnfocused: d$6(this._createDarkenedColor(i2, 0.7, 0), t2.zManipulator.renderOccluded), materialOccludedFocused: d$6(this._createDarkenedColor(i2, 0.85, 0), t2.zManipulator.renderOccluded) }, this._themeHandle = d$3(() => this._view.effectiveTheme.accentColor, (e5) => {
      const t3 = this._createDarkenedColor(e5, 1, 0.25), r3 = this._createDarkenedColor(e5, 1, 0), i3 = this._createDarkenedColor(e5, 0.7, 0), a4 = this._createDarkenedColor(e5, 0.85, 0), { materialUnfocused: o2, materialFocused: s2, materialOccludedUnfocused: n2, materialOccludedFocused: l2 } = this._materials;
      o2.setParameters({ color: t3 }), s2.setParameters({ color: r3 }), n2.setParameters({ color: i3 }), l2.setParameters({ color: a4 });
    }), this._createManipulator(), this.forEachManipulator((e5) => this._tool.manipulators.add(e5));
  }
  destroy() {
    this._themeHandle = l$7(this._themeHandle), this._manipulator.applyObjectTransform = H, this.forEachManipulator((e4) => {
      this._tool.manipulators.remove(e4), e4.destroy();
    });
  }
  forEachManipulator(e4) {
    e4(this._manipulator, A$3.TRANSLATE_Z);
  }
  createGraphicDragPipeline(e4, t2, r3) {
    const i2 = t2.graphic.geometry.spatialReference;
    return n$1(t2.graphic, r3, (t3) => this.createDragPipeline((r4, i3, a4, o2, s2) => ({ steps: i3, cancel: a4 } = e4(r4, i3, a4, o2, s2), t3(r4, i3, a4)), i2));
  }
  createDragPipeline(e4, t2) {
    const r3 = this._view;
    return x$5(this._manipulator, (i2, a4, o2, s2, n2) => {
      const l2 = a4.next((e5) => ({ ...e5, manipulatorType: A$3.TRANSLATE_Z })).next(k$2(r3, i2.renderLocation, t2)).next(P$5());
      e4(i2, l2, o2, s2, n2);
    });
  }
  get radius() {
    return this._radius;
  }
  set radius(e4) {
    e4 !== this._radius && (this._radius = e4, this._updateManipulator());
  }
  _updateManipulator() {
    const e4 = this._settings, t2 = this._radius / a$3, r3 = e4.zManipulator.height * t2, i2 = e4.zManipulator.coneHeight * t2, a4 = e4.zManipulator.coneWidth * t2, o2 = e4.zManipulator.width * t2, m3 = [r$9(0, 0, 0), r$9(0, 0, r3)], d2 = [r$9(0, 0, 0), r$9(0, 0, r3 + i2)], u2 = (e5) => {
      const t3 = e$d();
      if (i$8(t3, t3, [0, 0, r3]), l$8(t3, t3, Math.PI / 2), e5) {
        const r4 = 1 + 2 * e5 / a4;
        f$6(t3, t3, [r4, r4, r4]);
      }
      return t3;
    }, p4 = u2(0), { materialUnfocused: h3, materialFocused: f3, materialOccludedUnfocused: _2, materialOccludedFocused: g3 } = this._materials, w4 = pt(h3, m3, o2 / 2, 16, false), M2 = at(h3, i2, a4 / 2, 16, false);
    M2.transformation = p4, this._manipulator.renderObjects = [new e$b(M2, t$6.Unfocused), new e$b(w4, t$6.Unfocused), new e$b(M2.instantiate({ material: f3 }), t$6.Focused), new e$b(w4.instantiate({ material: f3 }), t$6.Focused), new e$b(M2.instantiate({ material: _2 }), t$6.Unfocused), new e$b(w4.instantiate({ material: _2 }), t$6.Unfocused), new e$b(M2.instantiate({ material: g3 }), t$6.Focused), new e$b(w4.instantiate({ material: g3 }), t$6.Focused)], this._manipulator.radius = o2 / 2 + 2, this._manipulator.collisionType = { type: "line", paths: [d2] };
  }
  _createManipulator() {
    const e4 = this._view, t2 = new ee({ view: e4, autoScaleRenderObjects: false, worldSized: false, selectable: false, cursor: "ns-resize", elevationInfo: this.elevationInfo, worldOriented: true, collisionPriority: 1.6 });
    t2.applyObjectTransform = (t3) => {
      const r3 = e4.state.camera, a4 = A3;
      e4.renderCoordsHelper.toRenderCoords(this._manipulator.elevationAlignedLocation, a4);
      const o2 = U$3(r3.eye, a4), s2 = r3.computeRenderPixelSizeAtDist(o2), n2 = e$e(E$1, a4, r3.eye);
      z$3(n2, n2);
      const l2 = R2;
      e4.renderCoordsHelper.worldUpAtPosition(A3, l2);
      const c2 = Math.abs(P$6(n2, l2)), _2 = _$3(E$1, n2, l2), j2 = _$3(E$1, _2, l2), g3 = e$f(c2, 0.01, 1), w4 = 1 - Math.sqrt(1 - g3 * g3) / g3 / r3.fullWidth, v2 = this._settings, M2 = this._radius / a$3, U2 = v2.zManipulator.width * M2;
      g$5(j2, z$3(j2, j2), (1 / w4 - 1) * o2 + s2 * U2), t3[12] -= E$1[0], t3[13] -= E$1[1], t3[14] -= E$1[2];
    }, this._manipulator = t2, this._updateManipulator();
  }
  _createDarkenedColor(r3, i2, a4) {
    const o2 = L$5(r3, a4);
    return o2.a *= i2, u$3.toUnitRGBA(o2);
  }
  get test() {
    return { manipulator: this._manipulator };
  }
};
const A3 = n$5(), E$1 = n$5(), R2 = n$5(), H = () => {
};
class u extends t {
  constructor(a4) {
    super(), this._handles = new e$a(), this._interactive = true;
    const { tool: t2, view: n2, snapToScene: s2, radius: e4 } = a4;
    this._view = n2, this.xyManipulation = new R$1({ tool: t2, view: n2, snapToScene: s2, radius: e4 }), this.xyAxisManipulation = new C$2({ tool: t2, view: n2, radius: e4 }), this.zManipulation = new x$1({ tool: t2, view: n2, radius: e4 }), this.xyManipulation.available = a4.xyAvailable, this.xyAxisManipulation.available = a4.xyAxisAvailable, this.zManipulation.available = a4.zAvailable, this._autoHideXYAxis(), this.forEachManipulator((i2) => this._handles.add(i2.events.on("grab-changed", () => this._updateManipulatorInteractivity())));
  }
  destroy() {
    this._handles.destroy(), this.xyManipulation.destroy(), this.xyAxisManipulation.destroy(), this.zManipulation.destroy();
  }
  createGraphicDragPipeline(i2, t2, n2) {
    return r$5([this.xyManipulation.createGraphicDragPipeline((a4, t3, n3, s2, e4) => i2(c$1.XY, a4, t3, n3, s2, e4), t2, n2), this.xyAxisManipulation.createGraphicDragPipeline((a4, t3, n3, s2, e4) => i2(c$1.XY_AXIS, a4, t3, n3, s2, e4), t2, n2), this.zManipulation.createGraphicDragPipeline((a4, t3, n3, s2, e4) => i2(c$1.Z, a4, t3, n3, s2, e4), t2, n2)]);
  }
  createDragPipeline(i2, t2, n2, s2) {
    return r$5([this.xyManipulation.createDragPipeline((a4, t3, n3, s3, e4) => i2(c$1.XY, a4, t3, n3, s3, e4), t2, n2, s2), this.xyAxisManipulation.createDragPipeline((a4, t3, n3, s3, e4) => i2(c$1.XY_AXIS, a4, t3, n3, s3, e4), t2, n2, s2), this.zManipulation.createDragPipeline((a4, t3, n3, s3, e4) => i2(c$1.Z, a4, t3, n3, s3, e4), n2)]);
  }
  set snapToScene(i2) {
    this.xyManipulation.snapToScene = i2;
  }
  set angle(i2) {
    this.xyAxisManipulation.angle = i2;
  }
  set interactive(i2) {
    this._interactive !== i2 && (this._interactive = i2, this._updateManipulatorInteractivity());
  }
  set radius(i2) {
    this.xyAxisManipulation.radius = i2, this.xyManipulation.radius = i2, this.zManipulation.radius = i2;
  }
  set displayScale(i2) {
    this.xyManipulation.displayScale = i2, this.xyAxisManipulation.displayScale = i2;
  }
  forEachManipulator(i2) {
    this.xyManipulation.forEachManipulator((a4) => i2(a4, A$3.TRANSLATE_XY)), this.xyAxisManipulation.forEachManipulator((a4) => i2(a4, A$3.TRANSLATE_XY)), this.zManipulation.forEachManipulator((a4) => i2(a4, A$3.TRANSLATE_Z));
  }
  get _xyAxisVisible() {
    const i2 = this.xyManipulation.someManipulator((i3) => i3.focused) || this.xyAxisManipulation.someManipulator((i3) => i3.focused);
    return this._view.inputManager && "touch" === this._view.inputManager.latestPointerType || i2;
  }
  _autoHideXYAxis() {
    const i2 = this.xyAxisManipulation, a4 = this.xyManipulation;
    if (has("esri-mobile"))
      return;
    const n2 = [];
    a4.forEachManipulator((i3) => n2.push(i3)), i2.forEachManipulator((i3) => n2.push(i3));
    const s2 = () => {
      const a5 = [];
      this._xyAxisVisible || i2.forEachManipulator((i3) => a5.push(i3.disableDisplay())), this._handles.remove(h$2), this._handles.add(a5, h$2);
    };
    for (const t2 of n2)
      this._handles.add(t2.events.on("focus-changed", s2));
    this._view.inputManager && this._handles.add(p$7(() => this._view.inputManager?.latestPointerType, s2)), s2();
  }
  _updateManipulatorInteractivity() {
    const i2 = this.grabbing;
    this.forEachManipulator((a4) => {
      a4.interactive = !i2 && this._interactive || a4.grabbing;
    });
  }
  static radiusForSymbol(i2) {
    const a4 = null != i2 && "point-3d" === i2.type && i2.symbolLayers;
    return !!a4 && a4.some((i3) => "icon" === i3.type) ? o$1 : a$3;
  }
}
const h$2 = "disable-xy-axis-display";
var c$1;
!function(i2) {
  i2[i2.XY = 0] = "XY", i2[i2.XY_AXIS = 1] = "XY_AXIS", i2[i2.Z = 2] = "Z";
}(c$1 || (c$1 = {}));
class l extends t {
  constructor(t2) {
    super(), this._view = t2.view, this._tool = t2.tool, this._graphicState = t2.graphicState, this._createManipulator(), this.forEachManipulator((t3) => this._tool.manipulators.add(t3));
  }
  destroy() {
    this.forEachManipulator((t2) => {
      this._tool.manipulators.remove(t2), t2.destroy();
    }), this._tool = null, this._view = null, this._manipulator = null, this._graphicState = null;
  }
  forEachManipulator(t2) {
    t2(this._manipulator, A$3.TRANSLATE_XY);
  }
  createGraphicDragPipeline(t2) {
    return n$1(this._graphicState.graphic, t2, (t3) => this.createDragPipeline(t3));
  }
  createDragPipeline(i2) {
    const r3 = this._view, a4 = this._graphicState.graphic, n2 = null != a4.geometry ? a4.geometry.spatialReference : null;
    return x$5(this._manipulator, (e4, l2, p4, h3, c2) => {
      const u2 = l2.next(N$2(c2, r3, a4, n2)).next(D$5()).next(P$5());
      i2(e4, u2, p4, h3, c2);
    });
  }
  _createManipulator() {
    const t2 = this._view, i2 = this._graphicState.graphic;
    this._manipulator = new S$4({ graphic: i2, view: t2, selectable: true, cursor: "move" });
  }
}
class F {
  constructor(t2) {
    this.allGraphics = t2, this.type = "graphic-move-start";
  }
}
class V {
  constructor(t2, i2, e4) {
    this.dx = t2, this.dy = i2, this.allGraphics = e4, this.type = "graphic-move";
  }
}
class L {
  constructor(t2) {
    this.allGraphics = t2, this.type = "graphic-move-stop";
  }
}
const N = "manipulators";
let q = class extends o$3.EventedMixin(l$9) {
  constructor(t2) {
    super(t2), this._infos = /* @__PURE__ */ new Map(), this.graphics = new V$3(), this.enableZ = true, this.sketchOptions = new l$a(), this.type = "move-3d", this.tooltip = null, this._updatingHandles = new h$b(), this._moveManipulation = null, this._latestTooltipInfo = null, this._translateGraphicTooltipInfo = null, this._translateGraphicXYTooltipInfo = null, this._translateGraphicZTooltipInfo = null;
  }
  initialize() {
    const { view: t2 } = this;
    this.addHandles([this.graphics.on("change", (t3) => {
      t3.removed.forEach((t4) => this.removeHandles(t4)), this._updateGraphicInfos(t3), this._setupFastTransformUpdates(t3.added), this._refreshManipulators();
    }), d$3(() => this.sketchOptions.tooltips.effectiveEnabled, (i3) => {
      this.tooltip = i3 ? new u$9({ info: this._latestTooltipInfo, view: t2 }) : u$8(this.tooltip);
    }, A$7)]);
    const i2 = this.graphics.toArray();
    this._updateGraphicInfos({ added: i2, removed: [] }), this._setupFastTransformUpdates(i2), this._refreshManipulators(), this.finishToolCreation();
  }
  destroy() {
    this.tooltip = u$8(this.tooltip), this._moveManipulation = u$8(this._moveManipulation), this._set("view", null), this._updatingHandles.destroy();
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  reset() {
  }
  _updateGraphicInfos({ added: t2, removed: i2 }) {
    for (const e4 of t2) {
      if (o$7(e4) !== P$7.SUPPORTED)
        continue;
      const t3 = new B(e4), i3 = this.view.trackGraphicState(t3.state);
      this._infos.set(t3.graphic, { info: t3, handle: i3 });
    }
    for (const e4 of i2)
      this._infos.get(e4)?.handle.remove(), this._infos.delete(e4);
  }
  _setupFastTransformUpdates(t2) {
    const { view: i2 } = this;
    for (const e4 of t2) {
      const { info: t3 } = this._infos.get(e4);
      this.addHandles(a$6(t3.state, i2), e4);
    }
  }
  _refreshManipulators() {
    if (this.removeHandles(N), this._moveManipulation = u$8(this._moveManipulation), this.manipulators.removeAll(), 0 === this._infos.size)
      return;
    const t2 = Array.from(this._infos.values(), ({ info: t3 }) => t3);
    this._createManipulators(t2), this._createVisualElements(t2), this._updateMoveManipulation(t2);
  }
  _createManipulators(t2) {
    for (const i2 of t2) {
      const e4 = i2.state;
      i2.manipulationXY = new l({ tool: this, view: this.view, graphicState: e4 }), i2.manipulationXY.forEachManipulator((t3) => this.addHandles([t3.events.on("immediate-click", (t4) => {
        this.emit("immediate-click", { ...t4, graphic: e4.graphic }), t4.stopPropagation();
      }), t3.events.on("grab-changed", ({ action: t4 }) => {
        "start" === t4 ? this._showTooltip(c$1.XY) : this._hideTooltip();
      })], N)), this.addHandles(i2.manipulationXY.createDragPipeline((i3, e5, o2, a4) => this._buildDragEventPipeline(t2, c$1.XY, i3, e5, o2, a4)), N);
    }
    this._createMoveManipulation(t2);
  }
  _createMoveManipulation(t2) {
    const i2 = new u({ tool: this, view: this.view, snapToScene: false, xyAvailable: true, xyAxisAvailable: true, zAvailable: true, radius: 1 === t2.length ? u.radiusForSymbol(t2[0].graphic.symbol) : a$3 });
    this._moveManipulation = i2, i2.elevationInfo = { mode: "absolute-height", offset: 0 }, i2.forEachManipulator((t3) => {
      this.addHandles(t3.events.on("immediate-click", (e5) => {
        i2.zManipulation.hasManipulator(t3) || 1 !== this.graphics.length || this.emit("immediate-click", { ...e5, graphic: this.graphics.at(0) }), e5.stopPropagation();
      }), N);
    });
    const e4 = (t3) => (i3) => {
      this.addHandles([i3.events.on("focus-changed", ({ action: i4 }) => {
        "focus" === i4 ? this._showTooltip(t3) : this._hideTooltip();
      }), i3.events.on("grab-changed", () => {
        this._latestTooltipInfo && (this._latestTooltipInfo.distance = m$6);
      })], N);
    };
    this._moveManipulation.xyManipulation.forEachManipulator(e4(c$1.XY)), this._moveManipulation.xyAxisManipulation.forEachManipulator(e4(c$1.XY_AXIS)), this._moveManipulation.zManipulation.forEachManipulator(e4(c$1.Z));
    const o2 = () => this._updateMoveManipulation(t2);
    for (const n2 of t2)
      this.addHandles([n2.state.on("changed", o2), d$3(() => n2.state.displaying, o2)], N);
    const a4 = t2[t2.length - 1];
    this.addHandles(a4.state.on("changed", () => this._updateMoveManipulationAngle(a4)), N), this.addHandles(i2.createDragPipeline((i3, e5, o3, a5, n2) => this._buildDragEventPipeline(t2, i3, e5, o3, a5, n2), a$b(a4.graphic), a4.graphic.geometry.spatialReference, a4.graphic), N), this._updateMoveManipulationAngle(a4);
  }
  _createVisualElements(t2) {
    for (const i2 of t2) {
      const e4 = i2.graphic, a4 = i$2({ view: this.view, graphic: e4, forEachManipulator: (t3) => {
        i2.manipulationXY?.forEachManipulator(t3), this._moveManipulation?.forEachManipulator(t3);
      }, onManipulatorsChanged: () => e$5() });
      null != a4 && (i2.geometryRepresentation = a4.visualElement, i2.geometryRepresentation instanceof w$1 && this.addHandles([i2.geometryRepresentation.events.on("attachment-origin-changed", () => {
        i2.state.isDraped || this._updateMoveManipulation(t2);
      }), d$3(() => i2.state.isDraped, () => this._updateMoveManipulation(t2))], N), this.addHandles(a4, N));
    }
  }
  _updateMoveManipulationAngle(t2) {
    this._moveManipulation && (this._moveManipulation.angle = r$3(t2.graphic.geometry));
  }
  _updateMoveManipulation(t2) {
    const i2 = e$7(0, 0, 0, this.view.spatialReference);
    let e4 = 0, o2 = false;
    const a4 = this._moveManipulation;
    if (a4) {
      for (const a5 of t2) {
        if (!a5.state.displaying)
          continue;
        const t3 = a5.state.graphic;
        this.enableZ && n$8(t3) && (o2 = true);
        const n2 = a5.geometryRepresentation instanceof w$1 && !a5.state.isDraped ? a5.geometryRepresentation.attachmentOrigin : O$3(this.view, t3);
        if (null != n2) {
          const { x: t4, y: o3, z: a6 } = n2;
          i2.x += t4, i2.y += o3, a6 && (i2.z ??= 0, i2.z += a6), e4++;
        }
      }
      e4 > 0 ? (i2.x /= e4, i2.y /= e4, i2.z ??= 0, i2.z /= e4, a4.location = i2, a4.xyManipulation.available = true, a4.xyAxisManipulation.available = true, a4.zManipulation.available = o2) : a4.available = false;
    }
  }
  _buildDragEventPipeline(t2, i2, e4, o2, a4, n2) {
    const s2 = [], r3 = [];
    let p4 = null, l2 = null;
    const h3 = () => {
      for (const t3 of s2)
        t3.dragging = false;
      s2.length = 0, r3.length = 0, p4 = null, l2 = null, this._moveManipulation && (this._moveManipulation.interactive = true);
    };
    if (1 === t2.length && i2 === c$1.XY) {
      const i3 = t2[0].graphic;
      ({ steps: o2, cancel: a4 } = this._buildSnappingPipelineSteps(i3, a$b(i3), o2, a4, n2));
    }
    return a4 = a4.next((t3) => l2?.(t3)).next(() => (this.emit("graphic-move-stop", new L(r3)), this.destroyed || h3(), null)), { steps: o2 = o2.next((i3) => {
      if ("start" === i3.action) {
        s2.length = 0, r3.length = 0;
        for (const i4 of t2)
          i4.dragging || !i4.manipulationXY?.hasManipulator(e4) && i4.manipulationXY?.grabbing || (s2.push(i4), r3.push(i4.graphic), i4.dragging = true);
        if (0 !== r3.length && (this._moveManipulation && (this._moveManipulation.interactive = false), p4 = R$7(r3), l2 = q$6(r3), this.emit("graphic-move-start", new F(r3)), this.destroyed))
          return null;
      }
      return 0 !== r3.length ? i3 : null;
    }).next((t3) => p4?.(t3)).next((t3) => (this._updateMoveTooltip(i2, t3), t3)).next((t3) => {
      switch (t3.action) {
        case "start":
        case "update":
          if (t3.translationX || t3.translationY || t3.translationZ) {
            const i3 = this.view.toScreen(t3.mapStart), e5 = this.view.toScreen(t3.mapEnd), o3 = e5.x - i3.x, a5 = e5.y - i3.y;
            if (this.emit("graphic-move", new V(o3, a5, r3)), this.destroyed)
              return null;
          }
          break;
        case "end":
          if (this.emit("graphic-move-stop", new L(r3)), this.destroyed)
            return null;
          h3();
      }
      return null;
    }), cancel: a4 };
  }
  _showTooltip(t2) {
    this._updateMoveTooltip(t2), this._latestTooltipInfo && (this._latestTooltipInfo.distance = m$6);
  }
  _hideTooltip() {
    this.tooltip?.clear(), this._latestTooltipInfo = null;
  }
  _updateMoveTooltip(t2, i2) {
    const { sketchOptions: e4, tooltip: o2 } = this;
    switch (t2) {
      case c$1.XY:
        this._latestTooltipInfo = this._translateGraphicTooltipInfo ??= new r$a({ sketchOptions: e4 }), this._updateMoveTooltipDistance(this._latestTooltipInfo, i2, (t3, i3) => m$7(t3, i3));
        break;
      case c$1.XY_AXIS:
        this._latestTooltipInfo = this._translateGraphicXYTooltipInfo ??= new l$b({ sketchOptions: e4 }), this._updateMoveTooltipDistance(this._latestTooltipInfo, i2, (t3, e5) => g$6(m$7(t3, e5), a$2(i2)));
        break;
      case c$1.Z:
        this._latestTooltipInfo = this._translateGraphicZTooltipInfo ??= new a$c({ sketchOptions: e4 }), this._updateMoveTooltipDistance(this._latestTooltipInfo, i2, y$4);
    }
    this._latestTooltipInfo.sketchOptions = e4, o2 && (o2.info = this._latestTooltipInfo);
  }
  _updateMoveTooltipDistance(t2, i2, e4) {
    if (null == i2 || "end" === i2.action)
      return;
    const { mapStart: o2, mapEnd: a4 } = i2, s2 = e4(o2, a4);
    t2.distance = null != s2 ? s2 : m$6;
  }
  _buildSnappingPipelineSteps(t2, i2, e4, o2, a4) {
    const n2 = t2.geometry;
    if (null == n2 || "point" !== n2.type && "mesh" !== n2.type)
      return { steps: e4, cancel: o2 };
    const s2 = ("point" === n2.type ? n2 : n2.anchor).clone(), r3 = new e$g({ elevationInfo: i2, pointer: a4, editGeometryOperations: V$4.fromGeometry(s2, this.view.state.viewingMode), visualizer: new O$2(), excludeFeature: t2 }), p4 = this.snappingManager, { snappingStep: l2, cancelSnapping: h3 } = f$7({ snappingContext: r3, snappingManager: p4, updatingHandles: this._updatingHandles });
    return o2 = o2.next(h3), { steps: e4 = e4.next((i3) => {
      s2.z = g$7(this.view, s2, a$b(t2), { mode: "absolute-height", offset: 0 });
      return { ...i3, snapOrigin: r3.coordinateHelper.pointToVector(s2) };
    }).next(...l2), cancel: o2 };
  }
};
e$4([y$3({ constructOnly: true, nonNullable: true })], q.prototype, "view", void 0), e$4([y$3()], q.prototype, "graphics", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], q.prototype, "enableZ", void 0), e$4([y$3({ constructOnly: true, type: l$a })], q.prototype, "sketchOptions", void 0), e$4([y$3({ constructOnly: true })], q.prototype, "snappingManager", void 0), e$4([y$3()], q.prototype, "type", void 0), e$4([y$3()], q.prototype, "updating", null), e$4([y$3()], q.prototype, "tooltip", void 0), q = e$4([c$6("esri.views.3d.interactive.editingTools.graphicMove3D.GraphicMoveTool")], q);
class B {
  constructor(t2) {
    this.geometryRepresentation = null, this.manipulationXY = null, this.dragging = false, this.state = new e$3({ graphic: t2 });
  }
  get graphic() {
    return this.state.graphic;
  }
}
function a$1(e4, r3, o2) {
  const n2 = "on-the-ground" === o2.mode ? Z.XY : Z.XYZ;
  return new Y$2(e4, n2, r3, 0);
}
function m$1(e4, r3, n2) {
  const t2 = n$5();
  if (!e4.renderCoordsHelper.toRenderCoords(r3, t2))
    return null;
  const s2 = j$1(e4, r3, F$2(n2.plane)), f3 = j$1(e4, r3, n2.edgeDirection);
  if (null == s2 || null == f3)
    return null;
  const u2 = _$3(n$5(), s2, f3);
  return j$4(t2, u2, E$4());
}
function j$1(e4, r3, o2) {
  const t2 = e$7(r3.x + o2[0], r3.y + o2[1], r3.z + o2[2], r3.spatialReference), s2 = n$5(), i2 = n$5();
  return e4.renderCoordsHelper.toRenderCoords(r3, s2) && e4.renderCoordsHelper.toRenderCoords(t2, i2) ? J$1(i2, s2, i2) : null;
}
function g$1(e4, t2, s2) {
  const l2 = F$2(e4), d2 = J$1(n$5(), t2, s2), f3 = _$3(n$5(), d2, l2), u2 = _$3(n$5(), d2, f3);
  return t$7(d2[0], d2[1], d2[2], 0, f3[0], f3[1], f3[2], 0, u2[0], u2[1], u2[2], 0, 0, 0, 0, 1);
}
function C$1(r3, o2, n2) {
  const c2 = n2.projectToRenderScreen(r3, x$6()), i2 = n2.projectToRenderScreen(o2, x$6());
  return null != c2 && null != i2 ? v$4(e$e(c2, c2, i2)) : 0;
}
let p$2 = class p extends r$b {
  constructor(o2) {
    super(o2), this.type = "reshape-edge-offset", this.distance = m$6, this.area = null, this.totalLength = null;
  }
};
e$4([y$3()], p$2.prototype, "type", void 0), e$4([y$3()], p$2.prototype, "distance", void 0), e$4([y$3()], p$2.prototype, "area", void 0), e$4([y$3()], p$2.prototype, "totalLength", void 0), p$2 = e$4([c$6("esri.views.interactive.tooltip.ReshapeEdgeOffsetTooltipInfo")], p$2);
let Ct = class extends o$3.EventedMixin(S$2) {
  constructor(t2) {
    super(t2), this._selectedIndex = 0, this._manipulatorHandles = new e$a(), this._manipulatorInfos = [], this._numGrabbing = 0, this._numDragging = 0, this._reshapeEventState = Yt.NONE, this._updatingHandles = new h$b(), this._recreatingManipulators = false, this._settings = new z$1({ getTheme: () => this.view.effectiveTheme }), this._latestTooltipInfo = null, this._translateGraphicTooltipInfo = null, this._translateGraphicXYTooltipInfo = null, this._translateGraphicZTooltipInfo = null, this._translateVertexTooltipInfo = null, this._translateVertexXYTooltipInfo = null, this._translateVertexZTooltipInfo = null, this._edgeOffsetTooltipInfo = null, this.outputGeometry = null, this._vertexLaserLineVisualElement = null;
  }
  initialize() {
    const { graphic: t2, view: e4 } = this, i2 = this._settings.manipulators, n2 = i2.vertex;
    this._vertexManipulatorMaterial = d$6(E$2(n2.color), n2.renderOccluded), this._vertexManipulatorOutlineMaterial = f$8(E$2(n2.outlineColor), n2.renderOccluded), this._vertexManipulatorHoverOutlineMaterial = f$8(E$2(n2.hoverOutlineColor), n2.renderOccluded);
    const o2 = i2.edge;
    this._edgeManipulatorMaterial = d$6(E$2(o2.color), o2.renderOccluded), this._edgeManipulatorOutlineMaterial = f$8(E$2(o2.outlineColor), o2.renderOccluded);
    const s2 = i2.edgeOffset;
    this._edgeOffsetManipulatorMaterial = d$6(E$2(s2.color), s2.renderOccluded, false), this._edgeOffsetManipulatorHoverMaterial = d$6(E$2(s2.hoverColor), s2.renderOccluded, false);
    const r3 = i2.selected;
    this._selectedManipulatorMaterial = d$6(E$2(r3.color), r3.renderOccluded), this._selectedManipulatorOutlineMaterial = f$8(E$2(r3.outlineColor), r3.renderOccluded), this._selectedManipulatorHoverOutlineMaterial = f$8(E$2(r3.hoverOutlineColor), r3.renderOccluded);
    const l2 = this._graphicState = new e$3({ graphic: t2 });
    this.tooltip = new u$9({ view: e4 }), this.addHandles([d$3(() => {
      const t3 = this._settings.manipulators;
      return { vertexSettings: t3.vertex, edgeSettings: t3.edge, edgeOffsetSettings: t3.edgeOffset, selectedSettings: t3.selected };
    }, ({ vertexSettings: t3, edgeSettings: e5, edgeOffsetSettings: i3, selectedSettings: a4 }) => {
      t3.applyColor(this._vertexManipulatorMaterial), t3.applyOutline(this._vertexManipulatorOutlineMaterial), t3.applyHoverOutline(this._vertexManipulatorHoverOutlineMaterial), e5.applyColor(this._edgeManipulatorMaterial), e5.applyOutline(this._edgeManipulatorOutlineMaterial), i3.applyColor(this._edgeOffsetManipulatorMaterial), i3.applyHover(this._edgeOffsetManipulatorHoverMaterial), a4.applyColor(this._selectedManipulatorMaterial), a4.applyOutline(this._selectedManipulatorOutlineMaterial), a4.applyHoverOutline(this._selectedManipulatorHoverOutlineMaterial);
    }), d$3(() => l2.displaying, (t3) => {
      for (const e5 of this._manipulatorInfos)
        e5.manipulator.available = t3;
    }), d$3(() => ({ labels: this._segmentLabels, enabled: this.sketchOptions.labels.enabled, edgeOffsetEnabled: this.enableEdgeOffset }), ({ labels: t3, enabled: e5, edgeOffsetEnabled: i3 }) => {
      null != t3 && (t3.visible = e5, t3.edgeDistance = i3 ? "far" : "default");
    }, P$3), d$3(() => this.sketchOptions.tooltips.effectiveEnabled, (t3) => {
      this.tooltip.info = t3 ? this._latestTooltipInfo : null;
    }, P$3), this.view.trackGraphicState(l2)]);
  }
  destroy() {
    this._segmentLabels = u$8(this._segmentLabels), this.tooltip = u$8(this.tooltip), this._removeManipulators(), this._updatingHandles.destroy();
  }
  get inputGeometry() {
    return null != this._editGeometryOperations ? this._editGeometryOperations.data.geometry : null;
  }
  set inputGeometry(t2) {
    this._recreateEditGeometryAndManipulators(t2);
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get manipulators() {
    return this.tool.manipulators;
  }
  get view() {
    return this.tool.view;
  }
  get graphic() {
    return this.tool.graphic;
  }
  get enableZShape() {
    return this.tool.enableZShape;
  }
  get enableZVertex() {
    return this.tool.enableZVertex;
  }
  get enableMoveGraphic() {
    return this.tool.enableMoveGraphic;
  }
  get enableMidpoints() {
    return this.tool.enableMidpoints;
  }
  get enableEdgeOffset() {
    return this.tool.enableEdgeOffset;
  }
  get sketchOptions() {
    return this.tool.sketchOptions;
  }
  get _accentColor() {
    return this.view.effectiveTheme.accentColor;
  }
  removeSelectedVertices() {
    const t2 = this._manipulatorInfos.filter((t3) => t3.manipulator.selected && "vertex" === t3.type);
    this._removeVertices(t2);
  }
  onManipulatorSelectionChanged() {
    this.emit("manipulators-changed");
  }
  _removeManipulators() {
    this._manipulatorHandles.removeAll(), this._moveManipulation = u$8(this._moveManipulation), this._graphicMoveManipulation = u$8(this._graphicMoveManipulation), this.manipulators.removeAll(), this._manipulatorInfos = [], this._numGrabbing = 0, this._numDragging = 0;
  }
  _createManipulators(t2) {
    if (null == this._editGeometryOperations)
      return;
    const e4 = a$b(this.graphic);
    for (const i2 of this._editGeometryOperations.data.components) {
      const a4 = t2?.byComponentIndex.get(i2.index);
      for (const t3 of i2.vertices) {
        const i3 = a4?.has(t3.index);
        this._createVertexOrEdgeManipulator(t3, e4, i3);
      }
      for (const t3 of i2.edges)
        this._createVertexOrEdgeManipulator(t3, e4);
    }
    this._createGraphicMoveManipulation(), this._createMoveManipulation(e4), this._createVisualElements();
  }
  get canRedo() {
    return null != this._editGeometryOperations && this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return null != this._editGeometryOperations && this._editGeometryOperations.canUndo;
  }
  redo() {
    if (null == this._editGeometryOperations)
      return null;
    const t2 = this._editGeometryOperations.redo();
    return null != t2 && (this.outputGeometry = this._editGeometryOperations.data.geometry, this._recreateManipulators()), t2;
  }
  undo() {
    if (null == this._editGeometryOperations)
      return null;
    this.emit("undo");
    const t2 = this._editGeometryOperations.undo();
    return null != t2 && (this.outputGeometry = this._editGeometryOperations.data.geometry, this._recreateManipulators()), t2;
  }
  _recreateManipulators() {
    this._recreatingManipulators || (this._recreatingManipulators = true, this._removeManipulators(), this._hideTooltip(), this._createManipulators(), this._recreatingManipulators = false);
  }
  _recreateEditGeometryAndManipulators(t2) {
    const e4 = { byComponentIndex: /* @__PURE__ */ new Map() };
    if (null != t2 && null != this.inputGeometry && v$5(t2, this.inputGeometry)) {
      for (const n2 of this._manipulatorInfos)
        if ("vertex" === n2.type && n2.manipulator.selected) {
          const { index: t3, component: { index: i3 } } = n2.handle, { byComponentIndex: a5 } = e4, o2 = a5.get(i3) || /* @__PURE__ */ new Set();
          o2.add(t3), a5.set(i3, o2);
        }
    }
    if (this._recreatingManipulators = true, this._removeManipulators(), this._hideTooltip(), this._editGeometryOperations = u$8(this._editGeometryOperations), this._segmentLabels = u$8(this._segmentLabels), null == t2)
      return void (this._recreatingManipulators = false);
    const i2 = "mesh" === t2.type ? t2.anchor : t2;
    this._editGeometryOperations = V$4.fromGeometry(i2, this.view.state.viewingMode), this._createManipulators(e4);
    const a4 = this.sketchOptions.labels;
    this._segmentLabels = new a$7({ context: { view: this.view, editGeometryOperations: this._editGeometryOperations, elevationInfo: a$b(this.graphic), labelOptions: a4, graphic: this.graphic, graphicState: this._graphicState }, visible: a4.enabled }), this._recreatingManipulators = false;
  }
  _perGraphicManipulatorDragAction(t2, e4) {
    if ("end" === e4.action)
      return e4;
    let i2 = 0;
    const a4 = [], n2 = this._manipulatorInfos.some((t3) => "vertex" === t3.type && t3.manipulator.selected), o2 = t2 === qt.SELECTED_OR_ALL && n2;
    for (const s2 of this._manipulatorInfos)
      "vertex" === s2.type && (s2.manipulator.grabbing || o2 && !s2.manipulator.selected || a4.push(s2), i2++);
    if (0 === a4.length)
      return e4;
    this._moveVertices(a4, e4);
    if (a4.length === i2) {
      if (this._updateEventState(Yt.MOVING), this.destroyed)
        return e4;
      this.emit("move", { type: "move", dx: e4.screenDeltaX, dy: e4.screenDeltaY, mover: this.graphic });
    } else {
      if (this._updateEventState(Yt.RESHAPING), this.destroyed)
        return e4;
      this.emit("reshape", { type: "reshape", mover: this.graphic });
    }
    return e4;
  }
  _isMultiVertexSelection() {
    return this._manipulatorInfos.reduce((t2, e4) => "vertex" === e4.type && e4.manipulator.selected ? t2 + 1 : t2, 0) > 1;
  }
  _perVertexManipulatorDragAction(t2) {
    if (this._updateEventState(Yt.RESHAPING), this.destroyed)
      return;
    const { mapDeltaX: e4, mapDeltaY: i2, mapDeltaZ: a4 } = t2;
    if (!e4 && !i2 && !a4)
      return;
    const n2 = [];
    for (const o2 of this._manipulatorInfos)
      "vertex" === o2.type && (o2.manipulator.selected && !o2.manipulator.grabbing || o2 === t2.info) && n2.push(o2);
    this._moveVertices(n2, t2, E$5.ACCUMULATE_STEPS), this.emit("reshape", { type: "reshape", mover: this.graphic });
  }
  _updateEventState(t2) {
    if (t2 === this._reshapeEventState)
      return false;
    switch (t2) {
      case Yt.NONE:
        if (0 !== this._numGrabbing || 0 !== this._numDragging)
          return false;
        switch (this._reshapeEventState) {
          case Yt.MOVING:
            this.emit("move", { type: "move-stop", dx: 0, dy: 0, mover: this.graphic });
            break;
          case Yt.RESHAPING:
            this.emit("reshape", { type: "reshape-stop", mover: this.graphic });
        }
        break;
      case Yt.MOVING:
        switch (this._reshapeEventState) {
          case Yt.NONE:
            this.emit("move", { type: "move-start", dx: 0, dy: 0, mover: this.graphic });
            break;
          case Yt.RESHAPING:
            this.emit("reshape", { type: "reshape-stop", mover: this.graphic }), this.destroyed || this.emit("move", { type: "move-start", dx: 0, dy: 0, mover: this.graphic });
        }
        break;
      case Yt.RESHAPING:
        switch (this._reshapeEventState) {
          case Yt.NONE:
            this.emit("reshape", { type: "reshape-start", mover: this.graphic });
            break;
          case Yt.MOVING:
            this.emit("move", { type: "move-stop", dx: 0, dy: 0, mover: this.graphic }), this.destroyed || this.emit("reshape", { type: "reshape-start", mover: this.graphic });
        }
    }
    if (this.destroyed)
      return false;
    const e4 = this._reshapeEventState !== t2;
    return this._reshapeEventState = t2, e4;
  }
  _createGraphicMoveManipulation() {
    const { tool: t2, view: e4 } = this, i2 = this._graphicState;
    if (this._graphicMoveManipulation = new l({ tool: t2, view: e4, graphicState: i2 }), this.enableMoveGraphic) {
      let t3 = null;
      this._manipulatorHandles.add(this._graphicMoveManipulation.createDragPipeline((e5, i3, a4) => {
        i3.next((t4) => this._trackNumDragging(t4)).next((e6) => ("start" === e6.action && (t3 = this._editGeometryOperations.createUndoGroup()), e6)).next((t4) => this._perGraphicManipulatorDragAction(qt.ALL, t4)).next((t4) => (this._updateTranslateGraphicTooltip(c$1.XY, t4), t4)).next((e6) => {
          "end" === e6.action && (this._hideTooltip(), t3 = l$7(t3));
        }), a4.next(() => this._onDragCancel(true, () => t3 = l$7(t3)));
      })), this._graphicMoveManipulation.forEachManipulator((t4) => this._manipulatorHandles.add(this._watchAndUpdateGrabState(t4, false)));
    } else
      this._graphicMoveManipulation.forEachManipulator((t3) => {
        t3.grabbable = false, t3.cursor = null;
      });
    this._graphicMoveManipulation.forEachManipulator((t3) => this._manipulatorHandles.add(t3.events.on("immediate-click", (t4) => {
      this._manipulatorInfos.some((t5) => t5.manipulator.selected) ? this._clearSelection() : this.emit("immediate-click", { ...t4, graphic: this.graphic }), t4.stopPropagation();
    })));
  }
  _createMoveManipulation(t2) {
    const { graphic: e4, tool: i2, view: a4 } = this, n2 = this._graphicState;
    this._moveManipulation = new u({ tool: i2, view: a4, xyAvailable: true, xyAxisAvailable: true, zAvailable: this.enableZShape && n$8(e4), snapToScene: false, radius: u.radiusForSymbol(e4.symbol) }), this._moveManipulation.forEachManipulator((t3) => this.addHandles([t3.events.on("immediate-click", (i3) => {
      this._moveManipulation.zManipulation.hasManipulator(t3) || this._manipulatorInfos.some((t4) => t4.manipulator.selected) || this.emit("immediate-click", { ...i3, graphic: e4 }), i3.stopPropagation();
    }), this._watchAndUpdateGrabState(t3, false)]));
    const o2 = (t3) => (e5) => {
      this.addHandles(e5.events.on("focus-changed", ({ action: e6 }) => {
        "focus" === e6 ? this._updateTranslateTooltip(t3) : this._hideTooltip();
      }));
    };
    this._moveManipulation.xyManipulation.forEachManipulator(o2(c$1.XY)), this._moveManipulation.xyAxisManipulation.forEachManipulator(o2(c$1.XY_AXIS)), this._moveManipulation.zManipulation.forEachManipulator(o2(c$1.Z)), this._moveManipulation.elevationInfo = { mode: "absolute-height", offset: 0 };
    const s2 = e4.geometry.spatialReference;
    this.addHandles([this._moveManipulation.createDragPipeline((a5, n3, o3, s3, r3) => {
      const { snappingStep: l2, cancelSnapping: p4 } = f$7({ predicate: (t3) => !!t3.info, snappingManager: i2.snappingManager, snappingContext: new e$g({ editGeometryOperations: this._editGeometryOperations, elevationInfo: t2, pointer: r3, excludeFeature: e4, visualizer: new O$2() }), updatingHandles: this._updatingHandles, useZ: false });
      return s3 = s3.next((t3) => (this._onDragCancel(), t3)).next(p4), { steps: o3 = o3.next((t3) => this._trackNumDragging(t3)).next((t3) => {
        const e5 = this._manipulatorInfos.filter((t4) => "vertex" === t4.type && t4.manipulator.selected);
        return t3.manipulatorType === A$3.TRANSLATE_XY && 1 === e5.length ? { ...t3, info: e5[0], snapOrigin: e5[0].handle.pos } : t3;
      }).next(Z$1(this.view, t2, e4)).next(...l2).next(D$5()).next((t3) => this._perGraphicManipulatorDragAction(qt.SELECTED_OR_ALL, t3)).next((t3) => (this._updateTranslateTooltip(a5, t3), t3)), cancel: s3 };
    }, t2, s2, e4), d$3(() => n2.displaying, () => this._updateMoveManipulationPosition(), P$3), n2.on("changed", () => {
      this._recreatingManipulators || this._updateMoveManipulationPosition();
    }), d$3(() => n2.isDraped, (t3) => {
      this._updateMoveManipulationPosition();
      const e5 = "align-move-manipulation";
      t3 ? this.addHandles(this.view.elevationProvider.on("elevation-change", () => this._updateMoveManipulationPosition()), e5) : this.removeHandles(e5);
    }, P$3)]);
  }
  _createVisualElements() {
    const { graphic: t2, view: e4 } = this, i2 = i$2({ view: e4, graphic: t2, forEachManipulator: (t3) => {
      if (!this.destroyed && !this._recreatingManipulators) {
        this._graphicMoveManipulation.forEachManipulator(t3), this._moveManipulation.forEachManipulator(t3);
        for (const e5 of this._manipulatorInfos)
          t3(e5.manipulator, A$3.TRANSLATE_XY);
      }
    }, onManipulatorsChanged: (t3) => this.on("manipulators-changed", t3) });
    null != i2 && (this._outlineVisualElement = i2.visualElement instanceof w$1 ? i2.visualElement : null), null != this._outlineVisualElement && this._manipulatorHandles.add(this._outlineVisualElement.events.on("attachment-origin-changed", () => {
      this._graphicState.isDraped || this._updateMoveManipulationPosition();
    })), this._manipulatorHandles.add(i2);
  }
  _createEdgeOffsetManipulator(t2, e4 = a$b(this.graphic)) {
    if (t2.component.vertices.length <= 2)
      return null;
    const i2 = this._settings.manipulators.edgeOffset, a4 = i2.size / 2, n2 = a4 + i2.collisionPadding, o2 = a4 / n2, r3 = o2 * Math.sqrt(3) / 2;
    null == this._edgeOffsetManipulatorGeometryInside && (this._edgeOffsetManipulatorGeometryInside = wt$1(this._edgeOffsetManipulatorMaterial, r3, o2 / 2, o2 / 2, i2.height, i2.offset)), null == this._edgeOffsetManipulatorGeometryOutside && (this._edgeOffsetManipulatorGeometryOutside = wt$1(this._edgeOffsetManipulatorMaterial, -r3, o2 / 2, o2 / 2, i2.height, -i2.offset));
    const l2 = [new e$b(this._edgeOffsetManipulatorGeometryInside.instantiate(), t$6.Unfocused), new e$b(this._edgeOffsetManipulatorGeometryInside.instantiate({ material: this._edgeOffsetManipulatorHoverMaterial }), t$6.Focused), new e$b(this._edgeOffsetManipulatorGeometryOutside.instantiate(), t$6.Unfocused), new e$b(this._edgeOffsetManipulatorGeometryOutside.instantiate({ material: this._edgeOffsetManipulatorHoverMaterial }), t$6.Focused)], p4 = new ee({ view: this.view, renderObjects: l2, elevationInfo: "on-the-ground" !== e4.mode || y$5(this.graphic.symbol) ? { mode: "absolute-height", offset: 0 } : e4, worldOriented: false, focusMultiplier: 1, radius: n2, available: !(!this.graphic.visible || !this.graphic.layer?.visible), collisionType: { type: "disc", direction: r$9(0, 0, 1) }, collisionPriority: 1, metadata: { deleting: false } }), h3 = new ee({ view: this.view, worldSized: true, worldOriented: false, available: !(!this.graphic.visible || !this.graphic.layer?.visible), collisionPriority: -10, cursor: this.enableMoveGraphic ? "move" : "default", metadata: { deleting: false } }), u2 = { manipulator: p4, handle: t2, locationUpdateHandle: null, type: "edge", selectedIndex: 0, edgeManipulator: h3, elevationInfo: e4, visibilityHandle: null };
    this._autoHideEdgeOffsetManipulator(u2, i2.minSquaredEdgeLength), this._updateEdgeOffsetManipulator(u2);
    const c2 = [];
    for (const s2 of [t2.leftVertex, t2.rightVertex]) {
      const t3 = this._getManipulatorInfoFromHandle(s2);
      null != t3 && c2.push(t3.manipulator.events.on("location-update", () => this._updateEdgeOffsetManipulator(u2)));
    }
    u2.locationUpdateHandle = r$5(c2), this._manipulatorHandles.add(u2.locationUpdateHandle, p4), this._manipulatorHandles.add([this._watchAndUpdateGrabState(p4, true), this._watchAndUpdateGrabState(h3, true)], p4), this._manipulatorHandles.add(x$5(p4, this._createEdgeOffsetPipeline(u2, e4)), p4), this._manipulatorHandles.add(x$5(h3, (t3, i3, a5, n3) => {
      if ("touch" === n3) {
        this._createEdgeOffsetPipeline(u2, e4)(t3, i3, a5);
      } else if (this.enableMoveGraphic) {
        const n4 = this.graphic, o3 = null != n4.geometry ? n4.geometry.spatialReference : null;
        i3.next((t4) => this._trackNumDragging(t4)).next(C$7(this.view, t3.elevationAlignedLocation)).next(D$4(this.view, t3.elevationAlignedLocation, e4, o3, n4)).next(P$5()).next(D$5()).next((t4) => this._perGraphicManipulatorDragAction(qt.ALL, t4)).next((t4) => (this._updateTranslateGraphicTooltip(c$1.XY, t4), t4)).next((t4) => {
          "end" === t4.action && this._hideTooltip();
        }), a5.next(() => this._onDragCancel(!t3.metadata.deleting));
      }
    }), p4);
    const m3 = (t3) => {
      this._manipulatorInfos.some((t4) => t4.manipulator.selected) ? this._clearSelection() : this.emit("immediate-click", { ...t3, graphic: this.graphic }), t3.stopPropagation();
    };
    return this._manipulatorHandles.add([p4.events.on("immediate-click", m3), h3.events.on("immediate-click", m3), p4.events.on("focus-changed", ({ action: t3 }) => {
      const { sketchOptions: e5, tooltip: i3 } = this;
      if ("focus" === t3) {
        const t4 = this._edgeOffsetTooltipInfo ??= new p$2({ sketchOptions: e5 });
        t4.distance = m$6, t4.sketchOptions = e5, this._updateTooltipAreaOrTotalLength(t4), this._latestTooltipInfo = t4, i3.info = e5.tooltips.effectiveEnabled ? this._latestTooltipInfo : null;
      } else
        this._hideTooltip();
    })], p4), this._manipulatorInfos.push(u2), this.manipulators.add(p4), this.manipulators.add(h3), this.emit("manipulators-changed"), u2;
  }
  _autoHideEdgeOffsetManipulator(t2, e4) {
    const i2 = t2.manipulator, a4 = t2.edgeManipulator, n2 = () => {
      t2.visibilityHandle = l$7(t2.visibilityHandle);
      const n3 = this._getManipulatorInfoFromHandle(t2.handle.leftVertex), o2 = this._getManipulatorInfoFromHandle(t2.handle.rightVertex), l2 = null != n3 && null != o2 && C$1(n3.manipulator.renderLocation, o2.manipulator.renderLocation, this.view.state.camera) < e4;
      (!i2.focused && !a4.focused || l2) && (i2.grabbable = !l2, a4.grabbable = !l2, t2.visibilityHandle = r$5([i2.disableDisplay(), e$5(() => {
        i2.grabbable = true, a4.grabbable = this.enableMoveGraphic;
      })]));
    };
    this._manipulatorHandles.add([i2.events.on("focus-changed", n2), a4.events.on("focus-changed", n2), e$5(() => {
      l$7(t2.visibilityHandle), a4.metadata.deleting = true, this.manipulators.remove(a4);
    })], i2), n2();
  }
  _updateEdgeOffsetManipulator(t2) {
    this._updateManipulatorPosition(t2);
    const { coordinateHelper: e4 } = this._editGeometryOperations.data, i2 = m$1(this.view, t2.manipulator.elevationAlignedLocation, a$1(e4, t2.handle, t2.manipulator.elevationInfo)), a4 = this._getManipulatorInfoFromHandle(t2.handle.leftVertex), n2 = this._getManipulatorInfoFromHandle(t2.handle.rightVertex);
    if (null == a4 || null == n2)
      return;
    const o2 = a4.manipulator.renderLocation, s2 = n2.manipulator.renderLocation, r3 = null != i2 ? g$1(i2, o2, s2) : o$8;
    t2.manipulator.modelTransform = r3, t2.edgeManipulator.elevationAlignedLocation = t2.manipulator.elevationAlignedLocation, t2.edgeManipulator.modelTransform = r3;
    const l2 = s$3(e$e(zt, o2, s2)) / 2;
    t2.edgeManipulator.collisionType = { type: "line", paths: [[[-l2, 0, 0], [l2, 0, 0]]] };
  }
  _createEdgeOffsetPipeline(t2, e4) {
    return (i2, a4, n2) => {
      this._clearSelection();
      const { step: o2, cleanup: s2 } = this._initializeEdgeOffset(t2, e4);
      a4.next((t3) => this._trackNumDragging(t3)).next(C$7(this.view, i2.elevationAlignedLocation)).next(o2).next(C$8(this.view)).next(A$8(this.view, this._editGeometryOperations.data.spatialReference)).next(D$5()).next(this._applyComputeEdgeOffsetDistanceStep()).next(this._applyEdgeOffsetStep(t2)).next(this._showEdgeOffsetTooltip()).next((t3) => {
        "end" === t3.action && s2();
      }), n2.next(() => {
        i2.metadata.deleting || (s2(), this._onDragCancel());
      });
    };
  }
  _initializeEdgeOffset(t2, e4) {
    const { view: i2 } = this, n2 = this._editGeometryOperations, o2 = a$1(n2.data.coordinateHelper, t2.handle, e4), r3 = n2.createUndoGroup(), p4 = m$1(i2, t2.manipulator.elevationAlignedLocation, o2);
    if (o2.requiresSplitEdgeLeft) {
      const e5 = this._getManipulatorInfoFromHandle(t2.handle.leftVertex.leftEdge);
      null != e5 && this._splitEdgeManipulator(e5, 1);
    }
    if (o2.requiresSplitEdgeRight) {
      const e5 = this._getManipulatorInfoFromHandle(t2.handle.rightVertex.rightEdge);
      null != e5 && this._splitEdgeManipulator(e5, 0);
    }
    const d2 = () => new m$8({ paths: [[t2.handle.leftVertex.pos, t2.handle.rightVertex.pos]], spatialReference: n2.data.spatialReference }), u2 = this._settings, c2 = new w$1({ view: i2, isDraped: this._graphicState.isDraped, geometry: d2(), elevationInfo: t2.elevationInfo, width: u2.visualElements.lineGraphics.outline.width, attached: false, isDecoration: true });
    let _2;
    const f3 = () => {
      this._cleanEdgeOffsetCollapsedEdges(t2), _2 = l$7(_2);
    }, v2 = this.on("undo", f3);
    return _2 = r$5([d$3(() => E$2(this._accentColor), (t3) => c2.color = t3, P$3), i$6(c2), d$3(() => this._graphicState.isDraped, (t3) => c2.isDraped = t3), this._graphicState.on("changed", () => c2.geometry = d2()), r3, v2]), c2.attached = true, { step: (t3) => null == o2 || null == p4 ? (f3(), null) : { ...t3, operation: o2, plane: p4 }, cleanup: f3 };
  }
  _applyEdgeOffsetStep(t2) {
    return (e4) => {
      if (this.destroyed || null == e4.operation)
        return e4;
      this._updateEventState(Yt.RESHAPING);
      const { mapDeltaX: i2, mapDeltaY: a4, mapDeltaZ: n2 } = e4;
      return (i2 || a4 || n2) && (this._offsetEdge(t2, e4), this.emit("reshape", { type: "reshape", mover: this.graphic })), e4;
    };
  }
  _applyComputeEdgeOffsetDistanceStep() {
    return (t2) => {
      const { operation: e4, mapEnd: i2 } = t2;
      return null == e4 || null == i2 ? t2 : ("start" === t2.action && e4.selectArrowFromStartPoint(i2), { ...t2, signedDistance: e4.signedDistanceToPoint(i2) });
    };
  }
  _showEdgeOffsetTooltip() {
    return (t2) => {
      const { mapEnd: e4, signedDistance: i2, operation: a4 } = t2, { tooltip: n2, sketchOptions: o2 } = this;
      if (null != i2) {
        const n3 = this._edgeOffsetTooltipInfo ??= new p$2({ sketchOptions: o2 });
        n3.sketchOptions = o2, n3.distance = "end" === t2.action ? m$6 : Rt$1(this._graphicState.isDraped, i2 * a4.selectedArrow, e4, a4.plane, this._editGeometryOperations.data.coordinateHelper), this._updateTooltipAreaOrTotalLength(n3), this._latestTooltipInfo = n3;
      } else
        this._latestTooltipInfo = null;
      return n2.info = o2.tooltips.effectiveEnabled ? this._latestTooltipInfo : null, t2;
    };
  }
  _cleanEdgeOffsetCollapsedEdges(t2) {
    const e4 = t2.handle.leftVertex.leftEdge?.leftVertex, i2 = t2.handle.leftVertex, a4 = t2.handle.rightVertex.rightEdge?.rightVertex, n2 = t2.handle.rightVertex, o2 = this._editGeometryOperations.data.coordinateHelper, s2 = [];
    if (e4 && o2.distance(e4.pos, i2.pos) < Xt) {
      const t3 = this._getManipulatorInfoFromHandle(i2);
      null != t3 && s2.push(t3);
    }
    if (o2.distance(i2.pos, n2.pos) < Xt || a4 && o2.distance(a4.pos, n2.pos) < Xt) {
      const t3 = this._getManipulatorInfoFromHandle(n2);
      null != t3 && s2.push(t3);
    }
    s2.length && this._removeVertices(s2);
  }
  _computeVertexManipulatorSizeAndOutline(t2) {
    const e4 = t2.size / 2, i2 = e4 + t2.collisionPadding;
    return { size: e4 / i2, outlineSize: (e4 + t2.outlineSize) / i2 };
  }
  _createVertexOrEdgeManipulator(t2, e4 = a$b(this.graphic), i2 = false) {
    const { view: a4 } = this, n2 = this._settings;
    if ("edge" === t2.type) {
      if (this.enableEdgeOffset)
        return this._createEdgeOffsetManipulator(t2, e4);
      if (!this.enableMidpoints)
        return null;
    }
    if (null == this._vertexManipulatorGeometry || null == this._vertexManipulatorOutlineGeometry) {
      const { size: t3, outlineSize: e5 } = this._computeVertexManipulatorSizeAndOutline(n2.manipulators.vertex);
      this._vertexManipulatorGeometry = st(this._vertexManipulatorMaterial, t3, 16, 16), this._vertexManipulatorOutlineGeometry = st(this._vertexManipulatorOutlineMaterial, e5, 16, 16);
    }
    if (null == this._edgeManipulatorGeometry || null == this._edgeManipulatorOutlineGeometry) {
      const { size: t3, outlineSize: e5 } = this._computeVertexManipulatorSizeAndOutline(n2.manipulators.edge);
      this._edgeManipulatorGeometry = st(this._edgeManipulatorMaterial, t3, 16, 16), this._edgeManipulatorOutlineGeometry = st(this._edgeManipulatorOutlineMaterial, e5, 16, 16);
    }
    const { geometry: o2 } = this.graphic, r3 = o2?.type, l2 = "point" === r3 || "mesh" === r3 ? [] : [new e$b(this._vertexManipulatorGeometry.instantiate(), Zt.Vertex | t$6.Unselected), new e$b(this._vertexManipulatorOutlineGeometry.instantiate(), Zt.Vertex | t$6.Unfocused | t$6.Unselected), new e$b(this._vertexManipulatorOutlineGeometry.instantiate({ material: this._vertexManipulatorHoverOutlineMaterial }), Zt.Vertex | t$6.Focused | t$6.Unselected), new e$b(this._vertexManipulatorGeometry.instantiate({ material: this._selectedManipulatorMaterial }), t$6.Selected), new e$b(this._vertexManipulatorOutlineGeometry.instantiate({ material: this._selectedManipulatorOutlineMaterial }), t$6.Selected | t$6.Unfocused), new e$b(this._vertexManipulatorOutlineGeometry.instantiate({ material: this._selectedManipulatorHoverOutlineMaterial }), t$6.Selected | t$6.Focused)];
    this.enableMidpoints && l2.push(new e$b(this._edgeManipulatorGeometry.instantiate({ material: this._vertexManipulatorMaterial }), Zt.Edge | t$6.Focused | t$6.Unselected), new e$b(this._edgeManipulatorOutlineGeometry.instantiate({ material: this._vertexManipulatorHoverOutlineMaterial }), Zt.Edge | t$6.Focused | t$6.Unselected), new e$b(this._edgeManipulatorGeometry.instantiate(), Zt.Edge | t$6.Unfocused | t$6.Unselected), new e$b(this._edgeManipulatorOutlineGeometry.instantiate(), Zt.Edge | t$6.Unfocused | t$6.Unselected));
    const p4 = new ee({ view: a4, renderObjects: l2, elevationInfo: e4, focusMultiplier: 1, touchMultiplier: 1, available: !(!this.graphic.visible || !this.graphic.layer?.visible), metadata: { deleting: false } });
    p4.selected = i2, this._setTypeSpecificManipulatorSettings(p4, t2, e4);
    const d2 = "edge" === t2.type ? { manipulator: p4, handle: t2, locationUpdateHandle: null, type: "edge", selectedIndex: 0 } : { manipulator: p4, handle: t2, type: "vertex", selectedIndex: 0 };
    if (this._manipulatorInfos.push(d2), this.manipulators.add(p4), this._updateManipulatorPosition(d2), "edge" === d2.type) {
      const t3 = [];
      for (const e5 of [d2.handle.leftVertex, d2.handle.rightVertex]) {
        const i3 = this._getManipulatorInfoFromHandle(e5);
        null != i3 && t3.push(i3.manipulator.events.on("location-update", () => this._updateManipulatorPosition(d2)));
      }
      d2.locationUpdateHandle = r$5(t3), this._manipulatorHandles.add(d2.locationUpdateHandle, p4);
    }
    this._manipulatorHandles.add(this._watchAndUpdateGrabState(p4, true), p4);
    const u2 = x$5(p4, (t3, i3, a5, n3) => {
      let o3 = null;
      const { snappingStep: s2, cancelSnapping: r4 } = f$7({ predicate: () => !this._isMultiVertexSelection(), snappingManager: this.tool.snappingManager, snappingContext: new e$g({ editGeometryOperations: this._editGeometryOperations, elevationInfo: e4, pointer: n3, excludeFeature: this.graphic, visualizer: new O$2() }), updatingHandles: this._updatingHandles, useZ: false });
      a5 = a5.next((e5) => (this._onDragCancel(!t3.metadata.deleting, () => o3 = l$7(o3)), e5)).next(r4), i3.next((t4) => this._trackNumDragging(t4)).next((t4) => {
        if ("start" === t4.action && (o3 = this._editGeometryOperations.createUndoGroup()), "edge" === d2.type) {
          const e5 = this._splitEdgeManipulator(d2);
          return { ...t4, info: e5, snapOrigin: e5.handle.pos };
        }
        return { ...t4, info: d2, snapOrigin: d2.handle.pos };
      }).next(C$7(this.view, t3.elevationAlignedLocation)).next(M$6(this.view, this.graphic, t3.elevationAlignedLocation, t3.location.spatialReference, this.graphic)).next(Z$1(this.view, e4, this.graphic)).next(...s2).next(D$5()).next((e5) => {
        this._perVertexManipulatorDragAction(e5), "end" === e5.action && (o3 = l$7(o3)), this._updateTranslateVertexTooltip(t3, c$1.XY, e5);
      });
    });
    return this._manipulatorHandles.add([u2, p4.events.on("immediate-click", (t3) => this._manipulatorClickCallback(t3, d2)), p4.events.on("select-changed", () => {
      d2.selectedIndex = ++this._selectedIndex, this._updateMoveManipulationPosition();
    }), p4.events.on("focus-changed", ({ action: t3 }) => {
      "focus" === t3 && "edge" !== d2.type ? this._updateTranslateVertexTooltip(p4, c$1.XY) : this._hideTooltip();
    })], p4), this.emit("manipulators-changed"), d2;
  }
  _trackNumDragging(t2) {
    switch (t2.action) {
      case "start":
        this._numDragging++;
        break;
      case "end":
        this._numDragging--;
    }
    return t2;
  }
  _onDragCancel(t2 = true, e4) {
    switch (this._numDragging--, t2 && (this.undo(), this.outputGeometry = null != this._editGeometryOperations ? this._editGeometryOperations.data.geometry : null), null != this.tool.snappingManager && this.tool.snappingManager.doneSnapping(), this._hideTooltip(), this._reshapeEventState) {
      case Yt.NONE:
        break;
      case Yt.MOVING:
        this.emit("move", { type: "move", dx: 0, dy: 0, mover: this.graphic });
        break;
      case Yt.RESHAPING:
        this.emit("reshape", { type: "reshape", mover: this.graphic });
    }
    e4 && e4(), this.destroyed || this._updateEventState(Yt.NONE);
  }
  _setTypeSpecificManipulatorSettings(t2, e4, i2) {
    const { graphic: a4 } = this, n2 = this._settings;
    switch (e4.type) {
      case "vertex": {
        t2.state = Zt.Vertex, t2.selectable = true, t2.cursor = "move", t2.collisionPriority = 2;
        const { size: e5, collisionPadding: o2 } = n2.manipulators.vertex;
        t2.radius = e5 / 2 + o2, t2.elevationInfo = i2;
        const { geometry: s2 } = a4, r3 = s2?.type;
        t2.interactive = null != r3 && "point" !== r3 && "mesh" !== r3;
        break;
      }
      case "edge": {
        t2.state = Zt.Edge, t2.selectable = false, t2.cursor = "copy", t2.collisionPriority = -1;
        const { size: e5, collisionPadding: o2 } = n2.manipulators.edge;
        t2.radius = e5 / 2 + o2, t2.elevationInfo = "on-the-ground" !== i2.mode || y$5(a4.symbol) ? { mode: "absolute-height", offset: 0 } : i2;
        break;
      }
    }
  }
  _watchAndUpdateGrabState(t2, e4) {
    return t2.events.on("grab-changed", (i2) => this._onGrabStateChanged(t2, e4, i2.action, i2.pointerType));
  }
  _onGrabStateChanged(t2, e4, i2, a4 = "mouse") {
    if (!this._recreatingManipulators) {
      if ("start" === i2)
        e4 && this._updateSelection(t2), this._numGrabbing++;
      else if (this._numGrabbing--, this._updateEventState(Yt.NONE), this.destroyed)
        return;
      this._moveManipulation.interactive = !this._numGrabbing, ("touch" !== a4 || this.enableEdgeOffset) && (this._manipulatorInfos.forEach((t3) => {
        const { manipulator: e5 } = t3, { geometry: i3 } = this.graphic, a5 = i3?.type;
        e5.interactive = e5.grabbing || !this._numGrabbing && null != a5 && "point" !== a5 && "mesh" !== a5, "edgeManipulator" in t3 && (t3.edgeManipulator.interactive = t3.edgeManipulator.grabbing || !this._numGrabbing);
      }), this._graphicMoveManipulation.forEachManipulator((t3) => {
        t3.interactive = t3.grabbing || !this._numGrabbing;
      }));
    }
  }
  _clearSelection() {
    for (const t2 of this._manipulatorInfos)
      t2.manipulator.grabbing || (t2.manipulator.selected = false);
  }
  _updateSelection(t2) {
    t2.grabbing && !t2.selected && t2.selectable && (this._clearSelection(), t2.selected = true, this.emit("manipulators-changed"));
  }
  _removeManipulator(t2) {
    null != t2 && (t2.manipulator.metadata.deleting = true, this.manipulators.remove(t2.manipulator), this._manipulatorHandles.remove(t2.manipulator), I$1(this._manipulatorInfos, t2), this.emit("manipulators-changed"));
  }
  _getManipulatorInfoFromHandle(t2) {
    if (t2) {
      for (const e4 of this._manipulatorInfos)
        if (t2 === e4.handle)
          return e4;
    }
    return null;
  }
  _updateManipulatorPosition(t2) {
    if (null == t2)
      return;
    const e4 = this._editGeometryOperations;
    if ("vertex" === t2.type)
      t2.manipulator.location = e4.data.coordinateHelper.vectorToDehydratedPoint(t2.handle.pos, Ft), t2.manipulator.grabbing && null != this._vertexLaserLineVisualElement && (this._vertexLaserLineVisualElement.visualElement.intersectsWorldUpAtLocation = t2.manipulator.renderLocation);
    else if ("edge" === t2.type) {
      const i2 = this._getManipulatorInfoFromHandle(t2.handle.leftVertex), a4 = this._getManipulatorInfoFromHandle(t2.handle.rightVertex);
      if (null == i2 || null == a4)
        return;
      const n2 = i2.manipulator, o2 = a4.manipulator;
      if (null != t2.manipulator.elevationInfo && "on-the-ground" === t2.manipulator.elevationInfo.mode) {
        const i3 = n2.location, a5 = o2.location, s2 = 0.5, r3 = i3.x + s2 * (a5.x - i3.x), l2 = i3.y + s2 * (a5.y - i3.y), p4 = i3.hasZ && a5.hasZ ? 0 : void 0;
        t2.manipulator.location = e$7(r3, l2, p4, e4.data.spatialReference);
      } else
        A$9(zt, n2.renderLocation, o2.renderLocation, 0.5), t2.manipulator.renderLocation = zt;
    }
  }
  _splitEdgeManipulator(t2, e4 = 0.5) {
    const i2 = this._editGeometryOperations, a4 = i2.splitEdge(t2.handle, e4).createdVertex;
    t2.locationUpdateHandle = l$7(t2.locationUpdateHandle);
    const n2 = a$b(this.graphic);
    let o2;
    this.enableEdgeOffset ? (this._removeManipulator(t2), o2 = this._createVertexOrEdgeManipulator(a4)) : (o2 = t2, o2.handle = a4, o2.type = "vertex", this._setTypeSpecificManipulatorSettings(t2.manipulator, t2.handle, n2)), a4.leftEdge && this._createVertexOrEdgeManipulator(a4.leftEdge), a4.rightEdge && this._createVertexOrEdgeManipulator(a4.rightEdge), this.outputGeometry = i2.data.geometry, this._updateManipulatorPosition(o2), this.enableEdgeOffset || this._updateTranslateVertexTooltip(o2.manipulator, c$1.XY), this._updateSelection(t2.manipulator);
    const s2 = this._updateEventState(Yt.RESHAPING), r3 = i2.data.coordinateHelper.vectorToArray(o2.handle.pos), l2 = i2.data.components.indexOf(a4.component);
    return this.emit("vertex-add", { type: "vertex-add", vertices: [{ coordinates: r3, componentIndex: l2, vertexIndex: a4.index }], added: r3 }), s2 && this._updateEventState(Yt.NONE), o2;
  }
  _updateMoveManipulationPosition() {
    const t2 = o$4(zt, 0, 0, 0);
    let e4 = 0, i2 = false, a4 = null, n2 = null;
    for (const o2 of this._manipulatorInfos)
      "vertex" === o2.type && (o2.manipulator.selected ? (e4++, u$6(t2, t2, o2.manipulator.renderLocation), null == a4 || o2.selectedIndex > a4.selectedIndex ? (n2 = a4, a4 = o2) : (null == n2 || o2.selectedIndex > n2.selectedIndex) && (n2 = o2)) : i2 = true);
    if (0 === e4) {
      const t3 = this._graphicState.displaying && this.enableMoveGraphic;
      this._moveManipulation.xyManipulation.available = t3, this._moveManipulation.xyAxisManipulation.available = t3, this._moveManipulation.xyAxisManipulation.orthogonalAvailable = t3, this._moveManipulation.zManipulation.available = t3 && this.enableZShape && n$8(this.graphic), this._moveManipulation.angle = r$3(this.graphic.geometry), this._moveManipulation.radius = u.radiusForSymbol(this.graphic.symbol);
    } else {
      const t3 = this._graphicState.displaying;
      this._moveManipulation.xyManipulation.available = t3, this._moveManipulation.xyAxisManipulation.available = t3, this._moveManipulation.zManipulation.available = t3 && this.enableZVertex && n$8(this.graphic), this._moveManipulation.xyAxisManipulation.orthogonalAvailable = t3 && 1 !== e4;
      let i3 = 0;
      if (null != a4) {
        const t4 = a4.handle.pos, e5 = null != n2 ? n2.handle.pos : a4.handle.leftEdge && a4.handle.leftEdge.leftVertex ? a4.handle.leftEdge.leftVertex.pos : null, o2 = null == n2 && a4.handle.rightEdge && a4.handle.rightEdge.rightVertex ? a4.handle.rightEdge.rightVertex.pos : null;
        e5 && o2 ? this._moveManipulation.xyAxisManipulation.available = false : e5 ? i3 = Nt(e5, t4) : o2 && (i3 = Nt(t4, o2));
      }
      this._moveManipulation.angle = i3, this._moveManipulation.radius = o$1;
    }
    0 !== e4 && i2 ? (g$5(t2, t2, 1 / e4), Ft.spatialReference = this._editGeometryOperations.data.spatialReference, Ft.hasZ = true, this.view.renderCoordsHelper.fromRenderCoords(t2, Ft), this._moveManipulation.elevationAlignedLocation = Ft) : null == this._outlineVisualElement || this._graphicState.isDraped || null == this._outlineVisualElement.attachmentOrigin ? y$6(this.view, this._moveManipulation, this.graphic) : this._moveManipulation.elevationAlignedLocation = this._outlineVisualElement.attachmentOrigin;
  }
  _removeVertices(t2) {
    const e4 = new Array(), i2 = this._editGeometryOperations;
    for (const a4 of t2) {
      const t3 = a4.handle.component;
      if ("vertex" === a4.type && i2.canRemoveVertex(t3)) {
        e4.push(a4.handle), this._removeManipulator(a4), this._removeManipulator(this._getManipulatorInfoFromHandle(a4.handle.leftEdge)), this._removeManipulator(this._getManipulatorInfoFromHandle(a4.handle.rightEdge));
        const n2 = i2.removeVertices([a4.handle]), o2 = n2.removedVertices?.[0].createdEdge;
        o2 ? this._createVertexOrEdgeManipulator(o2) : this.enableEdgeOffset && t3.vertices.length <= 2 && this._removeManipulator(this._getManipulatorInfoFromHandle(t3.edges[0]));
      }
    }
    if (e4.length > 0) {
      const t3 = e4.map((t4) => {
        const e5 = i2.data.components.indexOf(t4.component);
        return { coordinates: i2.data.coordinateHelper.vectorToArray(t4.pos), componentIndex: e5, vertexIndex: t4.index };
      });
      this.outputGeometry = i2.data.geometry;
      const a4 = this._updateEventState(Yt.RESHAPING);
      if (this.destroyed)
        return;
      if (this.emit("vertex-remove", { type: "vertex-remove", removed: t3.map((t4) => t4.coordinates), vertices: t3 }), this.destroyed)
        return;
      if (a4 && (this._updateEventState(Yt.NONE), this.destroyed))
        return;
      this._updateMoveManipulationPosition();
    }
  }
  _moveVertices(t2, e4, i2 = "start" === e4.action ? E$5.NEW_STEP : E$5.ACCUMULATE_STEPS) {
    const a4 = this._editGeometryOperations;
    a4.moveVertices(t2.map((t3) => t3.handle), e4.mapDeltaX, e4.mapDeltaY, e4.mapDeltaZ, i2), this.outputGeometry = a4.data.geometry;
    for (const n2 of t2)
      this._updateManipulatorPosition(n2);
  }
  _offsetEdge(t2, e4) {
    if (null == e4.operation || null == e4.signedDistance)
      return;
    const i2 = this._editGeometryOperations, a4 = e4.operation.clone();
    a4.distance = e4.signedDistance, i2.updateVertices([t2.handle.leftVertex, t2.handle.rightVertex], a4), this.outputGeometry = i2.data.geometry, this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(t2.handle.leftVertex)), this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(t2.handle.rightVertex));
  }
  _manipulatorClickCallback(t2, e4) {
    t2.shiftKey || this._clearSelection(), "vertex" === e4.type && (e4.manipulator.selected = !e4.manipulator.selected, t2.button === t$8.Right && this._removeVertices([e4])), "edge" === e4.type && t2.button === t$8.Left && this._splitEdgeManipulator(e4), t2.stopPropagation();
  }
  _updateTranslateTooltip(t2, e4) {
    const i2 = this._manipulatorInfos.filter((t3) => "vertex" === t3.type && t3.manipulator.selected);
    1 === i2.length ? this._updateTranslateVertexTooltip(i2[0].manipulator, t2, e4) : this._updateTranslateGraphicTooltip(t2, e4);
  }
  _updateTranslateGraphicTooltip(t2, e4) {
    const { sketchOptions: i2, tooltip: a4 } = this;
    switch (t2) {
      case c$1.XY:
        this._latestTooltipInfo = this._translateGraphicTooltipInfo ??= new r$a({ sketchOptions: i2 }), this._updateTranslateTooltipDistance(this._latestTooltipInfo, e4, (t3, e5) => m$7(t3, e5));
        break;
      case c$1.XY_AXIS:
        this._latestTooltipInfo = this._translateGraphicXYTooltipInfo ??= new l$b({ sketchOptions: i2 }), this._updateTranslateTooltipDistance(this._latestTooltipInfo, e4, (t3, i3) => g$6(m$7(t3, i3), a$2(e4)));
        break;
      case c$1.Z:
        this._latestTooltipInfo = this._translateGraphicZTooltipInfo ??= new a$c({ sketchOptions: i2 }), this._updateTranslateTooltipDistance(this._latestTooltipInfo, e4, y$4);
    }
    this._latestTooltipInfo.sketchOptions = i2, a4.info = i2.tooltips.effectiveEnabled ? this._latestTooltipInfo : null;
  }
  _updateTranslateVertexTooltip(t2, e4, i2) {
    const { sketchOptions: a4, tooltip: n2 } = this;
    switch (e4) {
      case c$1.XY:
        this._latestTooltipInfo = this._translateVertexTooltipInfo ??= new p$9({ sketchOptions: a4 }), this._updateTranslateTooltipDistance(this._latestTooltipInfo, i2, (t3, e5) => m$7(t3, e5)), this._updateTooltipAreaOrTotalLength(this._latestTooltipInfo);
        break;
      case c$1.XY_AXIS:
        this._latestTooltipInfo = this._translateVertexXYTooltipInfo ??= new c$d({ sketchOptions: a4 }), this._updateTranslateTooltipDistance(this._latestTooltipInfo, i2, (t3, e5) => g$6(m$7(t3, e5), a$2(i2))), this._updateTooltipAreaOrTotalLength(this._latestTooltipInfo);
        break;
      case c$1.Z:
        this._latestTooltipInfo = this._translateVertexZTooltipInfo ??= new n$9({ sketchOptions: a4 }), this._updateTranslateTooltipDistance(this._latestTooltipInfo, i2, y$4);
    }
    const o2 = R$8(t2.location);
    this._latestTooltipInfo.elevation = null != o2 ? v$6({ actual: o2 }) : null, this._latestTooltipInfo.sketchOptions = a4, n2.info = a4.tooltips.effectiveEnabled ? this._latestTooltipInfo : null;
  }
  _updateTranslateTooltipDistance(t2, e4, i2) {
    if (null != e4 && "end" !== e4.action) {
      const { mapStart: a4, mapEnd: n2 } = e4, o2 = i2(a4, n2);
      t2.distance = null != o2 ? o2 : m$6;
    } else
      t2.distance = m$6;
  }
  _updateTooltipAreaOrTotalLength(t2) {
    const { geometry: e4 } = this.graphic;
    if (null == e4)
      return t2.area = null, void (t2.totalLength = null);
    t2.area = "polygon" === e4.type ? u$a(e4) : null, t2.totalLength = "polyline" === e4.type ? c$e(e4) : null;
  }
  _hideTooltip() {
    this.tooltip.clear(), this._latestTooltipInfo = null;
  }
  get test() {
    return { segmentLabels: this._segmentLabels, manipulatorInfos: this._manipulatorInfos };
  }
};
function Nt(t2, e4) {
  return Math.atan2(e4[1] - t2[1], e4[0] - t2[0]) + Math.PI / 2;
}
function Rt$1(t2, e4, i2, a4, n2) {
  if (t2) {
    const t3 = n2.toXYZ(n2.pointToVector(i2)), o2 = J$2(a4, t3, c$7.get()), s2 = u$b(o2, t3, n2.spatialReference);
    if (null != s2)
      return i$9(s2.value * Math.sign(e4), s2.unit);
  }
  return i$9(e4 * W$1(i2.spatialReference), "meters");
}
e$4([y$3()], Ct.prototype, "_editGeometryOperations", void 0), e$4([y$3()], Ct.prototype, "_segmentLabels", void 0), e$4([y$3({ constructOnly: true })], Ct.prototype, "tool", void 0), e$4([y$3()], Ct.prototype, "tooltip", void 0), e$4([y$3()], Ct.prototype, "inputGeometry", null), e$4([y$3()], Ct.prototype, "outputGeometry", void 0), e$4([y$3({ readOnly: true })], Ct.prototype, "updating", null), e$4([y$3()], Ct.prototype, "manipulators", null), e$4([y$3()], Ct.prototype, "view", null), e$4([y$3()], Ct.prototype, "graphic", null), e$4([y$3()], Ct.prototype, "enableZShape", null), e$4([y$3()], Ct.prototype, "enableZVertex", null), e$4([y$3()], Ct.prototype, "enableMoveGraphic", null), e$4([y$3()], Ct.prototype, "enableMidpoints", null), e$4([y$3()], Ct.prototype, "enableEdgeOffset", null), e$4([y$3()], Ct.prototype, "sketchOptions", null), e$4([y$3()], Ct.prototype, "_accentColor", null), Ct = e$4([c$6("esri.views.3d.interactive.editingTools.reshapeGraphic.ReshapeOperation")], Ct);
const Ft = e$7(0, 0, void 0, f$9.WGS84), zt = n$5(), Xt = 1e-6;
var Zt, Yt, qt;
!function(t2) {
  t2.Vertex = u$c.Custom1, t2.Edge = u$c.Custom2;
}(Zt || (Zt = {})), function(t2) {
  t2[t2.NONE = 0] = "NONE", t2[t2.MOVING = 1] = "MOVING", t2[t2.RESHAPING = 2] = "RESHAPING";
}(Yt || (Yt = {})), function(t2) {
  t2[t2.ALL = 0] = "ALL", t2[t2.SELECTED_OR_ALL = 1] = "SELECTED_OR_ALL";
}(qt || (qt = {}));
let y$1 = class y2 extends o$3.EventedMixin(l$9) {
  constructor(e4) {
    super(e4), this._internalGeometryUpdate = false, this.enableZShape = true, this.enableZVertex = true, this.enableMoveGraphic = true, this.enableMidpoints = true, this.enableEdgeOffset = false, this.type = "reshape-3d", this.sketchOptions = new l$a(), this.snappingManager = null, this.automaticManipulatorSelection = false;
  }
  initialize() {
    const e4 = this._reshapeOperation = new Ct({ tool: this });
    this.addHandles([e4.on("reshape", (e5) => {
      "reshape" === e5.type && this._onReshapeGeometryChanged(), this.emit("reshape", e5);
    }), e4.on("move", (e5) => {
      "move" === e5.type && this._onReshapeGeometryChanged(), this.emit("move", e5);
    }), e4.on("vertex-add", (e5) => {
      this._onReshapeGeometryChanged(), this.emit("vertex-add", e5);
    }), e4.on("vertex-remove", (e5) => {
      this._onReshapeGeometryChanged(), this.emit("vertex-remove", e5);
    }), e4.on("immediate-click", (e5) => this.emit("immediate-click", e5)), this.view.on("pointer-down", ["Shift"], (e5) => e5.stopPropagation()), d$3(() => this.graphic, () => this._updateGraphic(), A$7)]), this.finishToolCreation();
  }
  destroy() {
    this._reshapeOperation = u$8(this._reshapeOperation);
  }
  get updating() {
    return this._reshapeOperation?.updating ?? false;
  }
  _updateGeometry() {
    const e4 = l$c(this.graphic);
    this._reshapeOperation.inputGeometry = null != e4 ? e4.clone() : null;
  }
  _updateGraphic() {
    if (this.removeHandles("onGraphicGeometryChange"), this._updateGeometry(), n$a(this.graphic) !== P$7.SUPPORTED)
      return;
    const e4 = d$3(() => this.graphic?.geometry, () => {
      false === this._internalGeometryUpdate && this._updateGeometry();
    }, C$6);
    this.addHandles(e4, "onGraphicGeometryChange");
  }
  onManipulatorSelectionChanged() {
    this._reshapeOperation && this._reshapeOperation.onManipulatorSelectionChanged();
  }
  _updateGeometryInternally(e4) {
    this._internalGeometryUpdate = true;
    const { graphic: t2 } = this, { geometry: o2 } = t2;
    "mesh" === o2?.type && "point" === e4.type ? (t2.geometry = o2.centerAt(e4), t2.notifyGeometryChanged()) : t2.geometry = e4, this._internalGeometryUpdate = false;
  }
  _onReshapeGeometryChanged() {
    const { outputGeometry: e4 } = this._reshapeOperation;
    null != this.graphic && e4 && this._updateGeometryInternally(e4.clone());
  }
  get canUndo() {
    return this._reshapeOperation.canUndo ?? false;
  }
  undo() {
    null != this.snappingManager && this.snappingManager.doneSnapping();
    const e4 = this._reshapeOperation.undo(), { outputGeometry: t2 } = this._reshapeOperation;
    e4 && t2 && this._updateGeometryInternally(t2.clone());
  }
  get canRedo() {
    return this._reshapeOperation.canRedo ?? false;
  }
  redo() {
    null != this.snappingManager && this.snappingManager.doneSnapping();
    const e4 = this._reshapeOperation.redo(), { outputGeometry: t2 } = this._reshapeOperation;
    e4 && t2 && this._updateGeometryInternally(t2.clone());
  }
  onInputEvent(e4) {
    "key-down" !== e4.type || "Delete" !== e4.key && "Backspace" !== e4.key || this._reshapeOperation.removeSelectedVertices();
  }
  reset() {
  }
  get test() {
    return { snappingManager: this.snappingManager, reshapeOperation: this._reshapeOperation };
  }
};
e$4([y$3()], y$1.prototype, "_reshapeOperation", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], y$1.prototype, "view", void 0), e$4([y$3({ constructOnly: true })], y$1.prototype, "graphic", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], y$1.prototype, "enableZShape", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], y$1.prototype, "enableZVertex", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], y$1.prototype, "enableMoveGraphic", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], y$1.prototype, "enableMidpoints", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], y$1.prototype, "enableEdgeOffset", void 0), e$4([y$3()], y$1.prototype, "type", void 0), e$4([y$3({ constructOnly: true, type: l$a })], y$1.prototype, "sketchOptions", void 0), e$4([y$3({ constructOnly: true })], y$1.prototype, "snappingManager", void 0), e$4([y$3()], y$1.prototype, "updating", null), e$4([y$3()], y$1.prototype, "automaticManipulatorSelection", void 0), y$1 = e$4([c$6("esri.views.3d.interactive.editingTools.graphicReshape3D.GraphicReshapeTool")], y$1);
let r$1 = class r extends r$b {
  constructor(o2) {
    super(o2), this.type = "transform-rotate", this.rotation = null, this.rotationPrecision = null, this.orientation = null, this.orientationPrecision = null, this.rotationType = "geographic";
  }
};
e$4([y$3()], r$1.prototype, "type", void 0), e$4([y$3()], r$1.prototype, "rotation", void 0), e$4([y$3()], r$1.prototype, "rotationPrecision", void 0), e$4([y$3()], r$1.prototype, "orientation", void 0), e$4([y$3()], r$1.prototype, "orientationPrecision", void 0), e$4([y$3()], r$1.prototype, "rotationType", void 0), r$1 = e$4([c$6("esri.views.interactive.tooltip.TransformRotateTooltipInfo")], r$1);
let s = class extends r$b {
  constructor(o2) {
    super(o2), this.type = "transform-scale", this.size = null, this.sizeUnit = null, this.sizePrecision = null;
  }
};
e$4([y$3()], s.prototype, "type", void 0), e$4([y$3()], s.prototype, "scale", void 0), e$4([y$3()], s.prototype, "size", void 0), e$4([y$3()], s.prototype, "sizeUnit", void 0), e$4([y$3()], s.prototype, "sizePrecision", void 0), s = e$4([c$6("esri.views.interactive.tooltip.TransformScaleTooltipInfo")], s);
let p$1 = class p2 extends r$b {
  constructor(o2) {
    super(o2), this.type = "transform-absolute", this.orientation = null, this.orientationPrecision = null, this.rotationType = "geographic", this.size = null, this.sizePrecision = null, this.sizeUnit = null;
  }
};
e$4([y$3()], p$1.prototype, "type", void 0), e$4([y$3()], p$1.prototype, "orientation", void 0), e$4([y$3()], p$1.prototype, "orientationPrecision", void 0), e$4([y$3()], p$1.prototype, "rotationType", void 0), e$4([y$3()], p$1.prototype, "size", void 0), e$4([y$3()], p$1.prototype, "sizePrecision", void 0), e$4([y$3()], p$1.prototype, "sizeUnit", void 0), p$1 = e$4([c$6("esri.views.interactive.tooltip.TransformAbsoluteTooltipInfo")], p$1);
var yt;
!function(t2) {
  t2.ScaleIn = u$c.Custom2, t2.ScaleOut = u$c.Custom3, t2.RotateLeft = u$c.Custom4, t2.RotateRight = u$c.Custom5, t2.Unlocked = u$c.Custom7, t2.DelayedFocused = u$c.Custom8, t2.TouchInput = u$c.Custom12;
}(yt || (yt = {}));
let bt = class extends S$2 {
  get angle() {
    return this.adapter.angle;
  }
  get scale() {
    return this.adapter.scale;
  }
  set location(t2) {
    this._ringManipulator.location = t2;
  }
  set elevationAlignedLocation(t2) {
    this._ringManipulator.elevationAlignedLocation = t2;
  }
  get grabbing() {
    return this._ringManipulator.grabbing;
  }
  set interactive(t2) {
    this._ringManipulator.interactive = t2;
  }
  get updating() {
    return !!this._activeAnimation;
  }
  constructor(t2) {
    super(t2), this.mode = null, this._scaleRotateDragData = null, this._activeAnimation = null, this._ringIndicatorDelayMs = q$1, this._absoluteTooltipInfo = null, this._scaleTooltipInfo = null, this._rotateTooltipInfo = null, this.events = new o$3(), this.getFocused = () => this._ringManipulator.focused, this.getScale = () => "scale" === this._scaleRotateDragData?.mode ? this.adapter.scale : 1;
  }
  initialize() {
    this._tooltip = new u$9({ view: this.tool.view }), this._createManipulator(), this._updateDragState(), this._updateManipulatorTransform(), this.addHandles([p$7(() => !this.sketchOptions.tooltips.effectiveEnabled, () => this._tooltip.clear(), P$3), d$3(() => {
      const { adapter: t2 } = this, { info: e4 } = this._tooltip;
      return e4 === this._absoluteTooltipInfo && this.getFocused() ? [e4, t2.size, t2.orientationClockwise] : [null];
    }, ([t2]) => {
      t2 && this._updateFocusTooltip();
    })]);
  }
  destroy() {
    this._activeAnimation?.frameTask.remove(), this._activeAnimation = null, this.tool.manipulators.remove(this._ringManipulator), this._ringManipulator = null, this._tooltip = u$8(this._tooltip);
  }
  startAnimation(t2) {
    this.cancelActiveAnimation(), t2.start();
    const e4 = A$a({ update: ({ deltaTime: e5 }) => {
      t2.update(e5) && this.cancelActiveAnimation();
    } });
    this._activeAnimation = { ...t2, frameTask: e4 };
  }
  cancelActiveAnimation() {
    this._activeAnimation?.frameTask.remove(), this._activeAnimation = u$8(this._activeAnimation);
  }
  forEachManipulator(t2) {
    t2(this._ringManipulator, A$3.SCALE_ROTATE);
  }
  _createManipulator() {
    const t2 = this._createRingManipulator();
    this._ringManipulator = t2, this.tool.manipulators.add(t2);
    const e4 = this.tool.graphicState.graphic, a4 = x$5(t2, (t3, a5, o2) => {
      this._scaleRotateDragData = null;
      const n2 = this.adapter.startInteraction(), l2 = { mode: "none", origin: t$9(t3.renderLocation), initialAngle: this.adapter.angle, angle: 0, angleDir: 0, scaleDir: 0 };
      this._scaleRotateDragData = l2, this._updateDragState();
      const c2 = c$7.get();
      this.tool.view.renderCoordsHelper.worldUpAtPosition(t3.renderLocation, c2), a5.next(O$4(this.tool.view, j$4(t3.renderLocation, c2, E$4()))).next((t4) => {
        const a6 = F$2(t4.plane), o3 = b$5(t4.renderStart, t4.renderEnd, l2.origin, a6), c3 = r$c.shortestSignedDiff(l2.angle, o3);
        l2.angleDir = e$f(l2.angleDir + c3, -m$2, m$2), l2.angle = o3;
        const p4 = Tt(l2, t4), h3 = p4 - this.adapter.scale;
        if (l2.scaleDir = e$f(l2.scaleDir + h3, -k$1, k$1), this._onScaleChanged(), "none" === l2.mode) {
          const a7 = this.mode || wt(t4, t4.plane, l2.origin, this.tool.view.state.camera);
          if (null != a7) {
            switch (a7) {
              case "rotate":
                this.tool.emit("graphic-rotate-start", { graphic: e4, angle: 0 }), this.tool.emit("record-undo", { record: this.adapter.createUndoRecord() });
                break;
              case "scale":
                this.tool.emit("graphic-scale-start", { graphic: e4, xScale: 1, yScale: 1 }), this.tool.emit("record-undo", { record: this.adapter.createUndoRecord() });
            }
            l2.mode = a7;
          }
        }
        switch (l2.mode) {
          case "rotate":
            n2.state.angle = l2.initialAngle + o3;
            break;
          case "scale":
            n2.state.scale = p4, this._onScaleChanged();
        }
        switch (this._updateDragState(), this._updateManipulatorTransform(), t4.action) {
          case "start":
          case "update":
            switch (l2.mode) {
              case "rotate":
                this.tool.emit("graphic-rotate", { graphic: e4, angle: M$7(l2.angle) });
                break;
              case "scale":
                this.tool.emit("graphic-scale", { graphic: e4, xScale: p4, yScale: p4 });
            }
            break;
          case "end":
            switch (l2.mode) {
              case "rotate":
                this.tool.emit("graphic-rotate-stop", { graphic: e4, angle: M$7(l2.angle) });
                break;
              case "scale":
                this.tool.emit("graphic-scale-stop", { graphic: e4, xScale: p4, yScale: p4 });
            }
        }
        return "end" === t4.action && (this.startAnimation(It(this, () => this._onScaleChanged())), this._scaleRotateDragData = null, this._updateDragState(), n2.done()), t4;
      }).next(this._updateTooltipPipelineStep(l2)), o2.next(() => {
        if (n2.cancel(), null != this._scaleRotateDragData) {
          switch (this._scaleRotateDragData.mode) {
            case "none":
              break;
            case "rotate":
              this.tool.emit("graphic-rotate-stop", { graphic: e4, angle: 0 });
              break;
            case "scale":
              this.tool.emit("graphic-scale-stop", { graphic: e4, xScale: 1, yScale: 1 });
          }
          this.startAnimation(It(this, () => this._onScaleChanged())), this._scaleRotateDragData = null, this._updateDragState();
        }
        this._updateFocusTooltip();
      });
    });
    this.addHandles([a4, t2.events.on("focus-changed", (t3) => {
      "focus" === t3.action ? this.startAnimation(kt(this, () => this._updateDelayedFocusedState(), { delayMs: this._ringIndicatorDelayMs })) : this._updateDelayedFocusedState();
    }), t2.events.on("immediate-click", (t3) => {
      t3.stopPropagation();
    }), d$3(() => this.tool.graphicState?.displaying, (t3) => this._ringManipulator.available = t3, P$3)]);
  }
  _updateTooltipPipelineStep(t2) {
    return (e4) => {
      const { sketchOptions: a4 } = this, { effectiveEnabled: i2, visualVariables: o2 } = a4.tooltips;
      if (!i2)
        return e4;
      if ("end" === e4.action)
        return this._updateFocusTooltip(), e4;
      const s$12 = this._tooltip;
      switch (t2.mode) {
        case "scale": {
          s$12.info = this._scaleTooltipInfo ??= new s({ sketchOptions: a4 });
          const { size: t3, scale: e5 } = this.adapter, i3 = o2?.size, r3 = s$12.info;
          r3.sketchOptions = a4, r3.scale = { value: e5 }, r3.size = null != t3 ? i$9(t3, "meters") : void 0, r3.sizePrecision = Ot(i3?.valueType), r3.sizeUnit = i3?.unit;
          break;
        }
        case "rotate": {
          s$12.info = this._rotateTooltipInfo ??= new r$1({ sketchOptions: a4 });
          const { orientationClockwise: t3, relativeAngleClockwise: e5 } = this.adapter, i3 = o2?.rotation, r3 = Ot(i3?.valueType), n2 = s$12.info;
          n2.sketchOptions = a4, n2.rotation = null != e5 ? l$d(e5, "radians", "geographic") : void 0, n2.rotationPrecision = r3, n2.rotationType = i3?.rotationType ?? "geographic", n2.orientation = null != t3 ? l$d(t3, "radians", "geographic") : void 0, n2.orientationPrecision = r3;
          break;
        }
      }
      return e4;
    };
  }
  _updateFocusTooltip() {
    const { sketchOptions: t2, _tooltip: e4 } = this, { effectiveEnabled: a4, visualVariables: i2 } = t2.tooltips;
    if (!a4)
      return;
    if (this.getFocused()) {
      const a5 = i2?.rotation, o2 = i2?.size, s2 = this.mode, { size: r3, orientationClockwise: n2 } = this.adapter, p4 = null != n2 && (null == s2 || "rotate" === s2), h3 = null != r3 && (null == s2 || "scale" === s2);
      e4.info = this._absoluteTooltipInfo ??= new p$1({ sketchOptions: t2 });
      const u2 = e4.info;
      u2.sketchOptions = t2, u2.orientation = p4 ? l$d(n2, "radians", "geographic") : void 0, u2.orientationPrecision = Ot(a5?.valueType), u2.rotationType = a5?.rotationType ?? "geographic", u2.size = h3 ? i$9(r3, "meters") : void 0, u2.sizeUnit = o2?.unit, u2.sizePrecision = Ot(o2?.valueType);
    } else
      e4.clear();
  }
  _onScaleChanged() {
    this.events.emit("scale-changed"), this._updateManipulatorTransform();
  }
  _updateDelayedFocusedState() {
    this._ringManipulator.updateStateEnabled(yt.DelayedFocused, this.getFocused()), this._updateFocusTooltip();
  }
  _updateDragState() {
    if (this._ringManipulator.updateStateEnabled(yt.Unlocked, !(null != this._scaleRotateDragData && "none" !== this._scaleRotateDragData?.mode)), null != this._scaleRotateDragData)
      switch (this._scaleRotateDragData.mode) {
        case "rotate":
          this._ringManipulator.updateStateEnabled(yt.ScaleIn | yt.ScaleOut, false), this._ringManipulator.updateStateEnabled(yt.RotateLeft, this._scaleRotateDragData.angleDir < 0), this._ringManipulator.updateStateEnabled(yt.RotateRight, this._scaleRotateDragData.angleDir >= 0);
          break;
        case "scale":
          this._ringManipulator.updateStateEnabled(yt.RotateLeft | yt.RotateRight, false), this._ringManipulator.updateStateEnabled(yt.ScaleIn, this._scaleRotateDragData.scaleDir < 0), this._ringManipulator.updateStateEnabled(yt.ScaleOut, this._scaleRotateDragData.scaleDir >= 0);
      }
    else
      this._ringManipulator.updateStateEnabled(yt.ScaleIn | yt.ScaleOut | yt.RotateLeft | yt.RotateRight, false);
  }
  _updateManipulatorTransform() {
    const t2 = p$8(f$5.get(), this.adapter.angle, r$9(0, 0, 1));
    if (null == t2)
      return;
    const e4 = this.getScale(), a4 = d$5(f$5.get(), o$4(c$7.get(), e4, e4, e4));
    this._ringManipulator.modelTransform = c$c(f$5.get(), a4, t2);
  }
  _createRingManipulator() {
    const t2 = (t3, e5, a5) => {
      const i3 = [], o3 = Math.ceil(t$1 * (e5 - t3) / (2 * Math.PI));
      for (let s3 = 0; s3 < o3 + 1; s3++) {
        const r4 = t3 + s3 * (e5 - t3) / o3;
        i3.push(r$9(a5 * Math.cos(r4), a5 * Math.sin(r4), 0));
      }
      return i3;
    }, e4 = (e5) => t2(0, 2 * Math.PI, e5), a4 = (t3) => [[-t3 / 2, 0], [t3 / 2, 0], [t3 / 2, P / 2], [-t3 / 2, P / 2]], i2 = this._createMaterial(1), o2 = (t3, e5, o3 = i2) => it(o3, a4(e5), t3, [], [], false), s2 = e4(I), r3 = o2(s2, i$1), n2 = { left: new Array(), right: new Array() }, l2 = [];
    for (let j2 = 0; j2 < 2; j2++) {
      const e5 = j2 * Math.PI - Math.PI / 4, a5 = Math.PI / 2 - x$2, s3 = e5 + a5, r4 = e5 + Math.PI / 2 - a5, c3 = t2(s3, r4, n$2), p5 = o2(c3, l$1);
      l2.push(c3), l2.push(t2(s3, r4, p$3 - i$1 / 2)), n2.left.push(p5), n2.right.push(p5.instantiate());
      for (let t3 = 0; t3 < 2; t3++) {
        const e6 = 0 === t3, a6 = e$d();
        if (e6) {
          f$6(a6, a6, [1, -1, 1]), b$4(a6, a6, -s3, [0, 0, 1]);
          const t4 = Math.round(f2 * (c3.length - 1));
          a6[12] = c3[t4][0], a6[13] = c3[t4][1], a6[14] = c3[t4][2];
        } else {
          b$4(a6, a6, r4, [0, 0, 1]);
          const t4 = Math.round((1 - f2) * (c3.length - 1));
          a6[12] = c3[t4][0], a6[13] = c3[t4][1], a6[14] = c3[t4][2];
        }
        const o3 = wt$1(i2, r$2, 0, s$1, P);
        mt(o3, a6), (e6 ? n2.left : n2.right).push(o3);
      }
    }
    const c2 = [];
    for (let S3 = 0; S3 < 2; S3++) {
      const e5 = S3 * Math.PI - Math.PI / 4, a5 = Math.PI / 2 - b2, i3 = e5 + a5, s3 = e5 + Math.PI / 2 - a5, r4 = t2(i3, s3, p$3);
      c2.push(o2(r4, l$1));
    }
    const p4 = this._createMaterial(0.66), h3 = this._createMaterial(0.5), u2 = this._createMaterial(0.33), d2 = e4(I + g$2), g3 = e4(I + j$2), m3 = o2(d2, l$1, p4), f$12 = o2(g3, l$1, u2), _2 = e4(I - g$2), v2 = e4(I - j$2), D2 = o2(_2, l$1, p4), b$12 = o2(v2, l$1, u2);
    let T2 = [new e$b(r3, yt.DelayedFocused), new e$b(r3.instantiate({ material: h3 }), t$6.None)];
    this.mode && "scale" !== this.mode || (T2 = T2.concat([...c2.map((t3) => new e$b(t3, yt.DelayedFocused | yt.Unlocked)), new e$b(m3, yt.DelayedFocused | yt.ScaleIn), new e$b(f$12, yt.DelayedFocused | yt.ScaleIn), new e$b(D2, yt.DelayedFocused | yt.ScaleOut), new e$b(b$12, yt.DelayedFocused | yt.ScaleOut)])), this.mode && "rotate" !== this.mode || (T2 = T2.concat([...n2.right.map((t3) => new e$b(t3.instantiate(), yt.DelayedFocused | yt.Unlocked)), ...n2.left.map((t3) => new e$b(t3, yt.DelayedFocused | yt.RotateLeft)), ...n2.right.map((t3) => new e$b(t3, yt.DelayedFocused | yt.RotateRight))]));
    const w4 = [s2, ...l2];
    return new ee({ view: this.tool.view, renderObjects: T2, autoScaleRenderObjects: false, worldOriented: true, radius: i$1, focusMultiplier: 1, touchMultiplier: 1.5, elevationInfo: a$b(this.tool.graphicState.graphic), collisionType: { type: "ribbon", paths: w4, direction: r$9(0, 0, 1) } });
  }
  _createMaterial(t2) {
    const e4 = new _$2({ cullFace: e$c.Back, renderOccluded: h$7.Transparent, isDecoration: true });
    return this.addHandles(d$3(() => ({ color: F$3(this.tool.view.effectiveTheme.accentColor, t2) }), (t3) => e4.setParameters(t3), P$3)), e4;
  }
  get test() {
    return { ringManipulator: this._ringManipulator, setRingIndicatorDelayMs: (t2) => this._ringIndicatorDelayMs = t2, tooltip: this._tooltip };
  }
};
function Tt(t2, e4) {
  const a4 = e$e(c$7.get(), e4.renderStart, t2.origin), i2 = e$e(c$7.get(), e4.renderEnd, t2.origin), o2 = s$3(a4), s2 = s$3(i2);
  return 0 === o2 ? 0 : s2 / o2;
}
function wt(t2, e4, a4, i2) {
  const { renderStart: o2, renderEnd: s2 } = t2, r3 = jt(o2, i2, c$7.get()), n2 = jt(s2, i2, c$7.get());
  if (p$a(r3, n2) < d * d)
    return null;
  const l2 = e$e(c$7.get(), o2, a4), c2 = _$3(c$7.get(), l2, F$2(e4)), p4 = o2, h3 = u$6(c$7.get(), p4, c2), u2 = jt(a4, i2, c$7.get()), d$12 = r3, g3 = jt(h3, i2, c$7.get()), m3 = e$e(c$7.get(), g3, d$12), f3 = e$e(c$7.get(), r3, u2), _2 = p$b(d$12, m3), v2 = p$b(u2, f3);
  return v$7(_2, n2) < v$7(v2, n2) ? "rotate" : "scale";
}
function jt(t2, e4, a4) {
  return e4.projectToScreen(t2, At), o$4(a4, At[0], At[1], 0);
}
var Rt;
function It(t2, e4) {
  let a4 = null, i2 = 1;
  const o2 = () => i2;
  return { start: () => {
    i2 = t2.getScale(), a4 = t2.getScale, t2.getScale = o2, e4();
  }, update: (t3) => (i2 += ((i2 + 1) / 2 - i2) * Math.min(t3 * u$1, 1), e4(), Math.abs(i2 - 1) < 0.01 ? Rt.STOP : Rt.CONTINUE), destroy: () => {
    a4 && (t2.getScale = a4), e4();
  } };
}
function kt(t2, e4, a4) {
  let i2 = 0, o2 = null;
  const s2 = () => false;
  return { start: () => {
    o2 = t2.getFocused, t2.getFocused = s2, i2 = 0, e4();
  }, update: (t3) => (i2 += t3, !o2?.() || i2 >= a4.delayMs ? Rt.STOP : Rt.CONTINUE), destroy: () => {
    o2 && (t2.getFocused = o2), e4();
  } };
}
function Ot(t2) {
  switch (t2) {
    case "integer":
    case "long":
      return 0;
    default:
      return null;
  }
}
e$4([y$3({ constructOnly: true })], bt.prototype, "tool", void 0), e$4([y$3({ constructOnly: true })], bt.prototype, "adapter", void 0), e$4([y$3({ constructOnly: true })], bt.prototype, "sketchOptions", void 0), e$4([y$3()], bt.prototype, "mode", void 0), e$4([y$3()], bt.prototype, "_activeAnimation", void 0), e$4([y$3()], bt.prototype, "updating", null), bt = e$4([c$6("esri.views.3d.interactive.editingTools.transformGraphic.GraphicScaleRotateTransform")], bt), function(t2) {
  t2[t2.CONTINUE = 0] = "CONTINUE", t2[t2.STOP = 1] = "STOP";
}(Rt || (Rt = {}));
const At = i$4();
function r2(e4) {
  return null != e4.geometry && "mesh" === e4.geometry.type ? o(e4.geometry) : n(e4);
}
function o(e4) {
  return g$4(e4.vertexSpace) ? i(e4, e4.transform, e4.vertexSpace) : m2(e4);
}
function n(e4) {
  let t2 = e4.geometry, r3 = null;
  return { undo(e5) {
    r3 = e5.geometry, e5.geometry = t2;
  }, redo(e5) {
    t2 = e5.geometry, e5.geometry = r3;
  } };
}
function i(t2, r3, o2) {
  let n2 = r3?.clone(), i2 = t$9(o2.origin), m3 = null, s2 = null;
  return { undo: (r4) => {
    m3 = t2.transform?.clone(), s2 = t$9(o2.origin), t2.transform = n2, t2.vertexSpace.origin = i2, r4.notifyMeshTransformChanged();
  }, redo: (r4) => {
    n2 = t2.transform?.clone(), i2 = t$9(o2.origin), t2.transform = m3, t2.vertexSpace.origin = s2, r4.notifyMeshTransformChanged();
  } };
}
function m2(e4) {
  let t2, r3 = e4.vertexAttributes.clonePositional();
  return { undo: (o2) => {
    t2 = e4.vertexAttributes.clonePositional(), e4.vertexAttributes = r3, o2.notifyGeometryChanged();
  }, redo: (o2) => {
    r3 = e4.vertexAttributes.clonePositional(), e4.vertexAttributes = t2, o2.notifyGeometryChanged();
  } };
}
let g2 = class extends S$2 {
  constructor(t2) {
    super(t2), this._interactionState = null;
  }
  initialize() {
    this.addHandles([p$7(() => {
      const t2 = this._interactionState;
      return t2 && t2.angle !== t2.previousAngle ? { interactionState: t2, angle: t2.state.angle } : null;
    }, ({ interactionState: t2 }) => {
      this._updateMeshRotation(t2);
    }, C$6), p$7(() => {
      const t2 = this._interactionState;
      return t2 && t2.scale !== t2.previousScale ? { interactionState: t2, scale: t2.state.scale } : null;
    }, ({ interactionState: t2 }) => {
      this._updateMeshSize(t2);
    }, C$6)]);
  }
  get initialAngle() {
    return this._interactionState?.initialAngle ?? 0;
  }
  get angle() {
    const t2 = this.geometry.transform;
    if (null == t2)
      return this._interactionState?.angle ?? 0;
    const e4 = y$7(t2.rotation)[2];
    return Math.abs(e4) > 0.999999 ? h$5(z$4(t2.rotation)) * Math.sign(e4) : 0;
  }
  get angleClockwise() {
    return -this.angle;
  }
  get relativeAngle() {
    return this.angle - this.initialAngle;
  }
  get relativeAngleClockwise() {
    return -this.relativeAngle;
  }
  get scale() {
    return this._interactionState?.scale ?? 1;
  }
  startInteraction() {
    const t2 = new h$1({ angle: this.angle });
    this._interactionState = t2;
    const e4 = () => {
      this._interactionState = null;
    };
    return { state: t2, done: e4, cancel: () => {
      t2.cancel(), e4();
    } };
  }
  createUndoRecord() {
    return r2(this.graphic);
  }
  _updateMeshRotation(t2) {
    const { angle: e4, previousAngle: i2 } = t2;
    t2.previousAngle = e4;
    const r3 = M$7(e4 - i2), { geometry: n2 } = this, s2 = n2.anchor;
    n2.rotate(0, 0, r3, { origin: s2 }), n2.transform && n2.vertexSpace.origin ? this.graphic.notifyMeshTransformChanged() : this.graphic.notifyGeometryChanged();
  }
  _updateMeshSize(t2) {
    const { scale: e4, previousScale: i2 } = t2;
    t2.previousScale = e4;
    const { geometry: o2 } = this, r3 = e4 / i2, n2 = this.geometry.anchor;
    this.geometry.scale(r3, { origin: n2 }), o2.transform && o2.vertexSpace.origin ? this.graphic.notifyMeshTransformChanged() : this.graphic.notifyGeometryChanged();
  }
};
e$4([y$3({ constructOnly: true })], g2.prototype, "graphic", void 0), e$4([y$3({ constructOnly: true })], g2.prototype, "geometry", void 0), e$4([y$3({ constructOnly: true })], g2.prototype, "viewingMode", void 0), e$4([y$3()], g2.prototype, "initialAngle", null), e$4([y$3()], g2.prototype, "angle", null), e$4([y$3()], g2.prototype, "angleClockwise", null), e$4([y$3()], g2.prototype, "relativeAngle", null), e$4([y$3()], g2.prototype, "relativeAngleClockwise", null), e$4([y$3()], g2.prototype, "scale", null), e$4([y$3()], g2.prototype, "_interactionState", void 0), g2 = e$4([c$6("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateMeshAdapter")], g2);
let h$1 = class h extends S$2 {
  get state() {
    const { angle: t2, scale: e4 } = this;
    return { angle: t2, scale: e4 };
  }
  constructor(t2) {
    super(t2), this.angle = 0, this.initialAngle = 0, this.previousAngle = 0, this.previousScale = 1, this.scale = 1, this.initialAngle = t2.angle, this.previousAngle = t2.angle;
  }
  cancel() {
    this.angle = this.initialAngle, this.scale = 1;
  }
};
e$4([y$3()], h$1.prototype, "angle", void 0), e$4([y$3()], h$1.prototype, "initialAngle", void 0), e$4([y$3()], h$1.prototype, "previousAngle", void 0), e$4([y$3()], h$1.prototype, "previousScale", void 0), e$4([y$3()], h$1.prototype, "scale", void 0), e$4([y$3()], h$1.prototype, "state", null), h$1 = e$4([c$6("InteractionState")], h$1);
let a3 = class extends S$2 {
  constructor(t2) {
    super(t2), this.sizeAxis = null, this._interactionState = null;
  }
  initialize() {
    this.addHandles(p$7(() => null != this._interactionState ? this._interactionState.state : null, (t2) => {
      this._updateSymbol(t2);
    }, C$6));
  }
  get initialAngle() {
    return this._interactionState?.initialAngle ?? 0;
  }
  get angle() {
    return null != this._interactionState ? this._interactionState.angle : null != this._orientationReferenceSymbolLayer ? c(this._orientationReferenceSymbolLayer.heading ?? 0) : 0;
  }
  get angleClockwise() {
    return -this.angle;
  }
  get orientation() {
    return this.angle;
  }
  get orientationClockwise() {
    return this.angleClockwise;
  }
  get relativeAngle() {
    return this.angle - this.initialAngle;
  }
  get relativeAngleClockwise() {
    return -this.relativeAngle;
  }
  get scale() {
    return this._interactionState?.scale ?? 1;
  }
  get size() {
    const t2 = this._sizeReferenceSymbolLayer;
    if (null == t2)
      return null;
    const e4 = this.findLayerView(), i2 = this._graphicSymbol;
    if (null == e4 || null == i2 || "point-3d" !== i2.type)
      return null;
    const l2 = e4.getSymbolLayerSize(i2, t2);
    if ("size" in l2 && null != l2.size)
      return l2.size;
    const n2 = this.sizeAxis;
    return !("width" in l2) || null == l2.width || null != n2 && "width" !== n2 && "all" !== n2 && "width-and-depth" !== n2 ? !("depth" in l2) || null == t2.depth || null != n2 && "depth" !== n2 && "all" !== n2 && "width-and-depth" !== n2 ? !("height" in l2) || null == t2.height || null != n2 && "height" !== n2 && "all" !== n2 ? null : l2.height : l2.depth : l2.width;
  }
  get _sizeReferenceSymbolLayer() {
    const t2 = this._graphicSymbol;
    return null == t2 || 0 === t2.symbolLayers.length ? null : t2.symbolLayers.find((t3) => "object" === t3.type);
  }
  get _orientationReferenceSymbolLayer() {
    const t2 = this._graphicSymbol;
    return null == t2 || 0 === t2.symbolLayers.length ? null : t2.symbolLayers.find((t3) => "object" === t3.type && null != t3.heading);
  }
  get _graphicSymbol() {
    return null != this.graphic?.symbol && "point-3d" === this.graphic.symbol.type ? this.graphic.symbol : null;
  }
  set _graphicSymbol(t2) {
    this.graphic.symbol = t2;
  }
  startInteraction() {
    const t2 = this._graphicSymbol, e4 = this.findLayerView();
    if (null != this._interactionState || null == t2 || null == e4)
      return h2;
    const i2 = t2.symbolLayers.map((i3) => "object" === i3.type ? e4.getSymbolLayerSize(t2, i3) : null).toArray(), l2 = t2.clone(), n2 = this.angle, o2 = new p3({ originalSymbol: l2, angle: n2, initialSizes: i2 });
    this._interactionState = o2;
    const r3 = () => {
      this._interactionState = null;
    };
    return { state: o2, done: r3, cancel: () => {
      this._graphicSymbol = l2, r3();
    } };
  }
  createUndoRecord() {
    let t2 = this.graphic.symbol, e4 = null;
    return { undo: (i2) => {
      e4 = i2.symbol, i2.symbol = t2;
    }, redo: (i2) => {
      t2 = i2.symbol, i2.symbol = e4;
    } };
  }
  _updateSymbol({ scale: t2, angle: e4, originalSymbol: l2, initialSizes: n2 }) {
    const o2 = this._graphicSymbol;
    if (null == o2 || "point-3d" !== o2.type)
      return;
    const r3 = o2.clone(), s2 = -M$7(e4 - this.initialAngle);
    let a4 = false;
    this._forEachObjectSymbolLayerPair(l2, r3, (e5, i2, l3) => {
      const o3 = (e5.heading ?? 0) + s2;
      i2.heading !== o3 && (i2.heading = o3, a4 = true);
      const r4 = n2[l3];
      if (null != r4 && "width" in r4) {
        r4.width = this.sizeFilter(r4.width), r4.height = this.sizeFilter(r4.height), r4.depth = this.sizeFilter(r4.depth);
        const e6 = r4.width * t2;
        i2.width !== e6 && (i2.width = e6, a4 = true);
        const l4 = r4.depth * t2;
        i2.depth !== l4 && (i2.depth = l4, a4 = true);
        const n3 = r4.height * t2;
        i2.height !== n3 && (i2.height = n3, a4 = true);
      }
    }), a4 && (this._graphicSymbol = r3);
  }
  _forEachObjectSymbolLayerPair(t2, e4, i2) {
    t2.symbolLayers.forEach((t3, l2) => {
      const n2 = e4.symbolLayers.at(l2);
      "object" === t3.type && "object" === n2.type && i2(t3, n2, l2);
    });
  }
};
function c(t2) {
  return -h$5(t2);
}
e$4([y$3()], a3.prototype, "initialAngle", null), e$4([y$3()], a3.prototype, "angle", null), e$4([y$3()], a3.prototype, "angleClockwise", null), e$4([y$3()], a3.prototype, "orientation", null), e$4([y$3()], a3.prototype, "orientationClockwise", null), e$4([y$3()], a3.prototype, "relativeAngle", null), e$4([y$3()], a3.prototype, "relativeAngleClockwise", null), e$4([y$3()], a3.prototype, "scale", null), e$4([y$3()], a3.prototype, "size", null), e$4([y$3()], a3.prototype, "sizeAxis", void 0), e$4([y$3({ constructOnly: true })], a3.prototype, "graphic", void 0), e$4([y$3()], a3.prototype, "_interactionState", void 0), e$4([y$3({ constructOnly: true })], a3.prototype, "findLayerView", void 0), e$4([y$3({ constructOnly: true })], a3.prototype, "sizeFilter", void 0), e$4([y$3()], a3.prototype, "_sizeReferenceSymbolLayer", null), e$4([y$3()], a3.prototype, "_orientationReferenceSymbolLayer", null), e$4([y$3()], a3.prototype, "_graphicSymbol", null), a3 = e$4([c$6("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateObjectSymbol3DAdapter")], a3);
const h2 = { state: { angle: 0, scale: 0 }, done: () => {
}, cancel: () => {
} };
let p3 = class extends S$2 {
  get state() {
    const { originalSymbol: t2, angle: e4, initialAngle: i2, scale: l2, initialSizes: n2 } = this;
    return { originalSymbol: t2, angle: e4, initialAngle: i2, scale: l2, initialSizes: n2 };
  }
  constructor(t2) {
    super(t2), this.angle = 0, this.initialAngle = 0, this.scale = 1, this.initialAngle = t2.angle;
  }
};
e$4([y$3()], p3.prototype, "originalSymbol", void 0), e$4([y$3()], p3.prototype, "angle", void 0), e$4([y$3()], p3.prototype, "initialAngle", void 0), e$4([y$3()], p3.prototype, "initialSizes", void 0), e$4([y$3()], p3.prototype, "scale", void 0), e$4([y$3()], p3.prototype, "state", null), p3 = e$4([c$6("InteractionState")], p3);
let Y = class extends o$3.EventedMixin(l$9) {
  constructor(t2) {
    super(t2), this.enableZ = true, this.enableRotation = true, this.enableScaling = true, this.sketchOptions = new l$a(), this.type = "transform-3d", this.tooltip = null, this._updatingHandles = new h$b(), this._scaleRotate = null, this._translateGraphicTooltipInfo = null, this._translateGraphicXYTooltipInfo = null, this._translateGraphicZTooltipInfo = null;
  }
  initialize() {
    const { graphic: t2, view: i2 } = this;
    this.graphicState = new e$3({ graphic: t2 }), this.addHandles(d$3(() => this.sketchOptions.tooltips.effectiveEnabled, (t3) => {
      this.tooltip = t3 ? new u$9({ view: i2 }) : u$8(this.tooltip);
    }, A$7)), this._moveManipulation = new u({ tool: this, view: i2, snapToScene: this.snapToScene, xyAvailable: true, xyAxisAvailable: true, zAvailable: this.enableZ && n$8(t2), radius: u.radiusForSymbol(t2.symbol) }), this._moveManipulation.forEachManipulator((e4) => this.addHandles(e4.events.on("immediate-click", (e5) => {
      this.emit("immediate-click", { ...e5, graphic: t2 }), e5.stopPropagation();
    })));
    const s2 = (t3) => (e4) => {
      this.addHandles(e4.events.on("focus-changed", ({ action: e5 }) => {
        const i3 = this.tooltip;
        null != i3 && ("focus" === e5 ? this._updateMoveTooltip(t3) : i3.clear());
      }));
    };
    this._moveManipulation.xyManipulation.forEachManipulator(s2(c$1.XY)), this._moveManipulation.xyAxisManipulation.forEachManipulator(s2(c$1.XY_AXIS)), this._moveManipulation.zManipulation.forEachManipulator(s2(c$1.Z));
    const n2 = a$b(t2);
    this._moveManipulation.elevationInfo = n2, this.addHandles(a$6(this.graphicState, i2));
    const { geometry: p4 } = t2;
    if (this._moveManipulation.createGraphicDragPipeline((e4, a4, o2, s3, r3) => {
      if (null != p4 && e4 === c$1.XY) {
        const { snappingStep: e5, cancelSnapping: a5 } = f$7({ snappingContext: new e$g({ elevationInfo: n2, pointer: r3, editGeometryOperations: V$4.fromGeometry(new x$7({ spatialReference: p4.spatialReference }), i2.state.viewingMode), visualizer: new O$2(), excludeFeature: t2 }), snappingManager: this.snappingManager, updatingHandles: this._updatingHandles, useZ: false });
        s3 = s3.next(a5), o2 = o2.next(A$b(this.view, n2)).next(...e5);
      }
      return { steps: o2 = o2.next((t3) => (this._updateMoveTooltip(e4, t3), t3)), cancel: s3 };
    }, this.graphicState, (t3) => {
      const { action: e4, graphic: i3, dxScreen: a4, dyScreen: o2 } = t3, s3 = { graphic: i3, dxScreen: a4, dyScreen: o2 };
      switch (e4) {
        case "start":
          this.emit("graphic-translate-start", s3), this.emit("record-undo", { record: this._createGeometryUndoRecord() });
          break;
        case "update":
          this.emit("graphic-translate", s3);
          break;
        case "end":
          this.emit("graphic-translate-stop", s3);
      }
    }), this._moveManipulation.angle = null != this._scaleRotate ? this._scaleRotate.angle : 0, this._scaleRotateAdapter = this._createScaleRotateAdapter(), this.addHandles(d$3(() => this._scaleRotateAdapter.angle, () => this._updateMoveAngle())), this.enableScaling || this.enableRotation) {
      const t3 = this.enableScaling && this.enableRotation ? null : this.enableScaling ? "scale" : "rotate";
      this._scaleRotate = new bt({ tool: this, mode: t3, adapter: this._scaleRotateAdapter, sketchOptions: this.sketchOptions }), this.addHandles(this._scaleRotate.events.on("scale-changed", () => this._onScaleChanged()));
    }
    this.addHandles([i$2({ view: this.view, graphic: this.graphic, forEachManipulator: (t3) => this._forEachManipulator(t3), onManipulatorsChanged: () => e$5() }), this.graphicState.on("changed", () => this._onGeometryChanged()), this._hideManipulatorsForGraphicState(), d$3(() => i2.scale, () => this._updateMoveAngle())].filter(q$7)), this.addHandles(this.view.trackGraphicState(this.graphicState)), this._onGeometryChanged(), this._updateMoveAngle(), this._forEachManipulator((t3) => {
      t3 instanceof ee && this.addHandles(t3.events.on("grab-changed", () => this._updateManipulatorsInteractive()));
    }), this.finishToolCreation();
  }
  destroy() {
    this.tooltip = u$8(this.tooltip), this._moveManipulation.destroy(), this._scaleRotate = u$8(this._scaleRotate), this._scaleRotateAdapter = u$8(this._scaleRotateAdapter), this._updatingHandles.destroy(), this._set("view", null), this._set("graphic", null);
  }
  _updateManipulatorsInteractive() {
    null != this._scaleRotate && (this._scaleRotate.interactive = !this._moveManipulation.grabbing, this._moveManipulation.interactive = !this._scaleRotate.grabbing);
  }
  _createScaleRotateAdapter() {
    return null != this.graphic.geometry && "mesh" === this.graphic.geometry.type ? new g2({ graphic: this.graphic, geometry: this.graphic.geometry, viewingMode: this.view.state.viewingMode }) : new a3({ graphic: this.graphic, sizeFilter: (t2) => this._enforceNonZeroSize(t2), findLayerView: () => this.view.allLayerViews.find((t2) => t2.layer === this.graphic.layer), sizeAxis: this.sketchOptions?.tooltips?.visualVariables?.size?.axis ?? null });
  }
  _forEachManipulator(t2) {
    this._moveManipulation?.forEachManipulator(t2), this._scaleRotate?.forEachManipulator(t2);
  }
  _hideManipulatorsForGraphicState() {
    return d$3(() => this.graphicState.displaying, (t2) => {
      this._forEachManipulator((e4) => e4.available = t2), this._moveManipulation.zManipulation.available = t2 && this.enableZ && n$8(this.graphic);
    });
  }
  _createGeometryUndoRecord() {
    return r2(this.graphic);
  }
  set snapToScene(t2) {
    this._moveManipulation && (this._moveManipulation.snapToScene = t2), this._set("snapToScene", t2);
  }
  get updating() {
    return this._updatingHandles.updating || !!this._scaleRotate?.updating;
  }
  set location(t2) {
    this._moveManipulation.location = t2, this._scaleRotate && (this._scaleRotate.location = t2);
  }
  set elevationAlignedLocation(t2) {
    this._moveManipulation.elevationAlignedLocation = t2, this._scaleRotate && (this._scaleRotate.elevationAlignedLocation = t2);
  }
  reset() {
  }
  onHide() {
    this._scaleRotate?.cancelActiveAnimation();
  }
  _onScaleChanged() {
    null != this._scaleRotate && (this._moveManipulation.displayScale = this._scaleRotate.getScale());
  }
  _updateMoveAngle() {
    this.view.state.viewingMode === l$4.Local || this.view.scale < v ? this._moveManipulation.angle = this._scaleRotateAdapter.angle : this._moveManipulation.angle = 0;
  }
  _onGeometryChanged() {
    y$6(this.view, this, this.graphic);
  }
  _enforceNonZeroSize(t2) {
    return t2 || this.view.state.camera.computeRenderPixelSizeAt(this._moveManipulation.renderLocation);
  }
  _updateMoveTooltip(t2, e4) {
    const { sketchOptions: i2, tooltip: a4 } = this;
    if (null != a4) {
      switch (a4.clear(), t2) {
        case c$1.XY:
          a4.info = this._translateGraphicTooltipInfo ??= new r$a({ sketchOptions: i2 }), this._updateMoveTooltipDistance(a4.info, e4, (t3, e5) => m$7(t3, e5));
          break;
        case c$1.XY_AXIS:
          a4.info = this._translateGraphicXYTooltipInfo ??= new l$b({ sketchOptions: i2 }), this._updateMoveTooltipDistance(a4.info, e4, (t3, i3) => g$6(m$7(t3, i3), a$2(e4)));
          break;
        case c$1.Z:
          a4.info = this._translateGraphicZTooltipInfo ??= new a$c({ sketchOptions: i2 }), this._updateMoveTooltipDistance(a4.info, e4, y$4);
      }
      a4.info.sketchOptions = i2;
    }
  }
  _updateMoveTooltipDistance(t2, e4, i2) {
    if (null != e4 && "end" !== e4.action) {
      const { mapStart: a4, mapEnd: o2 } = e4, s2 = i2(a4, o2);
      t2.distance = null != s2 ? s2 : m$6;
    } else
      t2.distance = m$6;
  }
  get test() {
    return { discManipulator: this._moveManipulation.xyManipulation.test.discManipulator, zManipulator: this._moveManipulation.zManipulation.test.manipulator, ringManipulator: null != this._scaleRotate ? this._scaleRotate.test.ringManipulator : null, arrowManipulators: this._moveManipulation.xyAxisManipulation.test.arrowManipulators, setRingIndicatorDelayMs: (t2) => null != this._scaleRotate ? this._scaleRotate.test.setRingIndicatorDelayMs(t2) : null, scaleRotateAdapter: this._scaleRotateAdapter, scaleRotateTransform: this._scaleRotate };
  }
};
e$4([y$3({ constructOnly: true, nonNullable: true })], Y.prototype, "view", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], Y.prototype, "graphic", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], Y.prototype, "enableZ", void 0), e$4([y$3()], Y.prototype, "enableRotation", void 0), e$4([y$3()], Y.prototype, "enableScaling", void 0), e$4([y$3({ constructOnly: true, type: l$a })], Y.prototype, "sketchOptions", void 0), e$4([y$3()], Y.prototype, "graphicState", void 0), e$4([y$3({ value: false })], Y.prototype, "snapToScene", null), e$4([y$3({ constructOnly: true })], Y.prototype, "snappingManager", void 0), e$4([y$3({ readOnly: true })], Y.prototype, "type", void 0), e$4([y$3({ readOnly: true })], Y.prototype, "updating", null), e$4([y$3()], Y.prototype, "tooltip", void 0), Y = e$4([c$6("esri.views.3d.interactive.editingTools.graphicTransform3D.GraphicTransformTool")], Y);
class y3 {
  constructor(t2, e4, i2, o2) {
    this._tool = t2, this._graphicState = e4, this._editGeometryOperations = i2, this._bounds = o2, this._moveXYTooltipInfo = null, this._moveZTooltipInfo = null;
    const a4 = this._tool, r3 = a4.view;
    this.moveXYGraphicManipulation = new l({ view: r3, tool: a4, graphicState: this._graphicState }), a4.addHandles(this._createMoveXYGraphicDragPipeline()), this.moveZManipulator = new I$2(r3, H$4.CENTER_ON_CALLOUT), this.moveZManipulator.state |= Si, a4.manipulators.add(this.moveZManipulator), a4.addHandles([this._createMoveZDragPipeline()]), a4.addHandles([a4.on("graphic-translate-stop", () => {
      this._moveXYTooltipInfo = null, this._moveZTooltipInfo = null;
    })]);
  }
  destroy() {
    this.moveXYGraphicManipulation.destroy(), this._tool.manipulators.remove(this.moveZManipulator), this.moveZManipulator.destroy();
  }
  forEachManipulator(t2) {
    this.moveXYGraphicManipulation.forEachManipulator(t2), t2(this.moveZManipulator, A$3.TRANSLATE_Z);
  }
  updateManipulators(t2, o2) {
    const n2 = this.moveZManipulator, s2 = x$8(f$5.get(), t2, Math.PI);
    s2[12] = 0, s2[13] = 0, s2[14] = 0, n2.modelTransform = s2, n2.renderLocation = e$e(c$7.get(), o2.origin, o2.basis1);
  }
  getUpdatedTooltipInfo() {
    return this.moveXYGraphicManipulation.grabbing || this.moveXYGraphicManipulation.dragging ? this._computeMoveXYTooltipInfo() : this.moveZManipulator.focused ? this._computeMoveZTooltipInfo() : null;
  }
  _computeMoveXYTooltipInfo() {
    const e4 = this._tool, i2 = this._moveXYTooltipInfo ??= new r$a({ sketchOptions: e4.sketchOptions });
    if (this.moveXYGraphicManipulation.dragging) {
      const t2 = this._bounds, o2 = t2.mapBoundsStart.origin, a4 = t2.mapBounds.origin, { renderSpatialReference: r3 } = e4.view;
      if (!r3)
        return null;
      const n2 = u$4(o2, a4, r3);
      if (null == n2)
        return null;
      i2.distance = n2;
    } else
      i2.distance = m$6;
    return i2;
  }
  _computeMoveZTooltipInfo() {
    const e4 = this._tool, i2 = this._moveZTooltipInfo ??= new a$c({ sketchOptions: e4.sketchOptions });
    if (this.moveZManipulator.dragging) {
      const t2 = this._bounds, o2 = t2.mapBoundsStart.origin, a4 = t2.mapBounds.origin, { renderSpatialReference: r3 } = e4.view;
      if (!r3)
        return null;
      const n2 = g$8(o2, a4, r3);
      if (null == n2)
        return null;
      i2.distance = n2;
    } else
      i2.distance = m$6;
    return i2;
  }
  _createMoveXYGraphicDragPipeline() {
    return this.moveXYGraphicManipulation.createDragPipeline((t2, e4, i2) => this._applyGraphicMoveSteps(e4, i2));
  }
  _createMoveZDragPipeline() {
    const t2 = this._editGeometryOperations.data.spatialReference;
    return x$5(this.moveZManipulator, (e4, i2, a4) => {
      const r3 = t$9(e4.renderLocation), n2 = i2.next(k$2(this._tool.view, r3, t2)).next(P$5());
      this._applyGraphicMoveSteps(n2, a4);
    });
  }
  _applyGraphicMoveSteps(t2, e4) {
    const i2 = this._tool, o2 = i2.graphic, a4 = t2.next((t3) => ("start" === t3.action && (i2.inputState = { type: "move" }, this._bounds.backupMapBounds(), i2.emit("graphic-translate-start", { graphic: o2, dxScreen: t3.screenDeltaX, dyScreen: t3.screenDeltaY })), t3)).next(D$5()).next(this._moveDragUpdateGeometry()).next((t3) => {
      const e5 = { graphic: o2, dxScreen: t3.screenDeltaX, dyScreen: t3.screenDeltaY };
      switch (t3.action) {
        case "start":
        case "update":
          (t3.mapEnd.x - t3.mapStart.x || t3.mapEnd.y - t3.mapStart.y || (t3.mapEnd.z ?? 0) - (t3.mapStart.z ?? 0)) && i2.emit("graphic-translate", e5);
          break;
        case "end":
          i2.inputState = null, i2.emit("graphic-translate-stop", e5);
      }
      return t3;
    });
    return e4.next(() => {
      null != i2.inputState && i2.emit("graphic-translate-stop", { graphic: o2, dxScreen: 0, dyScreen: 0 }), i2.cancel();
    }), a4;
  }
  _moveDragUpdateGeometry() {
    const t2 = this._tool;
    return (e4) => {
      if (null == t2.inputState || "move" !== t2.inputState.type)
        return e4;
      const i2 = [];
      for (const t3 of this._editGeometryOperations.data.components)
        i2.push(...t3.vertices);
      const o2 = "start" === e4.action ? E$5.NEW_STEP : E$5.ACCUMULATE_STEPS, a4 = this._editGeometryOperations.moveVertices(i2, e4.mapDeltaX, e4.mapDeltaY, e4.mapDeltaZ, o2);
      return d$7(a4, this._bounds.mapBounds), t2.graphic.geometry = this._editGeometryOperations.data.geometry, e4;
    };
  }
}
class T {
  constructor(t2, e4, o2) {
    this._tool = t2, this._editGeometryOperations = e4, this._bounds = o2, this._rotateTooltipInfo = null, this._startAngle = 0, this._endAngle = 0;
    const r3 = this._tool, a4 = r3.view, i2 = !a4._stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result;
    this.rotateManipulator = new g$9(a4, (t3, e5) => l$e(a4.textures, { accentColor: t3, contrastColor: e5, preMultiplyAlpha: i2 })), r3.addHandles([this.rotateManipulator.events.on("grab-changed", (t3) => this._onRotateGrab(t3)), this._createRotateDragPipeline(this.rotateManipulator)]), r3.manipulators.add(this.rotateManipulator), r3.addHandles([r3.on("graphic-rotate-start", (t3) => {
      this._startAngle = t3.angle;
    }), r3.on("graphic-rotate", (t3) => {
      this._endAngle = t3.angle;
    }), r3.on("graphic-rotate-stop", () => {
      this._startAngle = 0, this._endAngle = 0;
    })]);
  }
  destroy() {
    this._tool.manipulators.remove(this.rotateManipulator), this.rotateManipulator.destroy();
  }
  forEachManipulator(t2) {
    t2(this.rotateManipulator, A$3.ROTATE);
  }
  updateManipulators(t2, r3) {
    const a4 = this._bounds.mapBounds.plane[2] < 0 ? Math.PI : 0, i2 = l$8(f$5.get(), t2, a4);
    i2[12] = 0, i2[13] = 0, i2[14] = 0, this.rotateManipulator.modelTransform = i2, this.rotateManipulator.renderLocation = u$6(c$7.get(), r3.origin, r3.basis1);
  }
  getUpdatedTooltipInfo() {
    return this.rotateManipulator.focused ? this._computeRotateTooltipInfo() : null;
  }
  _computeRotateTooltipInfo() {
    const t2 = this._rotateTooltipInfo ??= new i$a({ sketchOptions: this._tool.sketchOptions });
    return t2.angle = this._startAngle - this._endAngle, t2;
  }
  _onRotateGrab({ action: t2, screenPoint: e4 }) {
    const o2 = this._tool, r3 = this._bounds;
    if ("start" !== t2 || !e4)
      return;
    const a4 = li(r3.displayBounds, o2.view.renderCoordsHelper, _i.HEADING, E$4()), i2 = m$9(o2.view.state.camera, e4);
    S$5(a4, i2, c$7.get()) && (r3.backupMapBounds(), o2.inputState = { type: "rotate", rotatePlane: a4 });
  }
  _createRotateDragPipeline(e4) {
    const o2 = this._tool, r3 = o2.graphic;
    return x$5(e4, (e5, a4, i2) => {
      const s2 = o2.inputState;
      null != s2 && (a4.next((t2) => ("start" === t2.action && o2.emit("graphic-rotate-start", { graphic: r3, angle: 0 }), t2)).next(O$4(o2.view, s2.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(s2)).next(this._rotateDragUpdateGeometry()).next((e6) => {
        const a5 = { graphic: r3, angle: M$7(e6.rotateAngle) };
        switch (e6.action) {
          case "start":
          case "update":
            o2.emit("graphic-rotate", a5);
            break;
          case "end":
            o2.inputState = null, o2.emit("graphic-rotate-stop", a5);
        }
        return e6;
      }), i2.next(() => {
        null != o2.inputState && o2.emit("graphic-rotate-stop", { graphic: r3, angle: 0 }), o2.cancel();
      }));
    });
  }
  _rotateDragRenderPlaneToRotate(t2) {
    return (e4) => {
      const o2 = F$2(t2.rotatePlane), r3 = b$5(e4.renderStart, e4.renderEnd, this._bounds.displayBounds.origin, o2);
      return { ...e4, rotateAxis: o2, rotateAngle: r3 };
    };
  }
  _rotateDragUpdateGeometry() {
    const t2 = this._tool, e4 = this._bounds;
    return (o2) => {
      const s2 = r$d(n$5(), e4.mapBoundsStart.origin), n2 = [];
      for (const t3 of this._editGeometryOperations.data.components)
        n2.push(...t3.vertices);
      const p4 = "start" === o2.action ? E$5.NEW_STEP : E$5.ACCUMULATE_STEPS, l2 = this._editGeometryOperations.rotateVertices(n2, s2, o2.rotateAngle, p4, e$h.REPLACE);
      return Z$2(e4.mapBoundsStart, e4.mapBounds), d$7(l2, e4.mapBounds), t2.graphic.geometry = this._editGeometryOperations.data.geometry, o2;
    };
  }
}
class C3 {
  constructor(s2, t2, i2) {
    this._tool = s2, this._onDisplayBoundsChanged = t2, this.mapBounds = W$3(), this.mapBoundsStart = W$3(), this.displayBounds = W$3(), this._calculateMapBounds(i2);
  }
  get displayBoundsMargin() {
    const { view: s2, graphic: t2 } = this._tool, i2 = s2.pointsOfInterest?.centerOnSurfaceFrequent.location ?? t2.geometry?.extent?.center;
    return i2 ? _ * s2.pixelSizeAt(i2) : 0;
  }
  backupMapBounds() {
    Z$2(this.mapBounds, this.mapBoundsStart);
  }
  updateDisplayBounds() {
    this._calculateDisplayBounds(), this._onDisplayBoundsChanged();
  }
  _calculateMapBounds(o2) {
    const { view: e4, attachmentOrigin: r3 } = this._tool, a4 = o2.geometry, n2 = n$3(a4);
    l$2(n2, n2, -1);
    const c2 = e4.spatialReference, p4 = a4.spatialReference, l2 = r3 ? e4.pixelSizeAt(r3) * z$5(c2) / W$1(p4) : 0;
    F$4(n2, o2, x2 * l2, this.mapBounds);
  }
  _calculateDisplayBounds() {
    const { view: s2, attachmentOrigin: t2, graphic: i2 } = this._tool;
    if (!i2.geometry)
      return;
    const o2 = t2?.z ?? f$4(this.mapBounds.origin, s2.elevationProvider, o$5.fromElevationInfo(a$b(i2)), s2.renderCoordsHelper), e4 = Z$2(this.mapBounds);
    e4.origin[2] = o2 ?? 0, S2(e4, s2.renderCoordsHelper, i2.geometry.spatialReference, this.displayBoundsMargin, this.displayBounds);
  }
}
const _ = 10, x2 = 80;
function S2(s2, t2, i2, m3 = 0, d2) {
  d2 || (d2 = W$3()), t2.toRenderCoords(s2.origin, i2, d2.origin);
  const u2 = c$7.get();
  u$6(u2, s2.origin, s2.basis1), u$6(u2, u2, s2.basis2), t2.toRenderCoords(u2, i2, u2);
  const f3 = c$7.get();
  u$6(f3, s2.origin, s2.basis1), e$e(f3, f3, s2.basis2), t2.toRenderCoords(f3, i2, f3);
  const B2 = c$7.get();
  e$e(B2, s2.origin, s2.basis1), e$e(B2, B2, s2.basis2), t2.toRenderCoords(B2, i2, B2);
  const y4 = c$7.get();
  e$e(y4, s2.origin, s2.basis1), u$6(y4, y4, s2.basis2), t2.toRenderCoords(y4, i2, y4);
  const v2 = A$9(c$7.get(), u2, f3, 0.5);
  e$e(v2, v2, d2.origin);
  const j2 = A$9(c$7.get(), B2, y4, 0.5);
  e$e(j2, d2.origin, j2), A$9(d2.basis1, v2, j2, 0.5);
  const R3 = A$9(c$7.get(), y4, u2, 0.5);
  e$e(R3, R3, d2.origin);
  const C4 = A$9(c$7.get(), f3, B2, 0.5);
  e$e(C4, d2.origin, C4), A$9(d2.basis2, R3, C4, 0.5);
  const _2 = _$3(c$7.get(), d2.basis1, d2.basis2), x3 = _$3(_2, _2, d2.basis1);
  return z$3(x3, x3), g$5(d2.basis2, x3, P$6(d2.basis2, x3)), g$5(d2.basis1, d2.basis1, 1 + m3 / s$3(d2.basis1)), g$5(d2.basis2, d2.basis2, 1 + m3 / s$3(d2.basis2)), J$3(d2), d2;
}
function U(s2, t2, i2) {
  return e$e(O2, e$e(O2, s2.origin, s2.basis1), s2.basis2), q$8(M, O2, s2.basis1, 2), q$8(D, M, s2.basis2, 2), q$8(k, O2, s2.basis2, 2), O2[2] = M[2] = D[2] = k[2] = t2, o$9({ topLeft: k, topRight: D, bottomRight: M, bottomLeft: O2, spatialReference: i2 });
}
const k = n$5(), D = n$5(), M = n$5(), O2 = n$5();
class j {
  get zMax() {
    if (!this._zMaxDirty)
      return this._zMax;
    const t2 = this._editGeometryOperations.data;
    if (t2.geometry.hasZ) {
      const e4 = t2.coordinateHelper;
      this._zMax = Number.NEGATIVE_INFINITY;
      for (const s2 of t2.components)
        for (const t3 of s2.vertices) {
          const s3 = e4.getZ(t3.pos) ?? 0;
          this._zMax = Math.max(s3, this._zMax);
        }
    } else
      this._zMax = 0;
    return this._zMaxDirty = false, this._zMax;
  }
  constructor(e4, i2, a4, r3, o2) {
    this._tool = e4, this._graphicState = i2, this._editGeometryOperations = a4, this._bounds = r3, this._preserveAspectRatioStep = o2, this._resizeHandles = [{ direction: [1, 0] }, { direction: [1, 1] }, { direction: [0, 1] }, { direction: [-1, 1] }, { direction: [-1, 0] }, { direction: [-1, -1] }, { direction: [0, -1] }, { direction: [1, -1] }], this._scaleTooltipInfo = null, this._displayBoundsStart = W$3(), this._displayBoundsMarginStart = 0, this._startScale = n$4(), this._endScale = n$4(), this._sizeStart = null, this._zMax = 0, this._zMaxDirty = true;
    const n2 = this._tool, c2 = n2.view;
    this.resizeManipulators = this._resizeHandles.map((t2) => {
      const e5 = new v$8(c2, t2);
      return n2.addHandles([e5.events.on("grab-changed", (t3) => this._onResizeGrab(t3)), this._createResizeDragPipeline(e5, t2)]), e5;
    }), n2.manipulators.addMany(this.resizeManipulators), n2.addHandles([n2.on("graphic-scale-start", (e5) => {
      o$2(this._startScale, e5.xScale, e5.yScale), o$2(this._endScale, e5.xScale, e5.yScale);
    }), n2.on("graphic-scale", (e5) => {
      o$2(this._endScale, e5.xScale, e5.yScale);
    }), n2.on("graphic-scale-stop", () => {
      o$2(this._startScale, 0, 0), o$2(this._endScale, 0, 0);
    }), this._graphicState.on("changed", () => {
      "resize" !== n2.inputState?.type && (this._zMaxDirty = true);
    })]);
  }
  destroy() {
    this.forEachManipulator((t2) => {
      this._tool.manipulators.remove(t2), t2.destroy();
    });
  }
  forEachManipulator(t2) {
    this.resizeManipulators.forEach((e4) => t2(e4, A$3.SCALE));
  }
  updateManipulators(t2, e4) {
    this.resizeManipulators.forEach((s2, i2) => {
      gi(s2, this._resizeHandles[i2], t2, e4);
    });
  }
  getUpdatedTooltipInfo() {
    return this.resizeManipulators.some((t2) => t2.focused) ? this._computeScaleTooltipInfo() : null;
  }
  _computeScaleTooltipInfo() {
    const t2 = this._tool, e4 = this._scaleTooltipInfo ??= new p$c({ sketchOptions: t2.sketchOptions }), s2 = t2.graphic.geometry;
    if (null == s2)
      return null;
    const i2 = U(this._bounds.mapBounds, this.zMax, s2.spatialReference);
    return null == i2 ? null : (e4.xSize = i2.xSize, e4.ySize = i2.ySize, null != this._sizeStart && this.resizeManipulators.some((t3) => t3.dragging) ? (e4.xScale = i2.xSize.value / this._sizeStart.xSize.value, e4.yScale = i2.ySize.value / this._sizeStart.ySize.value) : (e4.xScale = 1, e4.yScale = 1), e4);
  }
  _onResizeGrab({ action: t2, screenPoint: e4 }) {
    const s2 = this._tool, i2 = this._bounds;
    if ("start" !== t2 || !e4 || !s2.graphic.geometry)
      return;
    const a4 = m$9(s2.view.state.camera, e4);
    S$5(i2.displayBounds.plane, a4, c$7.get()) && (i2.backupMapBounds(), Z$2(i2.displayBounds, this._displayBoundsStart), this._displayBoundsMarginStart = i2.displayBoundsMargin, this._sizeStart = U(i2.mapBoundsStart, this.zMax, s2.graphic.geometry.spatialReference), s2.inputState = { type: "resize" });
  }
  _createResizeDragPipeline(t2, e4) {
    const s2 = this._tool, i2 = s2.graphic;
    return x$5(t2, (t3, a4, r3) => {
      null != s2.inputState && (a4.next((t4) => ("start" === t4.action && s2.emit("graphic-scale-start", { graphic: i2, xScale: 1, yScale: 1 }), t4)).next(O$4(s2.view, this._displayBoundsStart.plane)).next((t4) => ({ ...t4, handle: e4 })).next(this._resizeDragRenderPlaneToFactors()).next(...this._preserveAspectRatioStep()).next(this._resizeDragUpdateGeometry()).next((t4) => {
        const e5 = { graphic: i2, xScale: t4.factor1, yScale: t4.factor2 };
        switch (t4.action) {
          case "start":
          case "update":
            s2.emit("graphic-scale", e5);
            break;
          case "end":
            s2.inputState = null, s2.emit("graphic-scale-stop", e5);
        }
        return t4;
      }), r3.next(() => {
        null != s2.inputState && s2.emit("graphic-scale-stop", { graphic: i2, xScale: 1, yScale: 1 }), s2.cancel();
      }));
    });
  }
  _resizeDragRenderPlaneToFactors() {
    const t2 = this._bounds;
    return (e4) => {
      const s2 = this._displayBoundsStart, c2 = e4.handle.direction, l2 = t2.displayBoundsMargin, p4 = this._displayBoundsMarginStart, h3 = r$d(c$7.get(), s2.origin);
      q$8(h3, h3, s2.basis1, -c2[0]), q$8(h3, h3, s2.basis2, -c2[1]);
      const u2 = e$e(c$7.get(), e4.renderEnd, h3), m3 = e$e(c$7.get(), e4.renderStart, h3), g3 = Ei(e4.handle), y4 = Ii(s2), f3 = Ii(t2.displayBounds) / y4, z3 = (t3, e5) => {
        if (0 === t3)
          return 1;
        let s3 = s$3(e5), i2 = 0.5 * t3 * P$6(e5, u2) / s3;
        const a4 = i2 < 0 ? -1 : 1;
        if (g3) {
          i2 += (s3 - 0.5 * t3 * P$6(e5, m3) / s3) * a4 * f3;
        }
        const r3 = s3 < 1.5 * p4 ? 1 : E;
        return s3 = Math.max(s3 - p4, E), a4 > 0 && (i2 -= l2), a4 * Math.max(a4 * (i2 / s3), r3);
      };
      return { ...e4, factor1: z3(c2[0], s2.basis1), factor2: z3(c2[1], s2.basis2) };
    };
  }
  _resizeDragUpdateGeometry() {
    const r3 = this._tool, o2 = this._bounds;
    return (n2) => {
      const l2 = r$d(n$5(), o2.mapBoundsStart.origin);
      q$8(l2, l2, o2.mapBoundsStart.basis1, -n2.handle.direction[0]), q$8(l2, l2, o2.mapBoundsStart.basis2, -n2.handle.direction[1]);
      const h3 = o$2(n$4(), o2.mapBoundsStart.basis1[0], o2.mapBoundsStart.basis1[1]);
      v$2(h3, h3);
      const d2 = [];
      for (const t2 of this._editGeometryOperations.data.components)
        d2.push(...t2.vertices);
      const u2 = "start" === n2.action ? E$5.NEW_STEP : E$5.ACCUMULATE_STEPS, m3 = this._editGeometryOperations.scaleVertices(d2, l2, h3, n2.factor1, n2.factor2, u2, e$h.REPLACE);
      return Z$2(o2.mapBoundsStart, o2.mapBounds), d$7(m3, o2.mapBounds), r3.graphic.geometry = this._editGeometryOperations.data.geometry, n2;
    };
  }
}
const E = 1e-6;
class e3 {
  constructor() {
    this._lastDragEvent = null, this._next = null, this._enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t2) {
    if (this._enabled !== t2 && null != this._lastDragEvent && null != this._next) {
      const a4 = { ...this._lastDragEvent, action: "update" };
      t2 && this._adjustScaleFactors(a4), this._next.execute(a4);
    }
    this._enabled = t2;
  }
  createDragEventPipelineStep() {
    this._lastDragEvent = null;
    const t2 = new Y$1();
    return this._next = t2, [(t3) => (this._lastDragEvent = "end" !== t3.action ? { ...t3 } : null, this._enabled && this._adjustScaleFactors(t3), t3), t2];
  }
  _adjustScaleFactors(a4) {
    const e4 = Ei(a4.handle) ? Math.max(Math.abs(a4.factor1), Math.abs(a4.factor2)) : 0 === a4.handle.direction[0] ? Math.abs(a4.factor2) : Math.abs(a4.factor1);
    a4.factor1 = a4.factor1 < 0 ? -e4 : e4, a4.factor2 = a4.factor2 < 0 ? -e4 : e4;
  }
  get test() {
    return { _adjustScaleFactors: (t2) => this._adjustScaleFactors(t2) };
  }
}
let w3 = class extends o$3.EventedMixin(l$9) {
  constructor(t2) {
    super(t2), this.enableZ = true, this.enableScaling = true, this.enableRotation = true, this.sketchOptions = new l$a(), this._preserveAspectRatio = new e3(), this.grabbing = false, this.inputState = null, this._attachmentOrigin = null, this.type = "transform-3d", this._outlineVisualElement = null;
  }
  initialize() {
    const { view: t2, graphic: e4 } = this, s2 = this._graphicState = new e$3({ graphic: e4 }), n2 = e4.geometry, r3 = this._editGeometryOperations = V$4.fromGeometry(n2, t2.state.viewingMode), l2 = this._bounds = new C3(this, () => this._updateManipulators(), r3.data);
    this._extentMove = new y3(this, s2, r3, l2), this._extentScale = new j(this, s2, r3, l2, () => this._preserveAspectRatio.createDragEventPipelineStep()), this._extentRotate = new T(this, r3, l2), this.addHandles([d$3(() => this.enableZ, () => this._updateManipulatorAvailability(this._extentMove.moveZManipulator, A$3.TRANSLATE_Z)), d$3(() => this.enableScaling, () => this._extentScale.forEachManipulator((t3) => this._updateManipulatorAvailability(t3, A$3.SCALE))), d$3(() => this.enableRotation, () => this._updateManipulatorAvailability(this._extentRotate.rotateManipulator, A$3.ROTATE))]), this._updateAllManipulatorAvailability();
    const p4 = i$2({ view: t2, graphic: e4, forEachManipulator: (t3) => this._forEachManipulator(t3), onManipulatorsChanged: () => e$5() });
    if (null != p4) {
      const { visualElement: t3 } = p4;
      t3 instanceof w$1 && (this._outlineVisualElement = t3, this.addHandles(t3.events.on("attachment-origin-changed", () => this._bounds.updateDisplayBounds()))), this.addHandles(p4);
    }
    this.addHandles([s2.on("changed", () => this._onGeometryChanged()), d$3(() => s2.displaying, () => this._updateAllManipulatorAvailability()), d$3(() => s2.isDraped, () => this._graphicDrapedChanged(), P$3), d$3(() => t2.pointsOfInterest?.centerOnSurfaceFrequent.location, () => l2.updateDisplayBounds()), t2.trackGraphicState(s2)]);
    const h3 = (t3) => {
      this.addHandles(t3.events.on("grab-changed", () => {
        this.grabbing = t3.grabbing, this._updateAllManipulatorAvailability();
      }));
    };
    this._forEachManipulator(h3);
    const c2 = (t3, i2) => {
      this.addHandles(t3.events.on("immediate-click", (t4) => {
        i2 === A$3.TRANSLATE_XY && this.emit("immediate-click", { ...t4, graphic: e4 }), t4.stopPropagation();
      }));
    };
    this._forEachManipulator(c2), this._initializeTooltip(), this.finishToolCreation();
  }
  destroy() {
    this._extentMove.destroy(), this._extentScale.destroy(), this._extentRotate.destroy(), this._editGeometryOperations.destroy(), this.tooltip.destroy(), this._set("view", null), this._set("graphic", null);
  }
  _initializeTooltip() {
    const { view: t2 } = this, e4 = this.tooltip = new u$9({ view: t2 }), i2 = () => {
      e4.info = this._getUpdatedTooltipInfo();
    };
    this.addHandles([d$3(() => this.sketchOptions.tooltips.effectiveEnabled, i2), this.on("graphic-translate-start", i2), this.on("graphic-translate", i2), this.on("graphic-translate-stop", () => {
      this.tooltip.clear();
    }), this.on("graphic-rotate-start", i2), this.on("graphic-rotate", i2), this.on("graphic-rotate-stop", i2), this.on("graphic-scale-start", i2), this.on("graphic-scale", i2), this.on("graphic-scale-stop", i2)]), this._forEachManipulator((t3) => {
      this.addHandles([t3.events.on("focus-changed", i2), t3.events.on("grab-changed", i2), t3.events.on("drag", (t4) => {
        "cancel" === t4.action ? this.tooltip.clear() : i2();
      })]);
    });
  }
  _getUpdatedTooltipInfo() {
    return this.sketchOptions.tooltips.effectiveEnabled ? this._extentMove.getUpdatedTooltipInfo() ?? this._extentScale.getUpdatedTooltipInfo() ?? this._extentRotate.getUpdatedTooltipInfo() : null;
  }
  _onGeometryChanged() {
    this._bounds.updateDisplayBounds();
  }
  _graphicDrapedChanged() {
    this.removeHandles(G), this._bounds.updateDisplayBounds(), this._graphicState.isDraped && this.addHandles(this.view.elevationProvider.on("elevation-change", (t2) => {
      null != this._attachmentOrigin && w$4(t2.extent, this._attachmentOrigin.x, this._attachmentOrigin.y) && this._bounds.updateDisplayBounds();
    }), G);
  }
  _updateManipulators() {
    if (!this.visible)
      return;
    const t2 = this._bounds.displayBounds, e4 = ci(t2, f$5.get());
    this._extentMove.updateManipulators(e4, t2), this._extentScale.updateManipulators(e4, t2), this._extentRotate.updateManipulators(e4, t2);
  }
  _updateAllManipulatorAvailability() {
    this._forEachManipulator((t2, e4) => this._updateManipulatorAvailability(t2, e4));
  }
  _updateManipulatorAvailability(t2, e4) {
    const i2 = this.grabbing && !t2.grabbing;
    if (t2.interactive = !i2, t2 instanceof ee) {
      const a4 = this._graphicState.displaying, o2 = this.enableZ && n$8(this.graphic);
      switch (e4) {
        case A$3.ROTATE:
          t2.available = a4 && this.enableRotation;
          break;
        case A$3.SCALE:
          t2.available = a4 && (this.enableScaling || this.enableRotation || o2), t2.interactive = !i2 && this.enableScaling, t2.state = this.enableScaling ? Hi : Ui;
          break;
        case A$3.TRANSLATE_Z:
          t2.available = a4 && o2;
          break;
        default:
          t2.available = a4;
      }
    }
  }
  _forEachManipulator(t2) {
    this._extentMove.forEachManipulator(t2), this._extentScale.forEachManipulator(t2), this._extentRotate.forEachManipulator(t2);
  }
  get preserveAspectRatio() {
    return this._preserveAspectRatio.enabled;
  }
  set preserveAspectRatio(t2) {
    this._preserveAspectRatio.enabled = t2, this._set("preserveAspectRatio", t2);
  }
  get attachmentOrigin() {
    const t2 = this.graphic.geometry, e4 = this._graphicState.isDraped ? null : this._outlineVisualElement?.attachmentOrigin;
    return this._attachmentOrigin = e4 ?? O$3(this.view, this.graphic) ?? t2?.extent?.center, this._attachmentOrigin;
  }
  reset() {
  }
  cancel() {
    if (this.canUndo) {
      const t2 = this._editGeometryOperations.undo();
      E$6(t2, this._bounds.mapBounds), this.graphic.geometry = this._editGeometryOperations.data.geometry;
    }
    this.inputState = null;
  }
  get canUndo() {
    return this._editGeometryOperations.canUndo;
  }
  undo() {
    if (null != this.inputState)
      this.view.activeTool = null;
    else if (this.canUndo) {
      const t2 = this._editGeometryOperations.undo();
      E$6(t2, this._bounds.mapBounds), this.graphic.geometry = this._editGeometryOperations.data.geometry;
    }
  }
  get canRedo() {
    return this._editGeometryOperations.canRedo;
  }
  redo() {
    if (this.canRedo) {
      const t2 = this._editGeometryOperations.redo();
      d$7(t2, this._bounds.mapBounds), this.graphic.geometry = this._editGeometryOperations.data.geometry;
    }
  }
  get test() {
    return { moveZManipulator: this._extentMove.moveZManipulator, resizeManipulators: this._extentScale.resizeManipulators, rotateManipulator: this._extentRotate.rotateManipulator };
  }
};
e$4([y$3({ constructOnly: true, nonNullable: true })], w3.prototype, "view", void 0), e$4([y$3({ constructOnly: true, nonNullable: true })], w3.prototype, "graphic", void 0), e$4([y$3()], w3.prototype, "enableZ", void 0), e$4([y$3()], w3.prototype, "enableScaling", void 0), e$4([y$3()], w3.prototype, "enableRotation", void 0), e$4([y$3({ constructOnly: true, type: l$a })], w3.prototype, "sketchOptions", void 0), e$4([y$3()], w3.prototype, "preserveAspectRatio", null), e$4([y$3()], w3.prototype, "grabbing", void 0), e$4([y$3()], w3.prototype, "inputState", void 0), e$4([y$3({ readOnly: true })], w3.prototype, "type", void 0), e$4([y$3()], w3.prototype, "tooltip", void 0), w3 = e$4([c$6("esri.views.3d.interactive.editingTools.transformGraphic.ExtentTransformTool")], w3);
const G = "draped-elevation-changes";
export {
  z2 as DrawGraphicTool3D,
  w3 as ExtentTransformTool,
  q as GraphicMoveTool,
  y$1 as GraphicReshapeTool,
  Y as GraphicTransformTool
};
