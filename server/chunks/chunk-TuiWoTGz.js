import { bo as e$4, bp as y$1, br as c$5, bs as g$2, el as d$2, sF as f$3, b1 as s$3, bJ as d$3, e3 as v$2, bS as e$5, bu as u$5, pM as R$3, sB as G$3, sC as q$2, vh as G$4, kH as a$8, kD as b$3, j1 as r$4, hK as r$5, mD as v$3, mB as l$3, sK as A$6, mA as s$4, fw as n$3, kG as i$5, pP as f$4, eQ as n$4, bR as A$7, mQ as a$9, nX as d$4, DB as U$3, sz as E$2, q6 as h$4, ki as e$7, d1 as o$4, pz as r$6, pB as D$3, o2 as a$a, pC as t$4, eP as o$5, l6 as u$6, mL as g$3, nV as x$4, DC as l$4, ew as h$5, n$ as b$4, eu as e$8, k7 as t$5, gr as n$5, vd as c$7, DD as p$4, ko as o$6, jn as h$6, ie as z$2, n3 as W$1, fo as s$5, vs as g$4, x2 as o$7, eq as t$6, DE as t$7, ve as f$5, eg as p$5, bn as P$4, bD as u$7, DF as et, sL as r$8, DG as r$9, er as c$8, rZ as M$5, DH as o$9, o7 as r$a, cU as i$6, eL as t$8, eK as P$5, DI as R$4, kF as e$9, DJ as w$3, mz as e$a, DK as pt, DL as it, lk as q$5, mK as c$9, q1 as f$6, rV as t$9, u1 as R$5, q4 as c$a, q0 as g$5, oP as r$b, q3 as d$7, o3 as f$7, lQ as e$c, hy as e$d, mO as f$8, DM as ut, kr as l$5, DN as ct, uf as lt, vq as U$5, mJ as e$e, eO as z$4, pv as P$7, eN as _$1, DO as L$3, uc as i$7, u7 as l$6, o5 as f$9, eY as i$8, aq as has, bh as V$4, fx as p$6, bm as h$7, DP as o$a, DQ as P$9, vv as c$b, f9 as ot$1, pt as k$4, ps as b$5, z0 as H$1, DR as t$a, mH as x$7, f8 as v$4, DS as j$5, tR as y$5, vB as o$b, pq as s$8, pS as nt, h4 as z$5, mI as A$8, vu as t$b, DT as Y$1, cZ as f$b, rO as u$9, dy as m$5, w$ as c$d, DU as l$9, DV as n$8, bK as C$6, q2 as v$6, DW as b$7, sA as F, le as t$c, DX as r$d, fl as m$6, ug as at, rS as p$a, v8 as p$b, DY as b$8, vV as h$9, vY as l$a, DZ as x$8, fC as l$b, vW as N$3, v_ as g$7, vX as U$7, cy as x$9, bX as k$6, u3 as x$a, pY as m$7, pp as B$1, hw as r$e, pX as Z, pU as W$2, ln as V$7, ub as J, f5 as q$6, fh as se } from "./chunk-KFNcxJaF.js";
import { e as e$6, q as q$3 } from "./chunk-Jwrw72Py.js";
import { x as x$3 } from "./chunk-vcGzLtIh.js";
import { l as l$2, a as s$6, u as u$8, s as s$7, p as p$8, b as p$9, c as a$c } from "./chunk-GM3bx0Bh.js";
import { V as V$3, O as O$2, d as d$5, G as G$5 } from "./chunk-rpjYs__P.js";
import { t as t$3 } from "./chunk-NjpOSVY5.js";
import { c as c$6, x as x$5 } from "./chunk-nQSFOLog.js";
import { K, k as k$2, X, o as o$8, r as r$7, g as g$6, V as V$6, l as l$d, x as x$b } from "./chunk-GdVukjg-.js";
import { h as h$8, m as m$4, i as i$9, o as o$d, n as p$c } from "./chunk-KXkDk_IW.js";
import { $, e as e$b, w as w$4, k as k$3, b as b$6, v as v$5, F as F$1 } from "./chunk-S1k8w-_l.js";
import { n as n$6 } from "./chunk-mRgVwI7R.js";
import { T as T$3, P as P$6, M as M$6, U as U$6, k as k$5, D as D$5, H as H$2, l as l$c } from "./chunk-G5EKjELj.js";
import { x as x$6, z as z$3, d as d$6, D as D$4, y as y$2, q as q$4, U as U$4, P as P$8, l as l$7, j as j$4, w as w$5, C as C$5, O as O$3 } from "./chunk-FKMfLf6u.js";
import { S as S$3 } from "./chunk-WQPcs7l9.js";
import { V as V$5, y as y$4, N as N$2, E as E$3, e as e$g } from "./chunk-ntY6_aOQ.js";
import { e as e$f } from "./chunk-tNL5i2kK.js";
import { f as f$a } from "./chunk-vWiGr0Yr.js";
import { r as r$c, a as a$b, l as l$8, n as n$7, c as c$c, p as p$7 } from "./chunk-6h7v8yvx.js";
import { y as y$3, R as R$6, d as d$8 } from "./chunk-sO9RJjHR.js";
import { o as o$c } from "./chunk-7pOsGJCN.js";
import { I as I$1, H as H$3, z as Mi, g as g$8, c as ci, C as Ci, a as v$7, i as di, B as Ii, D as hi, e as ai, N as Ni, F as Hi } from "./chunk-xpxxwZ-i.js";
import { i as i$a, p as p$d } from "./chunk-fMj7ynpL.js";
import "@popperjs/core";
import "luxon";
import "@esri/arcgis-html-sanitizer";
import "@esri/calcite-components/dist/components/index.js";
import "./chunk-WuibsuuF.js";
import "./chunk-Z0Yk6-wB.js";
import "./chunk-8M1zBeVZ.js";
import "./chunk-Jk46lvUq.js";
import "./chunk-XZLuqbq5.js";
import "./chunk-z9Tnkksn.js";
import "./chunk-OvdaIYdh.js";
import "./chunk-s_1zK5-o.js";
import "./chunk-x5arQHJi.js";
import "./chunk-J84yWr0C.js";
import "./chunk-zw9UPZSi.js";
const w$2 = 3025, D$2 = { default: 15, far: 25 };
let O$1 = class O extends g$2 {
  constructor(t3) {
    super(t3), this.context = null, this.stagedVertex = null, this.visible = true, this.edgeDistance = "default", this._messagesUnits = null, this._labelInfos = [], this._nextLabelIndex = 0;
  }
  initialize() {
    const t3 = d$2(async (t4) => {
      const e4 = await f$3("esri/core/t9n/Units");
      s$3(t4), this._messagesUnits = e4;
    });
    this.addHandles([d$3(() => [null != this.context && this.getCameraOrExtent(this.context), this.visible, this._edgeDistancePixels, this.stagedVertex, this._messagesUnits], () => this._update()), ...["vertex-add", "vertex-update", "vertex-remove"].map((t4) => v$2(() => this.context?.editGeometryOperations, t4, () => this._update())), e$5(() => t3.abort()), d$3(() => this._colors, (t4) => this._updateStyle(t4))]);
  }
  destroy() {
    for (this._nextLabelIndex = 0; this._labelInfos.length; )
      this._destroyLabel(this._labelInfos.pop());
  }
  get updating() {
    return null == this._messagesUnits;
  }
  get test() {
    return { labelContents: this._labelInfos.slice(0, this._nextLabelIndex).map((t3) => t3.label.text) };
  }
  get _edgeDistancePixels() {
    return D$2[this.edgeDistance];
  }
  get _colors() {
    const t3 = this.context?.view.effectiveTheme.textColor ?? u$5.fromArray([255, 255, 255]);
    return { textColor: t3, backgroundColor: R$3(G$3(t3, q$2.Low), 0.6) };
  }
  _update() {
    if (this.destroyed)
      return;
    this._nextLabelIndex = 0;
    const t3 = this.context;
    if (null == t3)
      return void this._destroyUnusedLabels();
    const { components: e4, geometry: s2, coordinateHelper: o2 } = t3.editGeometryOperations.data;
    if (!s2)
      return void this._destroyUnusedLabels();
    const r3 = e4.length;
    for (let i2 = 0; i2 < r3; ++i2) {
      const n2 = [];
      if (e4[i2].iterateVertices((t4) => {
        n2.push(o2.toXYZ(t4.pos));
      }), 0 === i2 && null != this.stagedVertex && n2.push(o2.toXYZ(this.stagedVertex)), n2.length < 2)
        continue;
      const l2 = n2[0], a4 = n2[n2.length - 1];
      "polygon" === s2.type && n2.length > 2 && !G$4(l2, a4) && n2.push(l2);
      const c2 = 1 === r3 && !a$8(n2);
      let p4 = G$2, h2 = A$5;
      this.toScreenPointArray(t3, l2, p4);
      for (let e5 = 1; e5 < n2.length; ++e5) {
        const s3 = n2[e5 - 1], o3 = n2[e5];
        this.toScreenPointArray(t3, o3, h2), this._addLabel(t3, s3, p4, o3, h2, c2), [p4, h2] = [h2, p4];
      }
    }
    this._destroyUnusedLabels();
  }
  _updateStyle({ textColor: t3, backgroundColor: e4 }) {
    const s2 = this._nextLabelIndex, o2 = this._labelInfos;
    for (let r3 = 0; r3 < s2; ++r3) {
      const { label: s3 } = o2[r3];
      s3.textColor = t3, s3.backgroundColor = e4;
    }
  }
  _addLabel(t3, e4, s2, o2, r3, i2) {
    const { label: n2 } = this._getOrCreateLabel(t3);
    if (!this.visible || b$3(s2, r3) < w$2)
      return void (n2.visible = false);
    const l2 = null != t3.graphicState ? t3.graphicState.isDraped ? "on-the-ground" : "absolute-height" : r$4(t3.editGeometryOperations.data.geometry, t3.elevationInfo), { spatialReference: a4 } = t3.editGeometryOperations.data, p4 = l$2(e4, o2, a4, l2), h2 = this._messagesUnits, d2 = e$6(t3.view);
    n2.text = null != h2 && null != p4 ? q$3(h2, p4, d2) : "", n2.visible = true;
    const m3 = r3[0] - s2[0], u3 = r3[1] - s2[1];
    i2 ? r$5(V$2, -u3, m3) : r$5(V$2, u3, -m3), v$3(V$2, V$2), l$3(V$2, V$2, this._edgeDistancePixels), A$6(P$3, s2, r3, 0.5), s$4(P$3, P$3, V$2), n2.position = [P$3[0], P$3[1]], Math.abs(V$2[0]) > Math.abs(V$2[1]) ? n2.anchor = V$2[0] > 0 ? "left" : "right" : n2.anchor = -V$2[1] < 0 ? "top" : "bottom";
  }
  _getOrCreateLabel(t3) {
    const e4 = this._labelInfos.length > this._nextLabelIndex, { textColor: s2, backgroundColor: o2 } = this._colors;
    if (e4) {
      const t4 = this._labelInfos[this._nextLabelIndex++], { label: e5 } = t4;
      return e5.textColor = s2, e5.backgroundColor = o2, t4;
    }
    const r3 = new x$3({ anchor: "center", fontSize: 10, textColor: s2, backgroundColor: o2 });
    t3.view.overlay?.items.add(r3);
    const i2 = { label: r3 };
    return this._labelInfos.push(i2), this._nextLabelIndex = this._labelInfos.length, i2;
  }
  _destroyUnusedLabels() {
    for (; this._labelInfos.length > this._nextLabelIndex; )
      this._destroyLabel(this._labelInfos.pop());
  }
  _destroyLabel({ label: t3 }) {
    this.context?.view.overlay?.items.remove(t3), t3.destroy();
  }
};
e$4([y$1()], O$1.prototype, "context", void 0), e$4([y$1()], O$1.prototype, "stagedVertex", void 0), e$4([y$1()], O$1.prototype, "visible", void 0), e$4([y$1()], O$1.prototype, "edgeDistance", void 0), e$4([y$1()], O$1.prototype, "updating", null), e$4([y$1()], O$1.prototype, "_messagesUnits", void 0), e$4([y$1()], O$1.prototype, "_edgeDistancePixels", null), e$4([y$1()], O$1.prototype, "_colors", null), O$1 = e$4([c$5("esri.views.interactive")], O$1);
const V$2 = n$3(), P$3 = n$3(), G$2 = i$5(), A$5 = i$5();
let a$7 = class a extends O$1 {
  getCameraOrExtent({ view: e4 }) {
    return e4.state.camera;
  }
  toScreenPointArray({ view: e4, elevationInfo: t3, editGeometryOperations: o2 }, s2, a4 = i$5()) {
    const { spatialReference: m3 } = o2.data.coordinateHelper;
    return f$4(s2, m3, t3, e4, c$4), e4.state.camera.projectToScreen(c$4, a4), a4;
  }
};
a$7 = e$4([c$5("esri.views.3d.interactive.SegmentLabels3D")], a$7);
const c$4 = n$4();
function o$3(n2) {
  const { graphic: o2 } = n2;
  return [d$3(() => n2.displaying, (e4) => {
    e4 ? s$2(o2) : i$4(o2);
  }, { ...A$7 }), e$5(() => i$4(o2))];
}
function s$2(e4) {
  const { geometry: t3 } = e4;
  a$6(t3) && e4.notifyMeshTransformChanged({ action: a$9.EnableFastUpdates });
}
function i$4(e4) {
  const { geometry: t3 } = e4;
  a$6(t3) && e4.notifyMeshTransformChanged({ action: a$9.DisableFastUpdates });
}
function a$6(e4) {
  return "mesh" === e4?.type && !e4.vertexSpace.isGeoreferenced;
}
const d$1 = 0.3;
function u$4(o2, t3) {
  t3 && Object.assign(o2, t3);
}
let g$1 = class g {
  constructor(o2) {
    this.height = 90, this.coneHeight = 40, this.coneWidth = 23, this.width = 3, this.renderOccluded = d$4.Opaque, this.color = o2.accent;
  }
};
let f$2 = class f {
  constructor({ colors: o2, ...t3 }) {
    this.size = 11, this.outlineSize = 1, this.collisionPadding = 9, this.color = o2.accent, this.outlineColor = o2.outline, this.renderOccluded = d$4.Opaque, this.hoverOutlineColor = o2.selectedOutline, u$4(this, t3);
  }
  applyColor(o2) {
    this._apply(this.color, o2);
  }
  applyOutline(o2) {
    this._apply(this.outlineColor, o2);
  }
  applyHoverOutline(o2) {
    this._apply(this.hoverOutlineColor, o2);
  }
  _apply(o2, t3) {
    t3.setParameters({ color: E$2(o2), renderOccluded: this.renderOccluded });
  }
};
let w$1 = class w {
  constructor({ colors: o2, ...t3 }) {
    this.size = 40, this.height = 0.2, this.offset = 0.25, this.collisionPadding = 2, this.renderOccluded = d$4.Transparent, this.minSquaredEdgeLength = 900, this.color = R$3(o2.accent, 0.5), this.hoverColor = o2.accent, u$4(this, t3);
  }
  applyColor(o2) {
    this._apply(this.color, o2);
  }
  applyHover(o2) {
    this._apply(this.hoverColor, o2);
  }
  _apply(o2, t3) {
    t3.setParameters({ color: E$2(o2), renderOccluded: this.renderOccluded });
  }
};
let C$4 = class C {
  constructor(o2) {
    this.vertex = new f$2({ colors: o2, color: o2.accent, outlineColor: o2.outline }), this.edge = new f$2({ colors: o2, color: U$3(R$3(o2.accent, 2 / 3), 0.5), outlineColor: R$3(o2.outline, 0.5), size: 8, collisionPadding: 8 }), this.selected = new f$2({ colors: o2, color: o2.selected, outlineColor: o2.outline }), this.edgeOffset = new w$1({ colors: o2 });
  }
};
let m$3 = class m {
  constructor({ colors: o2, ...t3 }) {
    this.width = 1.5, this.stipplePattern = h$4(3.3), this.falloff = 0, this.innerWidth = 1.5, this.renderOccluded = d$4.OccludeAndTransparent, this.color = o2.selected, this.stippleOffColor = o2.outline, this.innerColor = o2.selected, u$4(this, t3);
  }
  apply(o2) {
    o2.color = E$2(this.color), o2.width = this.width, o2.stipplePattern = this.stipplePattern, o2.stippleOffColor = E$2(this.stippleOffColor), o2.falloff = this.falloff, o2.innerWidth = this.innerWidth, o2.innerColor = E$2(this.innerColor), o2.renderOccluded = this.renderOccluded;
  }
};
class O2 {
  constructor({ colors: o2, ...t3 }) {
    this.size = 4, this.outlineSize = 1, this.shape = "square", this.color = o2.selected, this.outlineColor = o2.outline, u$4(this, t3);
  }
  apply(o2) {
    o2.color = E$2(this.color), o2.size = this.size, o2.outlineSize = this.outlineSize, o2.outlineColor = E$2(this.outlineColor), o2.primitive = this.shape;
  }
}
class y {
  constructor({ colors: o2, ...t3 }) {
    this.innerWidth = 1, this.glowWidth = 8, this.glowFalloff = 8, this.globalAlpha = d$1, this.globalAlphaContrastBoost = 1.5, this.radius = 3, this.innerColor = o2.selected, this.glowColor = o2.accent, this.heightFillColor = o2.accent, u$4(this, t3);
  }
  apply(o2, e4 = 1) {
    const l2 = { glowColor: u$5.toUnitRGB(this.glowColor), glowFalloff: this.glowFalloff, glowWidth: this.glowWidth, innerColor: u$5.toUnitRGB(this.innerColor), innerWidth: this.innerWidth, globalAlpha: this.globalAlpha * e4 * this.glowColor.a, globalAlphaContrastBoost: this.globalAlphaContrastBoost, intersectsLineRadius: this.radius };
    "style" in o2 ? o2.style = l2 : o2.laserlineStyle = l2;
  }
}
let A$4 = class A {
  constructor(o2) {
    this.outline = new m$3({ colors: o2, color: o2.stippleOff, renderOccluded: d$4.OccludeAndTransparentStencil, stippleOffColor: o2.stippleOn, innerWidth: 0 }), this.staged = new m$3({ colors: o2, color: o2.stippleOn, renderOccluded: d$4.OccludeAndTransparentStencil, innerColor: o2.stagedSolid, stippleOffColor: o2.stippleOff }), this.shadowStyle = new y({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 8, glowWidth: 8, innerColor: o2.selected, innerWidth: 1 });
  }
};
class W {
  constructor(o2) {
    this.outline = new O2({ colors: o2, color: o2.selected, outlineColor: o2.outline, outlineSize: 1, shape: "circle", size: 4 }), this.shadowStyle = new y({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 1.5, glowWidth: 6, innerColor: o2.selected, innerWidth: 1, radius: 2 });
  }
}
let S$2 = class S extends m$3 {
  constructor({ colors: o2, ...t3 }) {
    super({ colors: o2 }), this.extensionType = V$3.GROUND_RAY, u$4(this, t3);
  }
};
let b$2 = class b {
  constructor(o2) {
    this.laserlineAlphaMultiplier = 1.5, this.heightPlaneAngleCutoff = 20, this.lineGraphics = new A$4(o2), this.pointGraphics = new W(o2), this.heightPlane = new y({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 8, glowWidth: 8, innerColor: o2.selected, innerWidth: 1 }), this.heightBox = new y({ colors: o2, globalAlpha: d$1, glowColor: o2.accent, glowFalloff: 8, glowWidth: 8, innerColor: o2.selected, innerWidth: 0, heightFillColor: o2.accent }), this.zVerticalLine = new S$2({ colors: o2, color: R$3(o2.accent, 5 * d$1 / 3), falloff: 2, innerColor: R$3(o2.selected, 0), renderOccluded: d$4.OccludeAndTransparent, stipplePattern: null, width: 5, extensionType: V$3.GROUND_RAY });
  }
};
let z$1 = class z extends g$2 {
  constructor(o2) {
    super(o2);
  }
  get colors() {
    const o2 = this.getTheme().accentColor, e4 = o2.a;
    return { accent: o2, contrast: G$3(o2), selected: u$5.fromArray([255, 255, 255, e4]), selectedOutline: u$5.fromArray([255, 255, 255, e4]), staged: u$5.fromArray([12, 207, 255, e4]), stagedSolid: u$5.fromArray([12, 207, 255, 1]), outline: u$5.fromArray([0, 0, 0, 0.5 * e4]), stippleOn: u$5.fromArray([255, 255, 255, 1]), stippleOff: u$5.fromArray([0, 0, 0, 0.5]) };
  }
  get visualElements() {
    return new b$2(this.colors);
  }
  get manipulators() {
    return new C$4(this.colors);
  }
  get zManipulator() {
    return new g$1(this.colors);
  }
};
e$4([y$1()], z$1.prototype, "colors", null), e$4([y$1()], z$1.prototype, "visualElements", null), e$4([y$1()], z$1.prototype, "manipulators", null), e$4([y$1()], z$1.prototype, "zManipulator", null), e$4([y$1()], z$1.prototype, "getTheme", void 0), z$1 = e$4([c$5("esri.views.3d.interactive.editingTools.settings.Settings")], z$1);
class w2 extends t$3 {
  constructor(t3) {
    super(t3), this._attachmentOrigin = e$7(0, 0, 0, null), this._attachmentOriginDirty = true, this.events = new o$4(), this._geometry = null, this._width = 1, this._color = r$6(1, 0, 1, 1), this._innerWidth = 0, this._innerColor = r$6(1, 1, 1, 1), this._stipplePattern = null, this._stippleOffColor = null, this._falloff = 0, this._elevationInfo = null, this._laserlineStyle = null, this._laserlineEnabled = false, this._renderOccluded = d$4.OccludeAndTransparentStencil, this._attachmentOrigin.spatialReference = t3.view.spatialReference, this._laserline = new c$6({ view: t3.view, isDecoration: t3.isDecoration }), this.applyProperties(t3), this.attached = t3.attached ?? true;
  }
  destroy() {
    this._laserline.destroy(), super.destroy();
  }
  createObject3DResourceFactory(e4) {
    return { view: e4, createResources: (e5) => this._createObject3DResources(e5), destroyResources: (e5) => this._destroyExternalResources(e5), recreateGeometry: (e5, t3) => {
      e5.geometries.length = 0, this._recreateGeometry(t3, e5.material, e5.geometries);
    } };
  }
  createDrapedResourceFactory(e4) {
    return { view: e4, createResources: () => this._createDrapedResources(), destroyResources: (e5) => this._destroyExternalResources(e5), recreateGeometry: (e5) => {
      e5.geometries = this._createRenderGeometriesDraped(e5.material), this._attachmentOriginChanged();
    } };
  }
  get _laserlineAttached() {
    return this.attached && this.visible && null != this._laserlineStyle && !this.isDraped && this.laserlineEnabled;
  }
  onAttachedChange(e4) {
    this._laserline.attached = this._laserlineAttached, e4 && this._attachmentOriginChanged();
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e4) {
    this._geometry = e4, this.recreateGeometry();
  }
  get width() {
    return this._width;
  }
  set width(e4) {
    e4 !== this._width && (this._width = e4, this._updateMaterial());
  }
  get color() {
    return this._color;
  }
  set color(e4) {
    D$3(e4, this._color) || (a$a(this._color, e4), this._updateMaterial());
  }
  get innerWidth() {
    return this._innerWidth;
  }
  set innerWidth(e4) {
    e4 !== this._innerWidth && (this._innerWidth = e4, this._updateMaterial());
  }
  get innerColor() {
    return this._innerColor;
  }
  set innerColor(e4) {
    D$3(e4, this._innerColor) || (a$a(this._innerColor, e4), this._updateMaterial());
  }
  get stipplePattern() {
    return this._stipplePattern;
  }
  set stipplePattern(e4) {
    const t3 = null != e4 != (null != this._stipplePattern);
    this._stipplePattern = e4, t3 ? this.recreate() : this._updateMaterial();
  }
  get stippleOffColor() {
    return this._stippleOffColor;
  }
  set stippleOffColor(e4) {
    e4 && this._stippleOffColor && D$3(e4, this._stippleOffColor) || (this._stippleOffColor = e4 ? t$4(e4) : null, this._updateMaterial());
  }
  get falloff() {
    return this._falloff;
  }
  set falloff(e4) {
    e4 !== this._falloff && (this._falloff = e4, this._updateMaterial());
  }
  get elevationInfo() {
    return this._elevationInfo;
  }
  set elevationInfo(e4) {
    this._elevationInfo = e4, this.recreateGeometry();
  }
  get laserlineStyle() {
    return this._laserlineStyle;
  }
  set laserlineStyle(e4) {
    this._laserlineStyle = e4, this._laserline.attached = this._laserlineAttached, null != e4 && (this._laserline.style = e4);
  }
  get laserlineEnabled() {
    return this._laserlineEnabled;
  }
  set laserlineEnabled(e4) {
    this._laserlineEnabled !== e4 && (this._laserlineEnabled = e4, this._laserline.attached = this._laserlineAttached);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e4) {
    e4 !== this._renderOccluded && (this._renderOccluded = e4, this._updateMaterial());
  }
  get attachmentOrigin() {
    if (!this._attachmentOriginDirty)
      return this._attachmentOrigin;
    const e4 = this.object3dResources.resources?.geometries;
    if (!e4 || 0 === e4.length)
      return null;
    o$5(P$2, 0, 0, 0);
    let s2 = 0;
    for (const t3 of e4)
      t3.computeAttachmentOrigin(D$1) && (u$6(P$2, P$2, D$1), s2++);
    return 0 === s2 ? null : (g$3(P$2, P$2, 1 / s2), this.view.renderCoordsHelper.fromRenderCoords(P$2, this._attachmentOrigin), this._attachmentOriginDirty = false, this._attachmentOrigin);
  }
  _updateMaterial() {
    null != this.object3dResources.resources && this.object3dResources.resources.material.setParameters(this._materialParameters), null != this.drapedResources.resources && this.drapedResources.resources.material.setParameters(this._materialParameters);
  }
  get _isClosed() {
    return null != this.geometry && "polygon" === this.geometry.type;
  }
  get _materialParameters() {
    return { width: this._width, color: this._color, stippleOffColor: this._stippleOffColor, stipplePattern: this._stipplePattern, stipplePreferContinuous: false, isClosed: this._isClosed, falloff: this._falloff, innerColor: this._innerColor, innerWidth: this._innerWidth, join: "round", hasPolygonOffset: true, renderOccluded: this._normalizedRenderOccluded, isDecoration: this.isDecoration };
  }
  get _normalizedRenderOccluded() {
    return this.isDraped && this._renderOccluded === d$4.OccludeAndTransparentStencil ? d$4.OccludeAndTransparent : this._renderOccluded;
  }
  _recreateGeometry(e4, t3, r3) {
    this._createRenderGeometries(t3, r3);
    for (const i2 of r3)
      e4.addGeometry(i2);
    this._attachmentOriginChanged();
  }
  _attachmentOriginChanged() {
    this._attachmentOriginDirty = true, this.events.emit("attachment-origin-changed");
  }
  _destroyExternalResources(e4) {
    e4.geometries = [];
  }
  _createObject3DResources(e4) {
    const t3 = new x$4(this._materialParameters), r3 = new Array();
    return this._recreateGeometry(e4, t3, r3), { material: t3, geometries: r3, forEach: (e5) => {
      e5(t3), r3.forEach(e5);
    } };
  }
  _createDrapedResources() {
    const e4 = new x$4(this._materialParameters);
    return { material: e4, geometries: this._createRenderGeometriesDraped(e4) };
  }
  _createRenderGeometriesDraped(e4) {
    const { geometry: t3, view: r3 } = this, i2 = r3.basemapTerrain.spatialReference;
    if (null == t3 || null == i2)
      return [];
    return l$4(t3, i2).lines.map(({ position: t4 }) => {
      const s2 = { overlayInfo: { spatialReference: i2, renderCoordsHelper: r3.renderCoordsHelper }, attributeData: { position: t4 }, removeDuplicateStartEnd: this._isClosed };
      return new h$5(b$4(e4, s2));
    });
  }
  calculateMapBounds(e4) {
    if (null == this.object3dResources.resources)
      return false;
    const t3 = this.view.renderCoordsHelper;
    for (const r3 of this.object3dResources.resources.geometries) {
      const i2 = r3.attributes.get(e$8.POSITION), s2 = t$5(i2.data.length);
      n$5(i2.data, t3.spatialReference, 0, s2, this.view.spatialReference, 0, i2.data.length / 3), c$7(e4, s2);
    }
    return true;
  }
  _createRenderGeometries(e4, t3) {
    const r3 = this.geometry;
    if (null == r3)
      return;
    const i2 = p$4(r3, this.view.elevationProvider, this.view.renderCoordsHelper, o$6.fromElevationInfo(this.elevationInfo ?? new h$6({ mode: r$4(r3, null) }))), s2 = new Array();
    for (const { position: n2, mapPositions: o2 } of i2.lines) {
      const r4 = { mapPositions: o2, attributeData: { position: n2 }, removeDuplicateStartEnd: this._isClosed };
      t3.push(b$4(e4, r4)), s2.push(n2);
    }
    this._laserline.pathVerticalPlane = s2;
  }
}
const D$1 = n$4(), P$2 = n$4();
let e$3 = class e extends o$4.EventedAccessor {
  constructor(r3) {
    super(r3), this.tracking = false, this.displaying = false, this.isDraped = false;
  }
};
e$4([y$1({ constructOnly: true })], e$3.prototype, "graphic", void 0), e$4([y$1()], e$3.prototype, "tracking", void 0), e$4([y$1()], e$3.prototype, "displaying", void 0), e$4([y$1()], e$3.prototype, "isDraped", void 0), e$3 = e$4([c$5("esri.views.3d.layers.graphics.GraphicState")], e$3);
function i$3(r3, i2) {
  const f3 = r3?.geometry;
  if (!r3 || "mesh" !== f3?.type || !i2)
    return;
  const { renderCoordsHelper: h2, elevationProvider: p4 } = i2, { camera: l2 } = i2.state, { extent: d2 } = f3, { center: v2, spatialReference: x2 } = d2, g3 = z$2(x2), j2 = W$1(x2), z3 = z$2(h2.spatialReference), y2 = d2.width * g3, C5 = d2.height * j2, R2 = (d2.zmax ?? 0) * j2, U2 = R2 - (d2.zmin ?? 0) * j2, k2 = Math.max(y2, C5, U2) / z3, { x: w3, y: P2 } = v2, S3 = v2.z ?? 0;
  o$5(u$3, w3, P2, S3), h2.toRenderCoords(u$3, x2, u$3);
  const T3 = k2 / l2.computeScreenPixelSizeAt(u$3);
  if (T3 > l2.width * c$3)
    return "meshTooClose";
  if (T3 < m$2)
    return "meshTooFar";
  const b3 = s$5(r3), { absoluteZ: A3 } = g$4(w3, P2, R2, x2, i2, b3);
  return A3 < (p4.getElevation(w3, P2, S3, x2, "ground") ?? 0) * j2 + U2 * a$5 ? "meshUnderground" : "mesh";
}
const m$2 = 20, c$3 = 1, a$5 = 0.1, u$3 = n$4();
let z2 = class extends K {
  constructor(e4) {
    super(e4), this._activeVertexVisualElement = null, this._createGraphicState = null, this._outlineVisualElement = null, this._verticesVisualElement = null, this._verticalLineVisualElement = null, this._settings = new z$1({ getTheme: () => this.view.effectiveTheme }), this.geometryType = null, this.type = "draw-3d";
  }
  initialize() {
    const { mode: e4, offset: t3 } = this.elevationInfo;
    this.internalGraphicsLayer.elevationInfo = new h$6({ mode: e4, offset: t3 });
  }
  normalizeCtorArgs(e4) {
    if (!e4.elevationInfo) {
      const t3 = e4.hasZ ?? true;
      return { ...e4, elevationInfo: o$7(t3) };
    }
    return e4;
  }
  initializeGraphic(e4) {
    const { view: t3 } = this, r3 = this._createGraphicState = new e$3({ graphic: e4 });
    return t$6([t3.maskOccludee(e4), t3.trackGraphicState(r3), d$3(() => ({ element: this._outlineVisualElement, isDraped: r3.isDraped }), ({ element: e5, isDraped: t4 }) => {
      e5 && (e5.isDraped = t4);
    }, A$7), this._setupLoadingIndicator(r3), ...o$3(r3)]);
  }
  updateDrawMeshTooltipInfo(e4) {
    const { graphic: t3, tooltipOptions: i2, view: r3 } = this;
    e4.tooltipOptions = i2, e4.viewType = r3.type, e4.helpMessage = i$3(t3, this.view), this.updateElevation(e4.elevation);
  }
  makeDrawOperation() {
    const { geometryType: e4 } = this, t3 = "circle" !== e4 && "rectangle" !== e4;
    return new k$2({ view: this.view, manipulators: this.manipulators, geometryType: X(e4), drawingMode: this.mode, hasZ: this.hasZ, defaultZ: this.defaultZ, snapToSceneEnabled: this.snapToScene, drawSurface: new o$8(this.view, this.elevationInfo, [this.internalGraphicsLayer]), elevationDrawSurface: new r$7(this.elevationInfo, this.defaultZ, this.view, this.internalGraphicsLayer), hasM: false, elevationInfo: this.elevationInfo, snappingManager: this.snappingManager, snappingVisualizer: new O$2(), segmentLabels: t3 ? new a$7() : null, labelOptions: this.labelOptions, tooltipOptions: this.tooltipOptions, isDraped: this._createGraphicState ? this._createGraphicState.isDraped : "on-the-ground" === t$7(this.hasZ, this.elevationInfo), cursor: this.cursor });
  }
  onActiveVertexChanged(e4) {
    const { view: n2 } = this;
    if (this._activeVertexVisualElement)
      return this._activeVertexVisualElement.vertices = [e4], this._updateVerticalLineVisualElement(e4), e$5();
    const a4 = this._settings, c2 = a4.manipulators.vertex, p4 = new d$5({ view: n2, spatialReference: n2.spatialReference, vertices: [e4], elevationInfo: this.internalGraphicsLayer.elevationInfo, size: c2.size, outlineSize: c2.outlineSize, renderOccluded: c2.renderOccluded, attached: false, isDecoration: true });
    this._activeVertexVisualElement = p4;
    const h2 = a4.visualElements.zVerticalLine, m3 = new G$5({ view: n2, extensionType: h2.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: d$4.OccludeAndTransparent, isDecoration: true });
    this._verticalLineVisualElement = m3;
    const u3 = t$6([d$3(() => a4.visualElements.zVerticalLine, (e5) => e5.apply(m3), P$4), d$3(() => ({ selectedColor: E$2(a4.colors.selected), outlineColor: E$2(a4.manipulators.vertex.outlineColor) }), ({ selectedColor: e5, outlineColor: t3 }) => {
      p4.color = e5, p4.outlineColor = t3;
    }, P$4), e$5(() => {
      this._activeVertexVisualElement = u$7(this._activeVertexVisualElement), this._verticalLineVisualElement = u$7(this._verticalLineVisualElement);
    })]);
    return p4.attached = true, u3;
  }
  _updateVerticalLineVisualElement(e4) {
    const t3 = this._verticalLineVisualElement;
    if (!t3)
      return;
    const { renderCoordsHelper: i2, elevationProvider: r3 } = this.view;
    o$5(M$4, e4[0], e4[1], e4[2]), b$1.setFromElevationInfo(this.elevationInfo), M$4[2] = f$5(M$4, r3, b$1, i2);
    i2.toRenderCoords(M$4, this.view.spatialReference, M$4) ? (t3.setStartEndFromWorldDownAtLocation(M$4), t3.attached = true) : t3.attached = false;
  }
  onOutlineChanged(e4) {
    if (this._outlineVisualElement)
      return this._outlineVisualElement.geometry = e4, e$5();
    const t3 = this.internalGraphicsLayer.elevationInfo, { view: n2 } = this, a4 = this._settings, c2 = new w2({ view: n2, geometry: e4, elevationInfo: t3, isDraped: this._createGraphicState ? this._createGraphicState.isDraped : "on-the-ground" === t$7(this.hasZ, t3), attached: false, isDecoration: true });
    this._outlineVisualElement = c2;
    const p4 = t$6([d$3(() => a4.visualElements.lineGraphics.outline, (e5) => e5.apply(c2), P$4), d$3(() => a4.visualElements.lineGraphics.shadowStyle, (e5) => e5.apply(c2), P$4), e$5(() => {
      this._outlineVisualElement = u$7(this._outlineVisualElement);
    })]);
    return c2.attached = true, c2.laserlineEnabled = true, p4;
  }
  onRegularVerticesChanged(e4) {
    if (this._verticesVisualElement)
      return this._verticesVisualElement.vertices = e4, e$5();
    const { view: n2 } = this, a4 = this._settings, c2 = a4.manipulators.vertex, p4 = new d$5({ view: n2, spatialReference: n2.spatialReference, vertices: e4, elevationInfo: this.internalGraphicsLayer.elevationInfo, size: c2.size, outlineSize: c2.outlineSize, renderOccluded: c2.renderOccluded, attached: false, isDecoration: true }), h2 = t$6([d$3(() => ({ color: E$2(a4.manipulators.vertex.color), outlineColor: E$2(a4.manipulators.vertex.outlineColor) }), ({ color: e5, outlineColor: t3 }) => {
      p4.color = e5, p4.outlineColor = t3;
    }, P$4), e$5(() => {
      this._verticesVisualElement = u$7(this._verticesVisualElement);
    })]);
    return p4.attached = true, this._verticesVisualElement = p4, h2;
  }
  updateGraphicGeometry(e4, t3) {
    if ("mesh" === this.geometryType && "point" === t3?.type) {
      const i2 = this.geometryToPlace;
      return i2 && i2.centerAt(t3), void (i2 && e4.geometry === i2 ? i2.vertexSpace.isGeoreferenced ? e4.notifyGeometryChanged() : e4.notifyMeshTransformChanged() : e4.geometry = i2);
    }
    super.updateGraphicGeometry(e4, t3);
  }
  _setupLoadingIndicator(e4) {
    const { drawOperation: t3 } = this;
    if (!this.geometryToPlace)
      return t3.loading = false, null;
    t3.loading = true;
    const s2 = e$5(() => {
      t3.loading = false;
    });
    let o2;
    const l2 = () => o2 && cancelAnimationFrame(o2);
    return t$6([p$5(() => e4.displaying, () => {
      l2(), o2 = requestAnimationFrame(() => s2.remove());
    }, { ...A$7, once: true }), e$5(l2), s2]);
  }
};
e$4([y$1({ constructOnly: true })], z2.prototype, "elevationInfo", void 0), e$4([y$1({ constructOnly: true })], z2.prototype, "geometryType", void 0), e$4([y$1()], z2.prototype, "type", void 0), e$4([y$1({ constructOnly: true })], z2.prototype, "view", void 0), z2 = e$4([c$5("esri.views.3d.interactive.editingTools.draw.DrawGraphicTool3D")], z2);
const b$1 = new o$6(), M$4 = n$4();
function o$2(n2) {
  const o2 = r$3(n2);
  return r$8(Math.cos(o2), Math.sin(o2));
}
function r$3(t3) {
  if (null == t3 || "polyline" !== t3.type && "polygon" !== t3.type)
    return 0;
  const o2 = "polyline" === t3.type ? t3.paths : t3.rings;
  for (const r3 of o2)
    for (let t4 = 0; t4 < r3.length - 1; t4++) {
      const o3 = r3[t4], e4 = r3[t4 + 1], s2 = o3[0] - e4[0], p4 = o3[1] - e4[1];
      if (s2 * s2 + p4 * p4 > et)
        return Math.atan2(e4[1] - o3[1], e4[0] - o3[0]);
    }
  return 0;
}
var N$1;
!function(N2) {
  N2[N2.NONE = 0] = "NONE", N2[N2.ANY = 1] = "ANY", N2[N2.Z = 2] = "Z", N2[N2.XY = 4] = "XY";
}(N$1 || (N$1 = {}));
var A$3;
!function(A3) {
  A3[A3.TRANSLATE_Z = 0] = "TRANSLATE_Z", A3[A3.TRANSLATE_XY = 1] = "TRANSLATE_XY", A3[A3.SCALE = 2] = "SCALE", A3[A3.ROTATE = 3] = "ROTATE", A3[A3.SCALE_ROTATE = 4] = "SCALE_ROTATE";
}(A$3 || (A$3 = {}));
let a$4 = class a2 {
  constructor() {
    this.grabbingState = N$1.NONE, this.zManipulator = null, this.firstSelected = null, this.numSelected = 0, this.firstGrabbedXY = null;
  }
  update(a4) {
    this.grabbingState = N$1.NONE, this.zManipulator = null, this.numSelected = 0, this.firstSelected = null, this.firstGrabbedXY = null, a4.forEachManipulator((a5, s2) => {
      if (s2 === A$3.TRANSLATE_Z && (this.zManipulator = a5), a5 instanceof $ && (a5.selected && (0 === this.numSelected && (this.firstSelected = a5), this.numSelected++), null == this.firstGrabbedXY && a5.grabbing && s2 === A$3.TRANSLATE_XY && (this.firstGrabbedXY = a5)), a5.grabbing)
        switch (this.grabbingState |= N$1.ANY, s2) {
          case A$3.TRANSLATE_Z:
            this.grabbingState |= N$1.Z;
            break;
          case A$3.TRANSLATE_XY:
            this.grabbingState |= N$1.XY;
        }
    });
  }
};
function j$3(t3) {
  const { view: a4, graphic: n2 } = t3, i2 = new e$3({ graphic: n2 }), l2 = M$3(t3, i2), o2 = [l2, T$2(t3, l2.visualElement, i2), a4.maskOccludee(n2), a4.trackGraphicState(i2)];
  return { visualElement: l2.visualElement, remove: () => r$9(o2) };
}
function M$3(e4, n2) {
  const { view: i2, graphic: r3 } = e4, s2 = new w2({ view: i2, geometry: L$2(r3) ? r3.geometry : null, elevationInfo: s$5(r3), attached: false, isDecoration: true }), p4 = new z$1({ getTheme: () => i2.effectiveTheme }), c2 = () => {
    s2.attached = n2.displaying;
  }, h2 = t$6([d$3(() => p4.visualElements.lineGraphics.outline, (e5) => e5.apply(s2), P$4), d$3(() => p4.visualElements.lineGraphics.shadowStyle, (e5) => e5.apply(s2), P$4), d$3(() => n2.displaying, c2), d$3(() => n2.isDraped, (e5) => {
    s2.isDraped = e5;
  }), n2.on("changed", () => s2.geometry = L$2(r3) ? r3.geometry : null), c$8(s2)]);
  return c2(), { visualElement: s2, remove: () => h2.remove() };
}
function T$2(s2, p4, c2) {
  const { graphic: h2, view: u3 } = s2, f3 = [], w3 = s$5(h2), S3 = "on-the-ground" === w3.mode || !w3.offset && "absolute-height" !== w3.mode, j2 = new a$4(), M2 = new z$1({ getTheme: () => u3.effectiveTheme }), T3 = M2.visualElements, A3 = new G$5({ view: u3, extensionType: T3.zVerticalLine.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: d$4.OccludeAndTransparent, isDecoration: true }), C5 = M$5(T3.heightPlaneAngleCutoff), O3 = new c$6({ view: u3, attached: false, angleCutoff: C5, isDecoration: true }), V2 = r$a(1);
  f3.push(d$3(() => ({ lineShadowStyle: M2.visualElements.lineGraphics.shadowStyle, pointShadowStyle: M2.visualElements.pointGraphics.shadowStyle, alpha: V2.value }), ({ lineShadowStyle: e4, pointShadowStyle: t3, alpha: a4 }) => {
    e4.apply(p4, a4), t3.apply(A3, a4);
  }, P$4));
  const k2 = r$a(1);
  f3.push(d$3(() => ({ heightPlane: M2.visualElements.heightPlane, alpha: k2.value }), ({ heightPlane: e4, alpha: t3 }) => e4.apply(O3, t3), P$4));
  const x2 = () => {
    if (j2.update(s2), !c2.displaying || S3 && (c2.isDraped || !L$2(h2) || !h2.geometry.hasZ))
      return p4.laserlineEnabled = false, A3.attached = false, void (O3.attached = false);
    p4.laserlineEnabled = true;
    const e4 = j2.grabbingState & N$1.XY ? T3.laserlineAlphaMultiplier : 1;
    V2.value = e4;
    const t3 = j2.grabbingState & N$1.Z ? T3.laserlineAlphaMultiplier : 1;
    k2.value = t3, D(A3, j2), G$1(s2, p4, O3, j2);
  };
  f3.push(d$3(() => M2.visualElements.zVerticalLine, (e4) => e4.apply(A3), P$4)), f3.push(c2.on("changed", x2), d$3(() => c2.displaying, x2), p4.events.on("attachment-origin-changed", x2), c$8(A3), c$8(O3));
  const P2 = [], U2 = () => {
    r$9(P2), P2.length = 0, s2.forEachManipulator((e4) => P2.push(e4.events.on("grab-changed", x2))), s2.forEachManipulator((e4) => P2.push(e4.events.on("select-changed", x2))), x2();
  };
  return U2(), f3.push(s2.onManipulatorsChanged(U2), o$9(() => t$6(P2))), t$6(f3);
}
function D(e4, t3) {
  const a4 = 1 === t3.numSelected ? t3.firstSelected : t3.numSelected > 1 && null != t3.firstGrabbedXY ? t3.firstGrabbedXY : null;
  null != a4 ? (e4.setStartEndFromWorldDownAtLocation(a4.renderLocation), e4.attached = true) : e4.attached = false;
}
function G$1(e4, t3, a4, n2) {
  if (n2.numSelected > 0) {
    o$5(A$2, 0, 0, 0);
    let t4 = 0;
    e4.forEachManipulator((e5, a5) => {
      a5 === A$3.TRANSLATE_XY && e5.selected && e5 instanceof $ && (u$6(A$2, A$2, e5.renderLocation), t4++);
    }), t4 > 0 ? (a4.heightManifoldTarget = g$3(A$2, A$2, 1 / t4), a4.attached = true) : a4.attached = false;
  } else {
    const n3 = t3.attachmentOrigin;
    null != n3 && e4.view.renderCoordsHelper.toRenderCoords(n3, A$2) ? (a4.heightManifoldTarget = A$2, a4.attached = true) : a4.attached = false;
  }
}
function L$2(e4) {
  return null != e4.geometry && ("polygon" === e4.geometry.type || "polyline" === e4.geometry.type);
}
const A$2 = n$4();
function P$1(t3) {
  const { view: n2, graphic: o2 } = t3, i2 = new e$3({ graphic: o2 }), a4 = [], r3 = V$1(t3, i2, a4);
  return x$2(t3, i2, a4, r3), a4.push(n2.trackGraphicState(i2)), { visualElement: r3, remove: () => r$9(a4) };
}
function x$2(e4, n2, l2, p4) {
  const { view: m3, graphic: d2 } = e4, E2 = new z$1({ getTheme: () => m3.effectiveTheme }), T3 = new G$5({ view: m3, extensionType: E2.visualElements.zVerticalLine.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: d$4.OccludeAndTransparent, isDecoration: true });
  l2.push(d$3(() => E2.visualElements.zVerticalLine, (e5) => e5.apply(T3), P$4));
  const P2 = new c$6({ view: m3, intersectsLineInfinite: true, attached: false, isDecoration: true }), x2 = M$5(E2.visualElements.heightPlaneAngleCutoff), V2 = new c$6({ view: m3, attached: false, angleCutoff: x2, isDecoration: true }), L2 = s$5(e4.graphic), M2 = o$6.fromElevationInfo(L2), C5 = "on-the-ground" === L2.mode || !L2.offset && "absolute-height" !== L2.mode, G2 = new a$4(), B2 = r$a(1);
  l2.push(d$3(() => ({ heightPlane: E2.visualElements.heightPlane, alpha: B2.value }), ({ heightPlane: e5, alpha: t3 }) => e5.apply(V2, t3), P$4));
  const I2 = r$a(1);
  l2.push(d$3(() => ({ shadowStyle: E2.visualElements.pointGraphics.shadowStyle, alpha: I2.value }), ({ shadowStyle: e5, alpha: t3 }) => e5.apply(P2, t3), P$4));
  const k2 = () => {
    G2.update(e4);
    const t3 = A$1(d2), o2 = C5 && (n2.isDraped || null == t3 || !t3.hasZ);
    let i2 = true;
    if (o2 || null == t3)
      i2 = false;
    else {
      const e5 = f$5(t3, m3.elevationProvider, M2, m3.renderCoordsHelper);
      o$5(R$2, t3.x, t3.y, e5), t$8(R$2, t3.spatialReference, R$2, m3.renderCoordsHelper.spatialReference), T3.setStartEndFromWorldDownAtLocation(R$2), P2.intersectsWorldUpAtLocation = R$2;
    }
    const a4 = G2.grabbingState & N$1.Z ? E2.visualElements.laserlineAlphaMultiplier : 1;
    B2.value = a4;
    const r3 = P$5(U$2);
    !o2 && n2.displaying && p4.calculateMapBounds(r3) && t$8(R$4(r3, R$2), m3.spatialReference, R$2, m3.renderCoordsHelper.spatialReference) ? (V2.heightManifoldTarget = R$2, V2.attached = true) : V2.attached = false;
    const l3 = G2.grabbingState & N$1.XY ? E2.visualElements.laserlineAlphaMultiplier : 1;
    I2.value = l3;
    const f3 = i2 && n2.displaying && !o2;
    P2.attached = f3, T3.attached = f3;
  };
  l2.push(d$3(() => [n2.displaying, n2.isDraped], k2), n2.on("changed", k2)), e4.forEachManipulator((e5) => {
    l2.push(e5.events.on("grab-changed", k2));
  }), l2.push(c$8(P2)), l2.push(c$8(T3)), l2.push(c$8(V2)), k2();
}
function V$1(e4, n2, o2) {
  const { view: i2, graphic: a4 } = e4, r3 = new x$5({ view: i2, geometry: A$1(a4), elevationInfo: s$5(a4), isDecoration: true });
  return L$1(e4, r3, n2, o2), o2.push(c$8(r3)), r3;
}
function A$1(e4) {
  const t3 = e4.geometry;
  return null == t3 ? null : "point" === t3.type ? t3 : "mesh" === t3.type ? t3.anchor.clone() : null;
}
function L$1(e4, t3, n2, o2) {
  const r3 = () => {
    t3.attached = n2.displaying;
  }, s2 = new z$1({ getTheme: () => e4.view.effectiveTheme });
  M$2(e4, t3, n2, o2), s2.visualElements.pointGraphics.outline.apply(t3), o2.push(d$3(() => n2.displaying, r3, P$4));
}
function M$2(e4, t3, o2, i2) {
  const { view: a4, graphic: r3 } = e4;
  let s2 = null;
  const l2 = (e5) => {
    null != s2 && (s2.remove(), s2 = null), o2.isDraped && null != e5 && (s2 = C$3(a4, e5, () => {
      t3.geometry = e5;
    }));
  }, p4 = () => {
    const e5 = A$1(r3);
    l2(e5), t3.geometry = e5;
  };
  i2.push(o2.on("changed", p4), o$9(() => s2)), p4();
}
function C$3(e4, t3, n2) {
  const o2 = e4.elevationProvider.spatialReference;
  e$9(t3, R$2, o2);
  const i2 = R$2[0], a4 = R$2[1];
  return e4.elevationProvider.on("elevation-change", (e5) => {
    w$3(e5.extent, i2, a4) && n2();
  });
}
const R$2 = n$4(), U$2 = i$6();
function i$2(i2) {
  switch (i2.graphic.geometry.type) {
    case "point":
    case "mesh":
      return P$1(i2);
    case "polygon":
    case "polyline":
      return j$3(i2);
    default:
      return null;
  }
}
const t$2 = 128, a$3 = 70, e$2 = 80, h$3 = 0.02, M$1 = 54, c$2 = 100, o$1 = Math.ceil(a$3 / 3 * 2), I = 160, P = 0.5, i$1 = 24, l$1 = 9, n$2 = I + 30, p$3 = I + 53, r$2 = 60, s$1 = 23, x$1 = 5 * Math.PI / 12, b2 = 1 * Math.PI / 3, d = 10, f$1 = 0.2, g2 = 30, j$2 = 53, k$1 = 0.2, m$1 = 0.3, q$1 = 200, u$2 = 3, v$1 = 1e6;
let t$1 = class t {
  constructor() {
    this._available = true;
  }
  set location(a4) {
    this._forEachManipulator3D((t3) => t3.location = a4);
  }
  set elevationAlignedLocation(a4) {
    this._forEachManipulator3D((t3) => t3.elevationAlignedLocation = a4);
  }
  set elevationInfo(a4) {
    this._forEachManipulator3D((t3) => t3.elevationInfo = a4);
  }
  get renderLocation() {
    let a4;
    return this._forEachManipulator3D((t3) => {
      a4 || (a4 = t3.renderLocation);
    }), a4;
  }
  get available() {
    return this._available;
  }
  set available(a4) {
    this._available = a4, this._forEachManipulator3D((t3) => t3.available = a4);
  }
  get hovering() {
    return this.someManipulator((a4) => a4.hovering);
  }
  get grabbing() {
    return this.someManipulator((a4) => a4.grabbing);
  }
  get dragging() {
    return this.someManipulator((a4) => a4.dragging);
  }
  hasManipulator(a4) {
    return this.someManipulator((t3) => t3 === a4);
  }
  someManipulator(a4) {
    let t3 = false;
    return this.forEachManipulator((i2) => {
      !t3 && a4(i2) && (t3 = true);
    }), t3;
  }
  _forEachManipulator3D(t3) {
    this.forEachManipulator((i2, o2) => {
      i2 instanceof $ && t3(i2, o2);
    });
  }
};
function n$1(n2, a4, r3, c2) {
  const s2 = (t3, e4) => a4({ action: t3, graphic: n2, dxScreen: e4.screenDeltaX, dyScreen: e4.screenDeltaY });
  return r3((a5, r4, i2) => (r4.next((t3) => ("start" === t3.action && s2("start", t3), t3)).next(x$6(n2, c2)).next((t3) => {
    switch (t3.action) {
      case "start":
      case "update":
        (t3.translationX || t3.translationY || t3.translationZ) && s2("update", t3);
        break;
      case "end":
        s2("end", t3);
    }
    return t3;
  }), { steps: r4, cancel: i2 = i2.next(z$3(n2)).next((t3) => (s2("end", { screenDeltaX: 0, screenDeltaY: 0 }), t3)) }));
}
function a$2(t3) {
  if (null == t3?.axis)
    return 1;
  const { mapStart: e4, mapEnd: n2, axis: a4 } = t3, r3 = [n2.x - e4.x, n2.y - e4.y];
  return r3[0] * a4[0] + r3[1] * a4[1] > 0 ? 1 : -1;
}
let C$2 = class C2 extends t$1 {
  constructor(t3) {
    super(), this._handles = new e$a(), this._arrowManipulatorInfos = new Array(), this._angle = 0, this._scale = 1, this._radius = a$3, this._updateAfterDrag = false, this.events = new o$4(), this._tool = t3.tool, this._view = t3.view, this._opaqueMaterial = this._createMaterial(), this._transparentMaterial = this._createMaterial(0.5), null != t3.radius && (this._radius = t3.radius), this._createManipulators(), this.forEachManipulator((t4) => this._tool.manipulators.add(t4));
  }
  set orthogonalAvailable(t3) {
    this._arrowManipulatorInfos.length >= 3 && (this._arrowManipulatorInfos[1].manipulator.available = t3, this._arrowManipulatorInfos[3].manipulator.available = t3);
  }
  destroy() {
    this._handles = u$7(this._handles), this.forEachManipulator((t3) => {
      this._tool.manipulators.remove(t3), t3.destroy();
    }), this._tool = null, this._view = null, this._arrowManipulatorInfos.length = 0;
  }
  forEachManipulator(t3) {
    for (const { manipulator: a4 } of this._arrowManipulatorInfos)
      t3(a4, A$3.TRANSLATE_XY);
  }
  createGraphicDragPipeline(t3, a4, r3) {
    const e4 = a4.graphic, i2 = s$5(e4), o2 = e4.geometry.spatialReference;
    return n$1(e4, r3, (a5) => this.createDragPipeline((r4, e5, i3, o3, s2) => ({ steps: e5, cancel: i3 } = t3(r4, e5, i3, o3, s2), a5(r4, e5, i3)), i2, o2, e4), this._view.state.viewingMode);
  }
  createDragPipeline(t3, a4, r3, i2) {
    return t$6(this._arrowManipulatorInfos.map(({ manipulator: e4 }, o2) => d$6(e4, (e5, s2, n2, l2, p4) => {
      const u3 = s2.next((t4) => ({ ...t4, manipulatorType: A$3.TRANSLATE_XY })).next(D$4(this._view, e5.elevationAlignedLocation)).next(T$3(this._view, e5.elevationAlignedLocation, a4, r3, i2)).next(y$2(e5.location, this.angle + (o2 + 1) * Math.PI * 0.5)).next(q$4());
      t3(e5, u3, n2, l2, p4);
    })));
  }
  get angle() {
    return this._angle;
  }
  set angle(t3) {
    this._angle = t3, this.dragging ? this._updateAfterDrag = true : this._updateManipulatorTransform();
  }
  get displayScale() {
    return this._scale;
  }
  set displayScale(t3) {
    this._scale = t3, this._updateManipulatorTransform();
  }
  get radius() {
    return this._radius;
  }
  set radius(t3) {
    this._radius !== t3 && (this._radius = t3, this._updateManipulators());
  }
  _updateManipulators() {
    for (let t3 = 0; t3 < this._arrowManipulatorInfos.length; t3++)
      this._updateArrowManipulator(this._arrowManipulatorInfos[t3], t3);
    this._updateManipulatorTransform();
  }
  _updateArrowManipulator({ manipulator: t3, transform: a4 }, r3) {
    const e4 = this._radius / a$3, i2 = M$1 * e4, o2 = i2 * Math.sqrt(3) / 2, s2 = pt(this._opaqueMaterial, o2, i2 / 2, i2 / 2, h$3);
    it(s2, q$5(f$6.get(), o$5(c$9.get(), 0, -o2 / 3, 0))), t3.renderObjects = [new e$b(s2, t$9.Focused), new e$b(s2.instantiate({ material: this._transparentMaterial }), t$9.Unfocused)], t3.radius = o2 / 3 * 2 * 1.2;
    const u3 = R$5(f$6.get(), r3 * Math.PI / 2), h2 = q$5(f$6.get(), o$5(c$9.get(), 0, c$2 * e4, 0));
    c$a(a4, u3, h2);
  }
  _createManipulators() {
    for (let t3 = 0; t3 < 4; t3++) {
      const a4 = this._createArrowManipulator(t3);
      this._arrowManipulatorInfos.push(a4);
    }
    this._updateManipulatorTransform();
  }
  _updateManipulatorTransform() {
    const t3 = this.angle, a4 = g$5(f$6.get(), t3, r$b(0, 0, 1));
    if (null == a4)
      return;
    const r3 = d$7(f$6.get(), o$5(c$9.get(), this.displayScale, this.displayScale, this.displayScale)), e4 = c$a(f$6.get(), r3, a4);
    for (const i2 of this._arrowManipulatorInfos) {
      const t4 = c$a(f$6.get(), e4, i2.transform);
      i2.manipulator.modelTransform = t4;
    }
  }
  _createArrowManipulator(t3) {
    const a4 = new $({ view: this._view, autoScaleRenderObjects: false, worldOriented: true, focusMultiplier: 1, touchMultiplier: 1, collisionType: { type: "disc", direction: r$b(0, 0, 1) } }), r3 = { manipulator: a4, transform: e$d() };
    return this._updateArrowManipulator(r3, t3), this._handles.add(a4.events.on("drag", (t4) => {
      this._updateAfterDrag && "end" === t4.action && !this.dragging && (this._updateManipulatorTransform(), this._updateAfterDrag = false);
    })), r3;
  }
  _createMaterial(a4 = 1) {
    const r3 = new f$7({ cullFace: e$c.Back, renderOccluded: d$4.Transparent, isDecoration: true });
    return this._handles.add(d$3(() => u$5.toUnitRGBA(this._view.effectiveTheme.accentColor), (t3) => {
      t3[3] *= a4, r3.setParameters({ color: t3 });
    }, P$4)), r3;
  }
  get test() {
    return { arrowManipulators: this._arrowManipulatorInfos.map(({ manipulator: t3 }) => t3) };
  }
};
let e$1 = class e2 {
  constructor() {
    this._view = null, this._elevationInfo = null, this._lastDragEvent = null, this._next = null, this._enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t3) {
    if (this._enabled !== t3 && null != this._lastDragEvent && null != this._next) {
      const n2 = this._lastDragEvent.mapEnd, e4 = this._snap(this._lastDragEvent.screenEnd);
      if (null != e4) {
        const s2 = { action: "update", mapStart: this._lastDragEvent.mapStart, mapEnd: true === t3 ? e4 : n2, screenStart: this._lastDragEvent.screenEnd, screenEnd: this._lastDragEvent.screenEnd };
        this._next.execute(s2);
      }
    }
    this._enabled = t3;
  }
  _snap(n2) {
    const e4 = null != this._view ? this._view.toMap(n2, { exclude: [] }) : null;
    return null != e4 && null != this._view && (e4.z = f$8(e4, this._view, this._elevationInfo)), e4;
  }
  createDragEventPipelineStep(t3, e4) {
    this._view = t3, this._elevationInfo = e4, this._lastDragEvent = null;
    const s2 = new U$4();
    this._next = s2;
    return [(t4) => {
      if (this._lastDragEvent = "end" !== t4.action ? { ...t4 } : null, this._enabled) {
        const n2 = this._snap(t4.screenEnd);
        return null != n2 ? { action: t4.action, mapStart: t4.mapStart, mapEnd: n2, screenStart: t4.screenStart, screenEnd: t4.screenEnd } : null;
      }
      return { action: t4.action, mapStart: t4.mapStart, mapEnd: t4.mapEnd, screenStart: t4.screenStart, screenEnd: t4.screenEnd };
    }, s2];
  }
};
class k extends t$1 {
  constructor(t3) {
    super(), this._handles = new e$a(), this._snapToScene = new e$1(), this._scale = 1, this._radius = a$3, this._view = t3.view, this._tool = t3.tool, this._discMaterial = this._createMaterial(), this._discMaterialTransparent = this._createMaterial(0.5), null != t3.snapToScene && (this.snapToScene = t3.snapToScene), null != t3.radius && (this._radius = t3.radius), this._createManipulator(), this.forEachManipulator((t4) => this._tool.manipulators.add(t4));
  }
  destroy() {
    this._handles = u$7(this._handles), this.forEachManipulator((t3) => {
      this._tool.manipulators.remove(t3), t3.destroy();
    }), this._tool = null, this._view = null, this._manipulator = null;
  }
  forEachManipulator(t3) {
    t3(this._manipulator, A$3.TRANSLATE_XY);
  }
  get displayScale() {
    return this._scale;
  }
  set displayScale(t3) {
    this._scale = t3, this._updateManipulatorTransform();
  }
  get snapToScene() {
    return this._snapToScene.enabled;
  }
  set snapToScene(t3) {
    this._snapToScene.enabled = t3;
  }
  get radius() {
    return this._radius;
  }
  set radius(t3) {
    t3 !== this._radius && (this._radius = t3, this._updateManipulator());
  }
  createGraphicDragPipeline(t3, e4, i2) {
    const a4 = e4.graphic, r3 = s$5(a4), s2 = a4.geometry.spatialReference;
    return n$1(a4, i2, (e5) => this.createDragPipeline((i3, a5, r4, s3, o2) => ({ steps: a5, cancel: r4 } = t3(i3, a5, r4, s3, o2), e5(i3, a5, r4)), r3, s2, a4), this._view.state.viewingMode);
  }
  createDragPipeline(t3, e4, i2, a4) {
    const r3 = this._view;
    return d$6(this._manipulator, (s2, o2, n2, l2, p4) => {
      const c2 = o2.next(D$4(r3, s2.elevationAlignedLocation)).next(T$3(r3, s2.elevationAlignedLocation, e4, i2, a4)).next(...this._snapToScene.createDragEventPipelineStep(r3, e4)).next((t4) => ({ ...t4, manipulatorType: A$3.TRANSLATE_XY })).next(q$4());
      t3(s2, c2, n2, l2, p4);
    });
  }
  _updateManipulatorTransform() {
    const t3 = d$7(f$6.get(), o$5(c$9.get(), this.displayScale, this.displayScale, this.displayScale));
    this._manipulator.modelTransform = t3;
  }
  _createManipulator() {
    const t3 = this._view;
    this._manipulator = new $({ view: t3, worldSized: false, autoScaleRenderObjects: false, focusMultiplier: 1, touchMultiplier: 1, collisionType: { type: "disc", direction: r$b(0, 0, 1) }, worldOriented: true }), this._updateManipulator();
  }
  _updateManipulator() {
    const t3 = ut(this._discMaterial, h$3, 1, t$2, r$b(0, 0, 1), r$b(0, 0, 0));
    t3.transformation = d$7(e$d(), r$b(this._radius, this._radius, this._radius)), this._manipulator.renderObjects = [new e$b(t3, t$9.Focused), new e$b(t3.instantiate({ material: this._discMaterialTransparent }), t$9.Unfocused)], this._manipulator.radius = e$2 * (this._radius / a$3);
  }
  _createMaterial(e4 = 1) {
    const i2 = new f$7({ cullFace: e$c.Back, renderOccluded: d$4.Transparent, isDecoration: true });
    return this._handles.add(d$3(() => u$5.toUnitRGBA(this._view.effectiveTheme.accentColor), (t3) => {
      t3[3] *= e4, i2.setParameters({ color: t3 });
    }, P$4)), i2;
  }
  get test() {
    return { discManipulator: this._manipulator };
  }
}
class A2 extends t$1 {
  constructor(e4) {
    super(), this._radius = a$3, this.events = new o$4(), this._tool = e4.tool, this._view = e4.view;
    const t3 = new z$1({ getTheme: () => this._view.effectiveTheme });
    this._settings = t3, null != e4.radius && (this._radius = e4.radius);
    const i2 = this._view.effectiveTheme.accentColor;
    this._materials = { materialUnfocused: w$4(this._createDarkenedColor(i2, 1, 0.25), d$4.Occlude), materialFocused: w$4(this._createDarkenedColor(i2, 1, 0), d$4.Occlude), materialOccludedUnfocused: w$4(this._createDarkenedColor(i2, 0.7, 0), t3.zManipulator.renderOccluded), materialOccludedFocused: w$4(this._createDarkenedColor(i2, 0.85, 0), t3.zManipulator.renderOccluded) }, this._themeHandle = d$3(() => this._view.effectiveTheme.accentColor, (e5) => {
      const t4 = this._createDarkenedColor(e5, 1, 0.25), r3 = this._createDarkenedColor(e5, 1, 0), i3 = this._createDarkenedColor(e5, 0.7, 0), a4 = this._createDarkenedColor(e5, 0.85, 0), { materialUnfocused: o2, materialFocused: s2, materialOccludedUnfocused: n2, materialOccludedFocused: l2 } = this._materials;
      o2.setParameters({ color: t4 }), s2.setParameters({ color: r3 }), n2.setParameters({ color: i3 }), l2.setParameters({ color: a4 });
    }), this._createManipulator(), this.forEachManipulator((e5) => this._tool.manipulators.add(e5));
  }
  destroy() {
    this._themeHandle = l$5(this._themeHandle), this._manipulator.applyObjectTransform = H, this.forEachManipulator((e4) => {
      this._tool.manipulators.remove(e4), e4.destroy();
    });
  }
  forEachManipulator(e4) {
    e4(this._manipulator, A$3.TRANSLATE_Z);
  }
  createGraphicDragPipeline(e4, t3, r3) {
    const i2 = t3.graphic.geometry.spatialReference;
    return n$1(t3.graphic, r3, (t4) => this.createDragPipeline((r4, i3, a4, o2, s2) => ({ steps: i3, cancel: a4 } = e4(r4, i3, a4, o2, s2), t4(r4, i3, a4)), i2), this._view.state.viewingMode);
  }
  createDragPipeline(e4, t3) {
    const r3 = this._view;
    return d$6(this._manipulator, (i2, a4, o2, s2, n2) => {
      const l2 = a4.next((e5) => ({ ...e5, manipulatorType: A$3.TRANSLATE_Z })).next(P$6(r3, i2.renderLocation, t3)).next(q$4());
      e4(i2, l2, o2, s2, n2);
    });
  }
  get radius() {
    return this._radius;
  }
  set radius(e4) {
    e4 !== this._radius && (this._radius = e4, this._updateManipulator());
  }
  _updateManipulator() {
    const e4 = this._settings, t3 = this._radius / a$3, r3 = e4.zManipulator.height * t3, i2 = e4.zManipulator.coneHeight * t3, a4 = e4.zManipulator.coneWidth * t3, o2 = e4.zManipulator.width * t3, m3 = [r$b(0, 0, 0), r$b(0, 0, r3)], d2 = [r$b(0, 0, 0), r$b(0, 0, r3 + i2)], u3 = (e5) => {
      const t4 = e$d();
      if (i$7(t4, t4, [0, 0, r3]), l$6(t4, t4, Math.PI / 2), e5) {
        const r4 = 1 + 2 * e5 / a4;
        f$9(t4, t4, [r4, r4, r4]);
      }
      return t4;
    }, p4 = u3(0), { materialUnfocused: h2, materialFocused: f3, materialOccludedUnfocused: _2, materialOccludedFocused: w3 } = this._materials, v2 = ct(h2, m3, o2 / 2, 16, false), M2 = lt(h2, i2, a4 / 2, 16, false);
    M2.transformation = p4, this._manipulator.renderObjects = [new e$b(M2, t$9.Unfocused), new e$b(v2, t$9.Unfocused), new e$b(M2.instantiate({ material: f3 }), t$9.Focused), new e$b(v2.instantiate({ material: f3 }), t$9.Focused), new e$b(M2.instantiate({ material: _2 }), t$9.Unfocused), new e$b(v2.instantiate({ material: _2 }), t$9.Unfocused), new e$b(M2.instantiate({ material: w3 }), t$9.Focused), new e$b(v2.instantiate({ material: w3 }), t$9.Focused)], this._manipulator.radius = o2 / 2 + 2, this._manipulator.collisionType = { type: "line", paths: [d2] };
  }
  _createManipulator() {
    const e4 = this._view, t3 = new $({ view: e4, autoScaleRenderObjects: false, worldSized: false, selectable: false, cursor: "ns-resize", elevationInfo: this.elevationInfo, worldOriented: true, collisionPriority: 1.6 });
    t3.applyObjectTransform = (t4) => {
      const r3 = e4.state.camera, a4 = E$1;
      e4.renderCoordsHelper.toRenderCoords(this._manipulator.elevationAlignedLocation, a4);
      const o2 = U$5(r3.eye, a4), s2 = r3.computeRenderPixelSizeAtDist(o2), n2 = e$e(R$1, a4, r3.eye);
      z$4(n2, n2);
      const l2 = x;
      e4.renderCoordsHelper.worldUpAtPosition(E$1, l2);
      const c2 = Math.abs(P$7(n2, l2)), _2 = _$1(R$1, n2, l2), j2 = _$1(R$1, _2, l2), w3 = i$8(c2, 0.01, 1), v2 = 1 - Math.sqrt(1 - w3 * w3) / w3 / r3.fullWidth, g3 = this._settings, M2 = this._radius / a$3, U2 = g3.zManipulator.width * M2;
      g$3(j2, z$4(j2, j2), (1 / v2 - 1) * o2 + s2 * U2), t4[12] -= R$1[0], t4[13] -= R$1[1], t4[14] -= R$1[2];
    }, this._manipulator = t3, this._updateManipulator();
  }
  _createDarkenedColor(r3, i2, a4) {
    const o2 = L$3(r3, a4);
    return o2.a *= i2, u$5.toUnitRGBA(o2);
  }
  get test() {
    return { manipulator: this._manipulator };
  }
}
const E$1 = n$4(), R$1 = n$4(), x = n$4(), H = () => {
};
let u$1 = class u extends t$1 {
  constructor(a4) {
    super(), this._handles = new e$a(), this._interactive = true;
    const { tool: t3, view: n2, snapToScene: s2, radius: e4 } = a4;
    this._view = n2, this.xyManipulation = new k({ tool: t3, view: n2, snapToScene: s2, radius: e4 }), this.xyAxisManipulation = new C$2({ tool: t3, view: n2, radius: e4 }), this.zManipulation = new A2({ tool: t3, view: n2, radius: e4 }), this.xyManipulation.available = a4.xyAvailable, this.xyAxisManipulation.available = a4.xyAxisAvailable, this.zManipulation.available = a4.zAvailable, this._autoHideXYAxis(), this.forEachManipulator((i2) => this._handles.add(i2.events.on("grab-changed", () => this._updateManipulatorInteractivity())));
  }
  destroy() {
    this._handles.destroy(), this.xyManipulation.destroy(), this.xyAxisManipulation.destroy(), this.zManipulation.destroy();
  }
  createGraphicDragPipeline(i2, t3, n2) {
    return t$6([this.xyManipulation.createGraphicDragPipeline((a4, t4, n3, s2, e4) => i2(c$1.XY, a4, t4, n3, s2, e4), t3, n2), this.xyAxisManipulation.createGraphicDragPipeline((a4, t4, n3, s2, e4) => i2(c$1.XY_AXIS, a4, t4, n3, s2, e4), t3, n2), this.zManipulation.createGraphicDragPipeline((a4, t4, n3, s2, e4) => i2(c$1.Z, a4, t4, n3, s2, e4), t3, n2)]);
  }
  createDragPipeline(i2, t3, n2, s2) {
    return t$6([this.xyManipulation.createDragPipeline((a4, t4, n3, s3, e4) => i2(c$1.XY, a4, t4, n3, s3, e4), t3, n2, s2), this.xyAxisManipulation.createDragPipeline((a4, t4, n3, s3, e4) => i2(c$1.XY_AXIS, a4, t4, n3, s3, e4), t3, n2, s2), this.zManipulation.createDragPipeline((a4, t4, n3, s3, e4) => i2(c$1.Z, a4, t4, n3, s3, e4), n2)]);
  }
  set snapToScene(i2) {
    this.xyManipulation.snapToScene = i2;
  }
  set angle(i2) {
    this.xyAxisManipulation.angle = i2;
  }
  set interactive(i2) {
    this._interactive !== i2 && (this._interactive = i2, this._updateManipulatorInteractivity());
  }
  set radius(i2) {
    this.xyAxisManipulation.radius = i2, this.xyManipulation.radius = i2, this.zManipulation.radius = i2;
  }
  set displayScale(i2) {
    this.xyManipulation.displayScale = i2, this.xyAxisManipulation.displayScale = i2;
  }
  forEachManipulator(i2) {
    this.xyManipulation.forEachManipulator((a4) => i2(a4, A$3.TRANSLATE_XY)), this.xyAxisManipulation.forEachManipulator((a4) => i2(a4, A$3.TRANSLATE_XY)), this.zManipulation.forEachManipulator((a4) => i2(a4, A$3.TRANSLATE_Z));
  }
  get _xyAxisVisible() {
    const i2 = this.xyManipulation.someManipulator((i3) => i3.focused) || this.xyAxisManipulation.someManipulator((i3) => i3.focused);
    return this._view.inputManager && "touch" === this._view.inputManager.latestPointerType || i2;
  }
  _autoHideXYAxis() {
    const i2 = this.xyAxisManipulation, a4 = this.xyManipulation;
    if (has("esri-mobile"))
      return;
    const n2 = [];
    a4.forEachManipulator((i3) => n2.push(i3)), i2.forEachManipulator((i3) => n2.push(i3));
    const s2 = () => {
      const a5 = [];
      this._xyAxisVisible || i2.forEachManipulator((i3) => a5.push(i3.disableDisplay())), this._handles.remove(h$2), this._handles.add(a5, h$2);
    };
    for (const t3 of n2)
      this._handles.add(t3.events.on("focus-changed", s2));
    this._view.inputManager && this._handles.add(p$5(() => this._view.inputManager?.latestPointerType, s2)), s2();
  }
  _updateManipulatorInteractivity() {
    const i2 = this.grabbing;
    this.forEachManipulator((a4) => {
      a4.interactive = !i2 && this._interactive || a4.grabbing;
    });
  }
  static radiusForSymbol(i2) {
    const a4 = null != i2 && "point-3d" === i2.type && i2.symbolLayers;
    return !!a4 && a4.some((i3) => "icon" === i3.type) ? o$1 : a$3;
  }
};
const h$2 = "disable-xy-axis-display";
var c$1;
!function(i2) {
  i2[i2.XY = 0] = "XY", i2[i2.XY_AXIS = 1] = "XY_AXIS", i2[i2.Z = 2] = "Z";
}(c$1 || (c$1 = {}));
class l extends t$1 {
  constructor(t3) {
    super(), this._view = t3.view, this._tool = t3.tool, this._graphicState = t3.graphicState, this._createManipulator(), this.forEachManipulator((t4) => this._tool.manipulators.add(t4));
  }
  destroy() {
    this.forEachManipulator((t3) => {
      this._tool.manipulators.remove(t3), t3.destroy();
    }), this._tool = null, this._view = null, this._manipulator = null, this._graphicState = null;
  }
  forEachManipulator(t3) {
    t3(this._manipulator, A$3.TRANSLATE_XY);
  }
  createGraphicDragPipeline(t3) {
    return n$1(this._graphicState.graphic, t3, (t4) => this.createDragPipeline(t4), this._view.state.viewingMode);
  }
  createDragPipeline(i2) {
    const e4 = this._view, r3 = this._graphicState.graphic, n2 = null != r3.geometry ? r3.geometry.spatialReference : null;
    return d$6(this._manipulator, (a4, l2, p4, h2, c2) => {
      const u3 = l2.next(M$6(c2, e4, r3, n2)).next(P$8()).next(q$4());
      i2(a4, u3, p4, h2, c2);
    });
  }
  _createManipulator() {
    const t3 = this._view, i2 = this._graphicState.graphic;
    this._manipulator = new S$3({ graphic: i2, view: t3, selectable: true, cursor: "move" });
  }
}
let C$1 = class C3 {
  constructor(t3) {
    this.allGraphics = t3, this.type = "graphic-move-start";
  }
};
class V {
  constructor(t3, i2, e4) {
    this.dx = t3, this.dy = i2, this.allGraphics = e4, this.type = "graphic-move";
  }
}
class L {
  constructor(t3) {
    this.allGraphics = t3, this.type = "graphic-move-stop";
  }
}
const N = "manipulators";
let q = class extends o$4.EventedMixin(l$7) {
  constructor(t3) {
    super(t3), this._infos = /* @__PURE__ */ new Map(), this.graphics = new V$4(), this.enableZ = true, this.tooltipOptions = new p$6(), this.type = "move-3d", this._updatingHandles = new h$7(), this._moveManipulation = null, this._tooltip = null, this._translateGraphicTooltipInfo = null, this._translateGraphicXYTooltipInfo = null, this._translateGraphicZTooltipInfo = null;
  }
  initialize() {
    const { view: t3 } = this;
    this.addHandles([this.graphics.on("change", (t4) => {
      t4.removed.forEach((t5) => this.removeHandles(t5)), this._updateGraphicInfos(t4), this._setupFastTransformUpdates(t4.added), this._refreshManipulators();
    }), d$3(() => this.tooltipOptions.enabled, (i3) => {
      this._tooltip = i3 ? new u$8({ view: t3 }) : u$7(this._tooltip);
    }, A$7)]);
    const i2 = this.graphics.toArray();
    this._updateGraphicInfos({ added: i2, removed: [] }), this._setupFastTransformUpdates(i2), this._refreshManipulators(), this.finishToolCreation();
  }
  destroy() {
    this._tooltip = u$7(this._tooltip), this._moveManipulation = u$7(this._moveManipulation), this._set("view", null), this._updatingHandles.destroy();
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  reset() {
  }
  _updateGraphicInfos({ added: t3, removed: i2 }) {
    for (const e4 of t3) {
      if (o$a(e4) !== P$9.SUPPORTED)
        continue;
      const t4 = new B(e4), i3 = this.view.trackGraphicState(t4.state);
      this._infos.set(t4.graphic, { info: t4, handle: i3 });
    }
    for (const e4 of i2)
      this._infos.get(e4)?.handle.remove(), this._infos.delete(e4);
  }
  _setupFastTransformUpdates(t3) {
    for (const i2 of t3) {
      const { info: t4 } = this._infos.get(i2);
      this.addHandles(o$3(t4.state), i2);
    }
  }
  _refreshManipulators() {
    if (this.removeHandles(N), this._moveManipulation = u$7(this._moveManipulation), this.manipulators.removeAll(), 0 === this._infos.size)
      return;
    const t3 = Array.from(this._infos.values(), ({ info: t4 }) => t4);
    this._createManipulators(t3), this._createVisualElements(t3), this._updateMoveManipulation(t3);
  }
  _createManipulators(t3) {
    for (const i2 of t3) {
      const e4 = i2.state;
      i2.manipulationXY = new l({ tool: this, view: this.view, graphicState: e4 }), i2.manipulationXY.forEachManipulator((t4) => this.addHandles([t4.events.on("immediate-click", (t5) => {
        this.emit("immediate-click", { ...t5, graphic: e4.graphic }), t5.stopPropagation();
      }), t4.events.on("grab-changed", ({ action: t5 }) => {
        const { tooltipOptions: i3, _tooltip: e5 } = this;
        null != e5 && ("start" === t5 ? (this._translateGraphicTooltipInfo ??= new r$c({ tooltipOptions: i3 }), e5.info = this._translateGraphicTooltipInfo, e5.info.tooltipOptions = i3, e5.info.distance = h$8) : e5.clear());
      })], N)), this.addHandles(i2.manipulationXY.createDragPipeline((i3, e5, o2, n2) => this._buildDragEventPipeline(t3, c$1.XY, i3, e5, o2, n2)), N);
    }
    this._createMoveManipulation(t3);
  }
  _createMoveManipulation(t3) {
    const i2 = new u$1({ tool: this, view: this.view, snapToScene: false, xyAvailable: true, xyAxisAvailable: true, zAvailable: true, radius: 1 === t3.length ? u$1.radiusForSymbol(t3[0].graphic.symbol) : a$3 });
    this._moveManipulation = i2, i2.elevationInfo = { mode: "absolute-height", offset: 0 }, i2.forEachManipulator((t4) => {
      this.addHandles(t4.events.on("immediate-click", (e5) => {
        i2.zManipulation.hasManipulator(t4) || 1 !== this.graphics.length || this.emit("immediate-click", { ...e5, graphic: this.graphics.at(0) }), e5.stopPropagation();
      }), N);
    });
    const e4 = (i3) => (e5) => {
      this.addHandles(e5.events.on("focus-changed", ({ action: e6 }) => {
        const o3 = this._tooltip;
        null != o3 && ("focus" === e6 ? this._updateMoveTooltip(t3, i3) : o3.clear());
      }), N);
    };
    this._moveManipulation.xyManipulation.forEachManipulator(e4(c$1.XY)), this._moveManipulation.xyAxisManipulation.forEachManipulator(e4(c$1.XY_AXIS)), this._moveManipulation.zManipulation.forEachManipulator(e4(c$1.Z));
    const o2 = () => this._updateMoveManipulation(t3);
    for (const a4 of t3)
      this.addHandles([a4.state.on("changed", o2), d$3(() => a4.state.displaying, o2)], N);
    const n2 = t3[t3.length - 1];
    this.addHandles(n2.state.on("changed", () => this._updateMoveManipulationAngle(n2)), N), this.addHandles(i2.createDragPipeline((i3, e5, o3, n3, a4) => this._buildDragEventPipeline(t3, i3, e5, o3, n3, a4), s$5(n2.graphic), n2.graphic.geometry.spatialReference, n2.graphic), N), this._updateMoveManipulationAngle(n2);
  }
  _createVisualElements(t3) {
    for (const i2 of t3) {
      const e4 = i2.graphic, n2 = i$2({ view: this.view, graphic: e4, forEachManipulator: (t4) => {
        i2.manipulationXY?.forEachManipulator(t4), this._moveManipulation?.forEachManipulator(t4);
      }, onManipulatorsChanged: () => e$5() });
      null != n2 && (i2.geometryRepresentation = n2.visualElement, i2.geometryRepresentation instanceof w2 && this.addHandles([i2.geometryRepresentation.events.on("attachment-origin-changed", () => {
        i2.state.isDraped || this._updateMoveManipulation(t3);
      }), d$3(() => i2.state.isDraped, () => this._updateMoveManipulation(t3))], N), this.addHandles(n2, N));
    }
  }
  _updateMoveManipulationAngle(t3) {
    this._moveManipulation && (this._moveManipulation.angle = r$3(t3.graphic.geometry));
  }
  _updateMoveManipulation(t3) {
    const i2 = e$7(0, 0, 0, this.view.spatialReference);
    let e4 = 0, o2 = false;
    const n2 = this._moveManipulation;
    if (n2) {
      for (const n3 of t3) {
        if (!n3.state.displaying)
          continue;
        const t4 = n3.state.graphic;
        this.enableZ && n$6(t4) && (o2 = true);
        const a4 = n3.geometryRepresentation instanceof w2 && !n3.state.isDraped ? n3.geometryRepresentation.attachmentOrigin : k$3(this.view, t4);
        if (null != a4) {
          const { x: t5, y: o3, z: n4 } = a4;
          i2.x += t5, i2.y += o3, n4 && (i2.z ??= 0, i2.z += n4), e4++;
        }
      }
      e4 > 0 ? (i2.x /= e4, i2.y /= e4, i2.z ??= 0, i2.z /= e4, n2.location = i2, n2.xyManipulation.available = true, n2.xyAxisManipulation.available = true, n2.zManipulation.available = o2) : n2.available = false;
    }
  }
  _buildDragEventPipeline(t3, i2, e4, o2, n2, a4) {
    const s2 = [], r3 = [];
    let p4 = null, l2 = null;
    const h2 = () => {
      for (const t4 of s2)
        t4.dragging = false;
      s2.length = 0, r3.length = 0, p4 = null, l2 = null, this._moveManipulation && (this._moveManipulation.interactive = true);
    };
    if (1 === t3.length && i2 === c$1.XY) {
      const i3 = t3[0].graphic;
      ({ steps: o2, cancel: n2 } = this._buildSnappingPipelineSteps(i3, s$5(i3), o2, n2, a4));
    }
    return n2 = n2.next((t4) => l2?.(t4)).next(() => (this.emit("graphic-move-stop", new L(r3)), this.destroyed || h2(), null)), { steps: o2 = o2.next((i3) => {
      if ("start" === i3.action) {
        s2.length = 0, r3.length = 0;
        for (const i4 of t3)
          i4.dragging || !i4.manipulationXY?.hasManipulator(e4) && i4.manipulationXY?.grabbing || (s2.push(i4), r3.push(i4.graphic), i4.dragging = true);
        if (0 !== r3.length && (this._moveManipulation && (this._moveManipulation.interactive = false), p4 = j$4(r3, this.view.state.viewingMode), l2 = w$5(r3), this.emit("graphic-move-start", new C$1(r3)), this.destroyed))
          return null;
      }
      return 0 !== r3.length ? i3 : null;
    }).next((t4) => p4?.(t4)).next((e5) => (this._updateMoveTooltip(t3, i2, e5), e5)).next((t4) => {
      switch (t4.action) {
        case "start":
        case "update":
          if (t4.translationX || t4.translationY || t4.translationZ) {
            const i3 = this.view.toScreen(t4.mapStart), e5 = this.view.toScreen(t4.mapEnd), o3 = e5.x - i3.x, n3 = e5.y - i3.y;
            if (this.emit("graphic-move", new V(o3, n3, r3)), this.destroyed)
              return null;
          }
          break;
        case "end":
          if (this.emit("graphic-move-stop", new L(r3)), this.destroyed)
            return null;
          h2();
      }
      return null;
    }), cancel: n2 };
  }
  _updateMoveTooltip(t3, i2, e4) {
    const { tooltipOptions: o2, _tooltip: n2 } = this;
    if (null == n2)
      return;
    n2.clear();
    const a4 = 0 === t3.length ? "absolute-height" : t3[0].state.isDraped ? "on-the-ground" : "absolute-height";
    switch (i2) {
      case c$1.XY:
        n2.info = this._translateGraphicTooltipInfo ??= new r$c({ tooltipOptions: o2 }), this._updateMoveTooltipDistance(n2.info, e4, (t4, i3) => s$6(t4, i3, a4));
        break;
      case c$1.XY_AXIS:
        n2.info = this._translateGraphicXYTooltipInfo ??= new l$8({ tooltipOptions: o2 }), this._updateMoveTooltipDistance(n2.info, e4, (t4, i3) => {
          const o3 = s$6(t4, i3, a4);
          return m$4(o3, a$2(e4));
        });
        break;
      case c$1.Z:
        n2.info = this._translateGraphicZTooltipInfo ??= new a$b({ tooltipOptions: o2 }), this._updateMoveTooltipDistance(n2.info, e4, y$3);
    }
    n2.info.tooltipOptions = o2;
  }
  _updateMoveTooltipDistance(t3, i2, e4) {
    if (null != i2 && "end" !== i2.action) {
      const { mapStart: o2, mapEnd: n2 } = i2, s2 = e4(o2, n2);
      t3.distance = null != s2 ? s2 : h$8;
    } else
      t3.distance = h$8;
  }
  _buildSnappingPipelineSteps(t3, i2, e4, o2, n2) {
    const a4 = t3.geometry;
    if (null == a4 || "point" !== a4.type && "mesh" !== a4.type)
      return { steps: e4, cancel: o2 };
    const s2 = ("point" === a4.type ? a4 : a4.anchor).clone(), r3 = new e$f({ elevationInfo: i2, pointer: n2, editGeometryOperations: V$5.fromGeometry(s2, this.view.state.viewingMode), visualizer: new O$2(), excludeFeature: t3 }), p4 = this.snappingManager, { snappingStep: l2, cancelSnapping: h2 } = f$a({ snappingContext: r3, snappingManager: p4, updatingHandles: this._updatingHandles });
    return o2 = o2.next(h2), { steps: e4 = e4.next((i3) => {
      s2.z = c$b(this.view, s2, s$5(t3), { mode: "absolute-height", offset: 0 });
      return { ...i3, snapOrigin: r3.coordinateHelper.pointToVector(s2) };
    }).next(...l2), cancel: o2 };
  }
  get test() {
    return { tooltip: this._tooltip };
  }
};
e$4([y$1({ constructOnly: true, nonNullable: true })], q.prototype, "view", void 0), e$4([y$1()], q.prototype, "graphics", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], q.prototype, "enableZ", void 0), e$4([y$1({ constructOnly: true, type: p$6 })], q.prototype, "tooltipOptions", void 0), e$4([y$1({ constructOnly: true })], q.prototype, "snappingManager", void 0), e$4([y$1()], q.prototype, "type", void 0), e$4([y$1()], q.prototype, "updating", null), q = e$4([c$5("esri.views.3d.interactive.editingTools.graphicMove3D.GraphicMoveTool")], q);
class B {
  constructor(t3) {
    this.geometryRepresentation = null, this.manipulationXY = null, this.dragging = false, this.state = new e$3({ graphic: t3 });
  }
  get graphic() {
    return this.state.graphic;
  }
}
function m2(e4, r3, o2) {
  const n2 = "on-the-ground" === o2.mode ? y$4.XY : y$4.XYZ;
  return new N$2(e4, n2, r3, 0);
}
function a$1(e4, r3, n2) {
  const t3 = n$4();
  if (!e4.renderCoordsHelper.toRenderCoords(r3, t3))
    return null;
  const s2 = j$1(e4, r3, ot$1(n2.plane)), l2 = j$1(e4, r3, n2.edgeDirection);
  if (null == s2 || null == l2)
    return null;
  const f3 = _$1(n$4(), s2, l2);
  return k$4(t3, f3, b$5());
}
function j$1(e4, r3, o2) {
  const t3 = e$7(r3.x + o2[0], r3.y + o2[1], r3.z + o2[2], r3.spatialReference), s2 = n$4(), i2 = n$4();
  return e4.renderCoordsHelper.toRenderCoords(r3, s2) && e4.renderCoordsHelper.toRenderCoords(t3, i2) ? H$1(i2, s2, i2) : null;
}
function C4(e4, t3, s2) {
  const u3 = ot$1(e4), d2 = H$1(n$4(), t3, s2), l2 = _$1(n$4(), d2, u3), f3 = _$1(n$4(), d2, l2);
  return t$a(d2[0], d2[1], d2[2], 0, l2[0], l2[1], l2[2], 0, f3[0], f3[1], f3[2], 0, 0, 0, 0, 1);
}
function h$1(r3, o2, n2) {
  const c2 = n2.projectToRenderScreen(r3, x$7()), i2 = n2.projectToRenderScreen(o2, x$7());
  return null != c2 && null != i2 ? v$4(e$e(c2, c2, i2)) : 0;
}
let p$2 = class p extends s$7 {
  constructor(o2) {
    super(o2), this.type = "reshape-edge-offset", this.distance = h$8, this.area = null, this.totalLength = null;
  }
};
e$4([y$1()], p$2.prototype, "type", void 0), e$4([y$1()], p$2.prototype, "distance", void 0), e$4([y$1()], p$2.prototype, "area", void 0), e$4([y$1()], p$2.prototype, "totalLength", void 0), p$2 = e$4([c$5("esri.views.interactive.tooltip.ReshapeEdgeOffsetTooltipInfo")], p$2);
let kt$1 = class kt extends o$4.EventedMixin(g$2) {
  constructor(t3) {
    super(t3), this._selectedIndex = 0, this._manipulatorHandles = new e$a(), this._manipulatorInfos = [], this._numGrabbing = 0, this._numDragging = 0, this._reshapeEventState = qt.NONE, this._updatingHandles = new h$7(), this._recreatingManipulators = false, this._settings = new z$1({ getTheme: () => this.view.effectiveTheme }), this._translateGraphicTooltipInfo = null, this._translateGraphicXYTooltipInfo = null, this._translateGraphicZTooltipInfo = null, this._translateVertexTooltipInfo = null, this._translateVertexXYTooltipInfo = null, this._translateVertexZTooltipInfo = null, this._edgeOffsetTooltipInfo = null, this.outputGeometry = null, this._vertexLaserLineVisualElement = null;
  }
  initialize() {
    const { graphic: t3, view: e4 } = this, i2 = this._settings.manipulators, n2 = i2.vertex;
    this._vertexManipulatorMaterial = w$4(E$2(n2.color), n2.renderOccluded), this._vertexManipulatorOutlineMaterial = b$6(E$2(n2.outlineColor), n2.renderOccluded), this._vertexManipulatorHoverOutlineMaterial = b$6(E$2(n2.hoverOutlineColor), n2.renderOccluded);
    const o2 = i2.edge;
    this._edgeManipulatorMaterial = w$4(E$2(o2.color), o2.renderOccluded), this._edgeManipulatorOutlineMaterial = b$6(E$2(o2.outlineColor), o2.renderOccluded);
    const r3 = i2.edgeOffset;
    this._edgeOffsetManipulatorMaterial = w$4(E$2(r3.color), r3.renderOccluded, false), this._edgeOffsetManipulatorHoverMaterial = w$4(E$2(r3.hoverColor), r3.renderOccluded, false);
    const s2 = i2.selected;
    this._selectedManipulatorMaterial = w$4(E$2(s2.color), s2.renderOccluded), this._selectedManipulatorOutlineMaterial = b$6(E$2(s2.outlineColor), s2.renderOccluded), this._selectedManipulatorHoverOutlineMaterial = b$6(E$2(s2.hoverOutlineColor), s2.renderOccluded);
    const l2 = this._graphicState = new e$3({ graphic: t3 });
    this._tooltip = new u$8({ view: e4 }), this.addHandles([d$3(() => {
      const t4 = this._settings.manipulators;
      return { vertexSettings: t4.vertex, edgeSettings: t4.edge, edgeOffsetSettings: t4.edgeOffset, selectedSettings: t4.selected };
    }, ({ vertexSettings: t4, edgeSettings: e5, edgeOffsetSettings: i3, selectedSettings: a4 }) => {
      t4.applyColor(this._vertexManipulatorMaterial), t4.applyOutline(this._vertexManipulatorOutlineMaterial), t4.applyHoverOutline(this._vertexManipulatorHoverOutlineMaterial), e5.applyColor(this._edgeManipulatorMaterial), e5.applyOutline(this._edgeManipulatorOutlineMaterial), i3.applyColor(this._edgeOffsetManipulatorMaterial), i3.applyHover(this._edgeOffsetManipulatorHoverMaterial), a4.applyColor(this._selectedManipulatorMaterial), a4.applyOutline(this._selectedManipulatorOutlineMaterial), a4.applyHoverOutline(this._selectedManipulatorHoverOutlineMaterial);
    }), d$3(() => l2.displaying, (t4) => {
      for (const e5 of this._manipulatorInfos)
        e5.manipulator.available = t4;
    }), d$3(() => ({ labels: this._segmentLabels, enabled: this._labelOptions.enabled, edgeOffsetEnabled: this.enableEdgeOffset }), ({ labels: t4, enabled: e5, edgeOffsetEnabled: i3 }) => {
      null != t4 && (t4.visible = e5, t4.edgeDistance = i3 ? "far" : "default");
    }, P$4), p$5(() => !this._tooltipOptions.enabled, () => this._tooltip.clear(), P$4), this.view.trackGraphicState(l2)]);
  }
  destroy() {
    this._segmentLabels = u$7(this._segmentLabels), this._tooltip = u$7(this._tooltip), this._removeManipulators(), this._updatingHandles.destroy();
  }
  get inputGeometry() {
    return null != this._editGeometryOperations ? this._editGeometryOperations.data.geometry : null;
  }
  set inputGeometry(t3) {
    this._recreateEditGeometryAndManipulators(t3);
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get manipulators() {
    return this.tool.manipulators;
  }
  get view() {
    return this.tool.view;
  }
  get graphic() {
    return this.tool.graphic;
  }
  get enableZShape() {
    return this.tool.enableZShape;
  }
  get enableZVertex() {
    return this.tool.enableZVertex;
  }
  get enableMoveGraphic() {
    return this.tool.enableMoveGraphic;
  }
  get enableMidpoints() {
    return this.tool.enableMidpoints;
  }
  get enableEdgeOffset() {
    return this.tool.enableEdgeOffset;
  }
  get _labelOptions() {
    return this.tool.labelOptions;
  }
  get _tooltipOptions() {
    return this.tool.tooltipOptions;
  }
  get _accentColor() {
    return this.view.effectiveTheme.accentColor;
  }
  removeSelectedVertices() {
    const t3 = this._manipulatorInfos.filter((t4) => t4.manipulator.selected && "vertex" === t4.type);
    this._removeVertices(t3);
  }
  onManipulatorSelectionChanged() {
    this.emit("manipulators-changed");
  }
  _removeManipulators() {
    this._manipulatorHandles.removeAll(), this._moveManipulation = u$7(this._moveManipulation), this._graphicMoveManipulation = u$7(this._graphicMoveManipulation), this.manipulators.removeAll(), this._manipulatorInfos = [], this._numGrabbing = 0, this._numDragging = 0;
  }
  _createManipulators(t3) {
    if (null == this._editGeometryOperations)
      return;
    const e4 = s$5(this.graphic);
    for (const i2 of this._editGeometryOperations.data.components) {
      const a4 = t3?.byComponentIndex.get(i2.index);
      for (const t4 of i2.vertices) {
        const i3 = a4?.has(t4.index);
        this._createVertexOrEdgeManipulator(t4, e4, i3);
      }
      for (const t4 of i2.edges)
        this._createVertexOrEdgeManipulator(t4, e4);
    }
    this._createGraphicMoveManipulation(), this._createMoveManipulation(e4), this._createVisualElements();
  }
  get canRedo() {
    return null != this._editGeometryOperations && this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return null != this._editGeometryOperations && this._editGeometryOperations.canUndo;
  }
  redo() {
    if (null == this._editGeometryOperations)
      return null;
    const t3 = this._editGeometryOperations.redo();
    return null != t3 && (this.outputGeometry = this._editGeometryOperations.data.geometry, this._recreateManipulators()), t3;
  }
  undo() {
    if (null == this._editGeometryOperations)
      return null;
    this.emit("undo");
    const t3 = this._editGeometryOperations.undo();
    return null != t3 && (this.outputGeometry = this._editGeometryOperations.data.geometry, this._recreateManipulators()), t3;
  }
  _recreateManipulators() {
    this._recreatingManipulators || (this._recreatingManipulators = true, this._removeManipulators(), this._tooltip.clear(), this._createManipulators(), this._recreatingManipulators = false);
  }
  _recreateEditGeometryAndManipulators(t3) {
    const e4 = { byComponentIndex: /* @__PURE__ */ new Map() };
    if (null != t3 && null != this.inputGeometry && j$5(t3, this.inputGeometry)) {
      for (const a4 of this._manipulatorInfos)
        if ("vertex" === a4.type && a4.manipulator.selected) {
          const { index: t4, component: { index: i3 } } = a4.handle, { byComponentIndex: n2 } = e4, o2 = n2.get(i3) || /* @__PURE__ */ new Set();
          o2.add(t4), n2.set(i3, o2);
        }
    }
    if (this._recreatingManipulators = true, this._removeManipulators(), this._tooltip.clear(), this._editGeometryOperations = u$7(this._editGeometryOperations), this._segmentLabels = u$7(this._segmentLabels), null == t3)
      return void (this._recreatingManipulators = false);
    const i2 = "mesh" === t3.type ? t3.anchor : t3;
    this._editGeometryOperations = V$5.fromGeometry(i2, this.view.state.viewingMode), this._createManipulators(e4), this._segmentLabels = new a$7({ context: { view: this.view, editGeometryOperations: this._editGeometryOperations, elevationInfo: s$5(this.graphic), labelOptions: this._labelOptions, graphic: this.graphic, graphicState: this._graphicState }, visible: this._labelOptions.enabled }), this._recreatingManipulators = false;
  }
  _perGraphicManipulatorDragAction(t3, e4) {
    if ("end" === e4.action)
      return e4;
    let i2 = 0;
    const a4 = [], n2 = this._manipulatorInfos.some((t4) => "vertex" === t4.type && t4.manipulator.selected), o2 = t3 === Wt.SELECTED_OR_ALL && n2;
    for (const r3 of this._manipulatorInfos)
      "vertex" === r3.type && (r3.manipulator.grabbing || o2 && !r3.manipulator.selected || a4.push(r3), i2++);
    if (0 === a4.length)
      return e4;
    this._moveVertices(a4, e4);
    if (a4.length === i2) {
      if (this._updateEventState(qt.MOVING), this.destroyed)
        return e4;
      this.emit("move", { type: "move", dx: e4.screenDeltaX, dy: e4.screenDeltaY, mover: this.graphic });
    } else {
      if (this._updateEventState(qt.RESHAPING), this.destroyed)
        return e4;
      this.emit("reshape", { type: "reshape", mover: this.graphic });
    }
    return e4;
  }
  _isMultiVertexSelection() {
    return this._manipulatorInfos.reduce((t3, e4) => "vertex" === e4.type && e4.manipulator.selected ? t3 + 1 : t3, 0) > 1;
  }
  _perVertexManipulatorDragAction(t3) {
    if (this._updateEventState(qt.RESHAPING), this.destroyed)
      return;
    const { mapDeltaX: e4, mapDeltaY: i2, mapDeltaZ: a4 } = t3;
    if (!e4 && !i2 && !a4)
      return;
    const n2 = [];
    for (const o2 of this._manipulatorInfos)
      "vertex" === o2.type && (o2.manipulator.selected && !o2.manipulator.grabbing || o2 === t3.info) && n2.push(o2);
    this._moveVertices(n2, t3, E$3.ACCUMULATE_STEPS), this.emit("reshape", { type: "reshape", mover: this.graphic });
  }
  _updateEventState(t3) {
    if (t3 === this._reshapeEventState)
      return false;
    switch (t3) {
      case qt.NONE:
        if (0 !== this._numGrabbing || 0 !== this._numDragging)
          return false;
        switch (this._reshapeEventState) {
          case qt.MOVING:
            this.emit("move", { type: "move-stop", dx: 0, dy: 0, mover: this.graphic });
            break;
          case qt.RESHAPING:
            this.emit("reshape", { type: "reshape-stop", mover: this.graphic });
        }
        break;
      case qt.MOVING:
        switch (this._reshapeEventState) {
          case qt.NONE:
            this.emit("move", { type: "move-start", dx: 0, dy: 0, mover: this.graphic });
            break;
          case qt.RESHAPING:
            this.emit("reshape", { type: "reshape-stop", mover: this.graphic }), this.destroyed || this.emit("move", { type: "move-start", dx: 0, dy: 0, mover: this.graphic });
        }
        break;
      case qt.RESHAPING:
        switch (this._reshapeEventState) {
          case qt.NONE:
            this.emit("reshape", { type: "reshape-start", mover: this.graphic });
            break;
          case qt.MOVING:
            this.emit("move", { type: "move-stop", dx: 0, dy: 0, mover: this.graphic }), this.destroyed || this.emit("reshape", { type: "reshape-start", mover: this.graphic });
        }
    }
    if (this.destroyed)
      return false;
    const e4 = this._reshapeEventState !== t3;
    return this._reshapeEventState = t3, e4;
  }
  _createGraphicMoveManipulation() {
    const { tool: t3, view: e4 } = this, i2 = this._graphicState;
    if (this._graphicMoveManipulation = new l({ tool: t3, view: e4, graphicState: i2 }), this.enableMoveGraphic) {
      let t4 = null;
      this._manipulatorHandles.add(this._graphicMoveManipulation.createDragPipeline((e5, i3, a4) => {
        i3.next((t5) => this._trackNumDragging(t5)).next((e6) => ("start" === e6.action && (t4 = this._editGeometryOperations.createUndoGroup()), e6)).next((t5) => this._perGraphicManipulatorDragAction(Wt.ALL, t5)).next((t5) => (this._updateTranslateGraphicTooltip(c$1.XY, t5), t5)).next((e6) => {
          "end" === e6.action && (this._tooltip.clear(), t4 = l$5(t4));
        }), a4.next(() => this._onDragCancel(true, () => t4 = l$5(t4)));
      })), this._graphicMoveManipulation.forEachManipulator((t5) => this._manipulatorHandles.add(this._watchAndUpdateGrabState(t5, false)));
    } else
      this._graphicMoveManipulation.forEachManipulator((t4) => {
        t4.grabbable = false, t4.cursor = null;
      });
    this._graphicMoveManipulation.forEachManipulator((t4) => this._manipulatorHandles.add(t4.events.on("immediate-click", (t5) => {
      this._manipulatorInfos.some((t6) => t6.manipulator.selected) ? this._clearSelection() : this.emit("immediate-click", { ...t5, graphic: this.graphic }), t5.stopPropagation();
    })));
  }
  _createMoveManipulation(t3) {
    const { graphic: e4, tool: i2, view: a4 } = this, n2 = this._graphicState;
    this._moveManipulation = new u$1({ tool: i2, view: a4, xyAvailable: true, xyAxisAvailable: true, zAvailable: this.enableZShape && n$6(e4), snapToScene: false, radius: u$1.radiusForSymbol(e4.symbol) }), this._moveManipulation.forEachManipulator((t4) => this.addHandles([t4.events.on("immediate-click", (i3) => {
      this._moveManipulation.zManipulation.hasManipulator(t4) || this._manipulatorInfos.some((t5) => t5.manipulator.selected) || this.emit("immediate-click", { ...i3, graphic: e4 }), i3.stopPropagation();
    }), this._watchAndUpdateGrabState(t4, false)]));
    const o2 = (t4) => (e5) => {
      this.addHandles(e5.events.on("focus-changed", ({ action: e6 }) => {
        "focus" === e6 && this._tooltipOptions.enabled ? this._updateTranslateTooltip(t4) : this._tooltip.clear();
      }));
    };
    this._moveManipulation.xyManipulation.forEachManipulator(o2(c$1.XY)), this._moveManipulation.xyAxisManipulation.forEachManipulator(o2(c$1.XY_AXIS)), this._moveManipulation.zManipulation.forEachManipulator(o2(c$1.Z)), this._moveManipulation.elevationInfo = { mode: "absolute-height", offset: 0 };
    const r3 = e4.geometry.spatialReference;
    this.addHandles([this._moveManipulation.createDragPipeline((a5, n3, o3, r4, s2) => {
      const { snappingStep: l2, cancelSnapping: p4 } = f$a({ predicate: (t4) => !!t4.info, snappingManager: i2.snappingManager, snappingContext: new e$f({ editGeometryOperations: this._editGeometryOperations, elevationInfo: t3, pointer: s2, excludeFeature: e4, visualizer: new O$2() }), updatingHandles: this._updatingHandles, useZ: false });
      return r4 = r4.next((t4) => (this._onDragCancel(), t4)).next(p4), { steps: o3 = o3.next((t4) => this._trackNumDragging(t4)).next((t4) => {
        const e5 = this._manipulatorInfos.filter((t5) => "vertex" === t5.type && t5.manipulator.selected);
        return t4.manipulatorType === A$3.TRANSLATE_XY && 1 === e5.length ? { ...t4, info: e5[0], snapOrigin: e5[0].handle.pos } : t4;
      }).next(C$5(this.view, t3, e4)).next(...l2).next(P$8()).next((t4) => this._perGraphicManipulatorDragAction(Wt.SELECTED_OR_ALL, t4)).next((t4) => (this._updateTranslateTooltip(a5, t4), t4)), cancel: r4 };
    }, t3, r3, e4), d$3(() => n2.displaying, () => this._updateMoveManipulationPosition(), P$4), n2.on("changed", () => {
      this._recreatingManipulators || this._updateMoveManipulationPosition();
    }), d$3(() => n2.isDraped, (t4) => {
      this._updateMoveManipulationPosition();
      const e5 = "align-move-manipulation";
      t4 ? this.addHandles(this.view.elevationProvider.on("elevation-change", () => this._updateMoveManipulationPosition()), e5) : this.removeHandles(e5);
    }, P$4)]);
  }
  _createVisualElements() {
    const { graphic: t3, view: e4 } = this, i2 = i$2({ view: e4, graphic: t3, forEachManipulator: (t4) => {
      if (!this.destroyed && !this._recreatingManipulators) {
        this._graphicMoveManipulation.forEachManipulator(t4), this._moveManipulation.forEachManipulator(t4);
        for (const e5 of this._manipulatorInfos)
          t4(e5.manipulator, A$3.TRANSLATE_XY);
      }
    }, onManipulatorsChanged: (t4) => this.on("manipulators-changed", t4) });
    null != i2 && (this._outlineVisualElement = i2.visualElement instanceof w2 ? i2.visualElement : null), null != this._outlineVisualElement && this._manipulatorHandles.add(this._outlineVisualElement.events.on("attachment-origin-changed", () => {
      this._graphicState.isDraped || this._updateMoveManipulationPosition();
    })), this._manipulatorHandles.add(i2);
  }
  _createEdgeOffsetManipulator(t3, e4 = s$5(this.graphic)) {
    const i2 = this._settings.manipulators.edgeOffset, a4 = i2.size / 2, n2 = a4 + i2.collisionPadding, o2 = a4 / n2, s2 = o2 * Math.sqrt(3) / 2;
    null == this._edgeOffsetManipulatorGeometryInside && (this._edgeOffsetManipulatorGeometryInside = pt(this._edgeOffsetManipulatorMaterial, s2, o2 / 2, o2 / 2, i2.height, i2.offset)), null == this._edgeOffsetManipulatorGeometryOutside && (this._edgeOffsetManipulatorGeometryOutside = pt(this._edgeOffsetManipulatorMaterial, -s2, o2 / 2, o2 / 2, i2.height, -i2.offset));
    const l2 = [new e$b(this._edgeOffsetManipulatorGeometryInside.instantiate(), t$9.Unfocused), new e$b(this._edgeOffsetManipulatorGeometryInside.instantiate({ material: this._edgeOffsetManipulatorHoverMaterial }), t$9.Focused), new e$b(this._edgeOffsetManipulatorGeometryOutside.instantiate(), t$9.Unfocused), new e$b(this._edgeOffsetManipulatorGeometryOutside.instantiate({ material: this._edgeOffsetManipulatorHoverMaterial }), t$9.Focused)], p4 = new $({ view: this.view, renderObjects: l2, elevationInfo: "on-the-ground" !== e4.mode || y$5(this.graphic.symbol) ? { mode: "absolute-height", offset: 0 } : e4, worldOriented: false, focusMultiplier: 1, radius: n2, available: !(!this.graphic.visible || !this.graphic.layer?.visible), collisionType: { type: "disc", direction: r$b(0, 0, 1) }, collisionPriority: 1, metadata: { deleting: false } }), h2 = new $({ view: this.view, worldSized: true, worldOriented: false, available: !(!this.graphic.visible || !this.graphic.layer?.visible), collisionPriority: -10, cursor: this.enableMoveGraphic ? "move" : "default", metadata: { deleting: false } }), u3 = { manipulator: p4, handle: t3, locationUpdateHandle: null, type: "edge", selectedIndex: 0, edgeManipulator: h2, elevationInfo: e4, visibilityHandle: null };
    this._autoHideEdgeOffsetManipulator(u3, i2.minSquaredEdgeLength), this._updateEdgeOffsetManipulator(u3);
    const c2 = [];
    for (const r3 of [u3.handle.leftVertex, u3.handle.rightVertex]) {
      const t4 = this._getManipulatorInfoFromHandle(r3);
      null != t4 && c2.push(t4.manipulator.events.on("location-update", () => this._updateEdgeOffsetManipulator(u3)));
    }
    u3.locationUpdateHandle = t$6(c2), this._manipulatorHandles.add(u3.locationUpdateHandle, p4), this._manipulatorHandles.add([this._watchAndUpdateGrabState(p4, true), this._watchAndUpdateGrabState(h2, true)], p4), this._manipulatorHandles.add(d$6(p4, this._createEdgeOffsetPipeline(u3, e4)), p4), this._manipulatorHandles.add(d$6(h2, (t4, i3, a5, n3) => {
      if ("touch" === n3) {
        this._createEdgeOffsetPipeline(u3, e4)(t4, i3, a5);
      } else if (this.enableMoveGraphic) {
        const n4 = this.graphic, o3 = null != n4.geometry ? n4.geometry.spatialReference : null;
        i3.next((t5) => this._trackNumDragging(t5)).next(D$4(this.view, t4.elevationAlignedLocation)).next(T$3(this.view, t4.elevationAlignedLocation, e4, o3, n4)).next(q$4()).next(P$8()).next((t5) => this._perGraphicManipulatorDragAction(Wt.ALL, t5)).next((t5) => (this._updateTranslateGraphicTooltip(c$1.XY, t5), t5)).next((t5) => {
          "end" === t5.action && this._tooltip.clear();
        }), a5.next(() => this._onDragCancel(!t4.metadata.deleting));
      }
    }), p4);
    const m3 = (t4) => {
      this._manipulatorInfos.some((t5) => t5.manipulator.selected) ? this._clearSelection() : this.emit("immediate-click", { ...t4, graphic: this.graphic }), t4.stopPropagation();
    };
    return this._manipulatorHandles.add([p4.events.on("immediate-click", m3), h2.events.on("immediate-click", m3), p4.events.on("focus-changed", ({ action: t4 }) => {
      const { _tooltipOptions: e5, _tooltip: i3 } = this;
      "focus" === t4 && e5.enabled ? (i3.info = this._edgeOffsetTooltipInfo ??= new p$2({ tooltipOptions: e5 }), i3.info.distance = h$8, i3.info.tooltipOptions = e5, this._updateTooltipAreaOrTotalLength(i3.info)) : i3.clear();
    })], p4), this._manipulatorInfos.push(u3), this.manipulators.add(p4), this.manipulators.add(h2), this.emit("manipulators-changed"), u3;
  }
  _autoHideEdgeOffsetManipulator(t3, e4) {
    const i2 = t3.manipulator, a4 = t3.edgeManipulator, n2 = () => {
      t3.visibilityHandle = l$5(t3.visibilityHandle);
      const n3 = this._getManipulatorInfoFromHandle(t3.handle.leftVertex), o2 = this._getManipulatorInfoFromHandle(t3.handle.rightVertex), l2 = null != n3 && null != o2 && h$1(n3.manipulator.renderLocation, o2.manipulator.renderLocation, this.view.state.camera) < e4;
      (!i2.focused && !a4.focused || l2) && (i2.grabbable = !l2, a4.grabbable = !l2, t3.visibilityHandle = t$6([i2.disableDisplay(), e$5(() => {
        i2.grabbable = true, a4.grabbable = this.enableMoveGraphic;
      })]));
    };
    this._manipulatorHandles.add([i2.events.on("focus-changed", n2), a4.events.on("focus-changed", n2), e$5(() => {
      l$5(t3.visibilityHandle), a4.metadata.deleting = true, this.manipulators.remove(a4);
    })], i2), n2();
  }
  _updateEdgeOffsetManipulator(t3) {
    this._updateManipulatorPosition(t3);
    const { coordinateHelper: e4 } = this._editGeometryOperations.data, i2 = a$1(this.view, t3.manipulator.elevationAlignedLocation, m2(e4, t3.handle, t3.manipulator.elevationInfo)), a4 = this._getManipulatorInfoFromHandle(t3.handle.leftVertex), n2 = this._getManipulatorInfoFromHandle(t3.handle.rightVertex);
    if (null == a4 || null == n2)
      return;
    const o2 = a4.manipulator.renderLocation, r3 = n2.manipulator.renderLocation, s2 = null != i2 ? C4(i2, o2, r3) : o$b;
    t3.manipulator.modelTransform = s2, t3.edgeManipulator.elevationAlignedLocation = t3.manipulator.elevationAlignedLocation, t3.edgeManipulator.modelTransform = s2;
    const l2 = s$8(e$e(Xt, o2, r3)) / 2;
    t3.edgeManipulator.collisionType = { type: "line", paths: [[[-l2, 0, 0], [l2, 0, 0]]] };
  }
  _createEdgeOffsetPipeline(t3, e4) {
    return (i2, a4, n2) => {
      this._clearSelection();
      const { step: o2, cleanup: r3 } = this._initializeEdgeOffset(t3, e4);
      a4.next((t4) => this._trackNumDragging(t4)).next(D$4(this.view, i2.elevationAlignedLocation)).next(o2).next(U$6(this.view)).next(k$5(this.view, this._editGeometryOperations.data.spatialReference)).next(P$8()).next(this._applyComputeEdgeOffsetDistanceStep()).next(this._applyEdgeOffsetStep(t3)).next(this._showEdgeOffsetTooltip()).next((t4) => {
        "end" === t4.action && r3();
      }), n2.next(() => {
        i2.metadata.deleting || (r3(), this._onDragCancel());
      });
    };
  }
  _initializeEdgeOffset(t3, e4) {
    const { view: i2 } = this, n2 = this._editGeometryOperations, o2 = m2(n2.data.coordinateHelper, t3.handle, e4), s2 = n2.createUndoGroup(), p4 = a$1(i2, t3.manipulator.elevationAlignedLocation, o2);
    if (o2.requiresSplitEdgeLeft) {
      const e5 = this._getManipulatorInfoFromHandle(t3.handle.leftVertex.leftEdge);
      null != e5 && this._splitEdgeManipulator(e5, 1);
    }
    if (o2.requiresSplitEdgeRight) {
      const e5 = this._getManipulatorInfoFromHandle(t3.handle.rightVertex.rightEdge);
      null != e5 && this._splitEdgeManipulator(e5, 0);
    }
    const d2 = () => new m$5({ paths: [[t3.handle.leftVertex.pos, t3.handle.rightVertex.pos]], spatialReference: n2.data.spatialReference }), u3 = this._settings, c2 = new w2({ view: i2, isDraped: this._graphicState.isDraped, geometry: d2(), elevationInfo: t3.elevationInfo, width: u3.visualElements.lineGraphics.outline.width, attached: false, isDecoration: true });
    let g3;
    const f3 = () => {
      this._cleanEdgeOffsetCollapsedEdges(t3), g3 = l$5(g3);
    }, v2 = this.on("undo", f3);
    return g3 = t$6([d$3(() => E$2(this._accentColor), (t4) => c2.color = t4, P$4), c$8(c2), d$3(() => this._graphicState.isDraped, (t4) => c2.isDraped = t4), this._graphicState.on("changed", () => c2.geometry = d2()), s2, v2]), c2.attached = true, { step: (t4) => null == o2 || null == p4 ? (f3(), null) : { ...t4, operation: o2, plane: p4 }, cleanup: f3 };
  }
  _applyEdgeOffsetStep(t3) {
    return (e4) => {
      if (this.destroyed || null == e4.operation)
        return e4;
      this._updateEventState(qt.RESHAPING);
      const { mapDeltaX: i2, mapDeltaY: a4, mapDeltaZ: n2 } = e4;
      return (i2 || a4 || n2) && (this._offsetEdge(t3, e4), this.emit("reshape", { type: "reshape", mover: this.graphic })), e4;
    };
  }
  _applyComputeEdgeOffsetDistanceStep() {
    return (t3) => {
      const { operation: e4, mapEnd: i2 } = t3;
      return null == e4 || null == i2 ? t3 : ("start" === t3.action && e4.selectArrowFromStartPoint(i2), { ...t3, signedDistance: e4.signedDistanceToPoint(i2) });
    };
  }
  _showEdgeOffsetTooltip() {
    return (t3) => {
      const { mapEnd: e4, signedDistance: i2, operation: a4 } = t3, { _tooltip: n2, _tooltipOptions: o2 } = this;
      return o2.enabled && null != i2 ? (n2.info = this._edgeOffsetTooltipInfo ??= new p$2({ tooltipOptions: o2 }), n2.info.tooltipOptions = o2, n2.info.distance = "end" === t3.action ? h$8 : Ft(this._graphicState.isDraped, i2 * a4.selectedArrow, e4, a4.plane, this._editGeometryOperations.data.coordinateHelper), this._updateTooltipAreaOrTotalLength(n2.info), t3) : (n2.clear(), t3);
    };
  }
  _cleanEdgeOffsetCollapsedEdges(t3) {
    const e4 = t3.handle.leftVertex.leftEdge?.leftVertex, i2 = t3.handle.leftVertex, a4 = t3.handle.rightVertex.rightEdge?.rightVertex, n2 = t3.handle.rightVertex, o2 = this._editGeometryOperations.data.coordinateHelper, r3 = [];
    if (e4 && o2.distance(e4.pos, i2.pos) < Zt) {
      const t4 = this._getManipulatorInfoFromHandle(i2);
      null != t4 && r3.push(t4);
    }
    if (o2.distance(i2.pos, n2.pos) < Zt || a4 && o2.distance(a4.pos, n2.pos) < Zt) {
      const t4 = this._getManipulatorInfoFromHandle(n2);
      null != t4 && r3.push(t4);
    }
    r3.length && this._removeVertices(r3);
  }
  _computeVertexManipulatorSizeAndOutline(t3) {
    const e4 = t3.size / 2, i2 = e4 + t3.collisionPadding;
    return { size: e4 / i2, outlineSize: (e4 + t3.outlineSize) / i2 };
  }
  _createVertexOrEdgeManipulator(t3, e4 = s$5(this.graphic), i2 = false) {
    const { view: a4 } = this, n2 = this._settings;
    if ("edge" === t3.type) {
      if (this.enableEdgeOffset)
        return this._createEdgeOffsetManipulator(t3, e4);
      if (!this.enableMidpoints)
        return null;
    }
    if (null == this._vertexManipulatorGeometry || null == this._vertexManipulatorOutlineGeometry) {
      const { size: t4, outlineSize: e5 } = this._computeVertexManipulatorSizeAndOutline(n2.manipulators.vertex);
      this._vertexManipulatorGeometry = nt(this._vertexManipulatorMaterial, t4, 16, 16), this._vertexManipulatorOutlineGeometry = nt(this._vertexManipulatorOutlineMaterial, e5, 16, 16);
    }
    if (null == this._edgeManipulatorGeometry || null == this._edgeManipulatorOutlineGeometry) {
      const { size: t4, outlineSize: e5 } = this._computeVertexManipulatorSizeAndOutline(n2.manipulators.edge);
      this._edgeManipulatorGeometry = nt(this._edgeManipulatorMaterial, t4, 16, 16), this._edgeManipulatorOutlineGeometry = nt(this._edgeManipulatorOutlineMaterial, e5, 16, 16);
    }
    const { geometry: o2 } = this.graphic, s2 = o2?.type, l2 = "point" === s2 || "mesh" === s2 ? [] : [new e$b(this._vertexManipulatorGeometry.instantiate(), Yt.Vertex | t$9.Unselected), new e$b(this._vertexManipulatorOutlineGeometry.instantiate(), Yt.Vertex | t$9.Unfocused | t$9.Unselected), new e$b(this._vertexManipulatorOutlineGeometry.instantiate({ material: this._vertexManipulatorHoverOutlineMaterial }), Yt.Vertex | t$9.Focused | t$9.Unselected), new e$b(this._vertexManipulatorGeometry.instantiate({ material: this._selectedManipulatorMaterial }), t$9.Selected), new e$b(this._vertexManipulatorOutlineGeometry.instantiate({ material: this._selectedManipulatorOutlineMaterial }), t$9.Selected | t$9.Unfocused), new e$b(this._vertexManipulatorOutlineGeometry.instantiate({ material: this._selectedManipulatorHoverOutlineMaterial }), t$9.Selected | t$9.Focused)];
    this.enableMidpoints && l2.push(new e$b(this._edgeManipulatorGeometry.instantiate({ material: this._vertexManipulatorMaterial }), Yt.Edge | t$9.Focused | t$9.Unselected), new e$b(this._edgeManipulatorOutlineGeometry.instantiate({ material: this._vertexManipulatorHoverOutlineMaterial }), Yt.Edge | t$9.Focused | t$9.Unselected), new e$b(this._edgeManipulatorGeometry.instantiate(), Yt.Edge | t$9.Unfocused | t$9.Unselected), new e$b(this._edgeManipulatorOutlineGeometry.instantiate(), Yt.Edge | t$9.Unfocused | t$9.Unselected));
    const p4 = new $({ view: a4, renderObjects: l2, elevationInfo: e4, focusMultiplier: 1, touchMultiplier: 1, available: !(!this.graphic.visible || !this.graphic.layer?.visible), metadata: { deleting: false } });
    p4.selected = i2, this._setTypeSpecificManipulatorSettings(p4, t3, e4);
    const d2 = "edge" === t3.type ? { manipulator: p4, handle: t3, locationUpdateHandle: null, type: "edge", selectedIndex: 0 } : { manipulator: p4, handle: t3, type: "vertex", selectedIndex: 0 };
    if (this._manipulatorInfos.push(d2), this.manipulators.add(p4), this._updateManipulatorPosition(d2), "edge" === d2.type) {
      const t4 = [];
      for (const e5 of [d2.handle.leftVertex, d2.handle.rightVertex]) {
        const i3 = this._getManipulatorInfoFromHandle(e5);
        null != i3 && t4.push(i3.manipulator.events.on("location-update", () => this._updateManipulatorPosition(d2)));
      }
      d2.locationUpdateHandle = t$6(t4), this._manipulatorHandles.add(d2.locationUpdateHandle, p4);
    }
    this._manipulatorHandles.add(this._watchAndUpdateGrabState(p4, true), p4);
    const u3 = d$6(p4, (t4, i3, a5, n3) => {
      let o3 = null;
      const { snappingStep: r3, cancelSnapping: s3 } = f$a({ predicate: () => !this._isMultiVertexSelection(), snappingManager: this.tool.snappingManager, snappingContext: new e$f({ editGeometryOperations: this._editGeometryOperations, elevationInfo: e4, pointer: n3, excludeFeature: this.graphic, visualizer: new O$2() }), updatingHandles: this._updatingHandles, useZ: false });
      a5 = a5.next((e5) => (this._onDragCancel(!t4.metadata.deleting, () => o3 = l$5(o3)), e5)).next(s3), i3.next((t5) => this._trackNumDragging(t5)).next((t5) => {
        if ("start" === t5.action && (o3 = this._editGeometryOperations.createUndoGroup()), "edge" === d2.type) {
          const e5 = this._splitEdgeManipulator(d2);
          return { ...t5, info: e5, snapOrigin: e5.handle.pos };
        }
        return { ...t5, info: d2, snapOrigin: d2.handle.pos };
      }).next(D$4(this.view, t4.elevationAlignedLocation)).next(D$5(this.view, this.graphic, t4.elevationAlignedLocation, t4.location.spatialReference, this.graphic)).next(C$5(this.view, e4, this.graphic)).next(...r3).next(P$8()).next((e5) => {
        this._perVertexManipulatorDragAction(e5), "end" === e5.action && (o3 = l$5(o3)), this._updateTranslateVertexTooltip(t4, c$1.XY, e5);
      });
    });
    return this._manipulatorHandles.add([u3, p4.events.on("immediate-click", (t4) => this._manipulatorClickCallback(t4, d2)), p4.events.on("select-changed", () => {
      d2.selectedIndex = ++this._selectedIndex, this._updateMoveManipulationPosition();
    }), p4.events.on("focus-changed", ({ action: t4 }) => {
      "focus" === t4 && "edge" !== d2.type ? this._updateTranslateVertexTooltip(p4, c$1.XY) : this._tooltip.clear();
    })], p4), this.emit("manipulators-changed"), d2;
  }
  _trackNumDragging(t3) {
    switch (t3.action) {
      case "start":
        this._numDragging++;
        break;
      case "end":
        this._numDragging--;
    }
    return t3;
  }
  _onDragCancel(t3 = true, e4) {
    switch (this._numDragging--, t3 && (this.undo(), this.outputGeometry = null != this._editGeometryOperations ? this._editGeometryOperations.data.geometry : null), null != this.tool.snappingManager && this.tool.snappingManager.doneSnapping(), this._tooltip.clear(), this._reshapeEventState) {
      case qt.NONE:
        break;
      case qt.MOVING:
        this.emit("move", { type: "move", dx: 0, dy: 0, mover: this.graphic });
        break;
      case qt.RESHAPING:
        this.emit("reshape", { type: "reshape", mover: this.graphic });
    }
    e4 && e4(), this.destroyed || this._updateEventState(qt.NONE);
  }
  _setTypeSpecificManipulatorSettings(t3, e4, i2) {
    const { graphic: a4 } = this, n2 = this._settings;
    switch (e4.type) {
      case "vertex": {
        t3.state = Yt.Vertex, t3.selectable = true, t3.cursor = "move", t3.collisionPriority = 2;
        const { size: e5, collisionPadding: o2 } = n2.manipulators.vertex;
        t3.radius = e5 / 2 + o2, t3.elevationInfo = i2;
        const { geometry: r3 } = a4, s2 = r3?.type;
        t3.interactive = null != s2 && "point" !== s2 && "mesh" !== s2;
        break;
      }
      case "edge": {
        t3.state = Yt.Edge, t3.selectable = false, t3.cursor = "copy", t3.collisionPriority = -1;
        const { size: e5, collisionPadding: o2 } = n2.manipulators.edge;
        t3.radius = e5 / 2 + o2, t3.elevationInfo = "on-the-ground" !== i2.mode || y$5(a4.symbol) ? { mode: "absolute-height", offset: 0 } : i2;
        break;
      }
    }
  }
  _watchAndUpdateGrabState(t3, e4) {
    return t3.events.on("grab-changed", (i2) => this._onGrabStateChanged(t3, e4, i2.action, i2.pointerType));
  }
  _onGrabStateChanged(t3, e4, i2, a4 = "mouse") {
    if (!this._recreatingManipulators) {
      if ("start" === i2)
        e4 && this._updateSelection(t3), this._numGrabbing++;
      else if (this._numGrabbing--, this._updateEventState(qt.NONE), this.destroyed)
        return;
      this._moveManipulation.interactive = !this._numGrabbing, ("touch" !== a4 || this.enableEdgeOffset) && (this._manipulatorInfos.forEach((t4) => {
        const { manipulator: e5 } = t4, { geometry: i3 } = this.graphic, a5 = i3?.type;
        e5.interactive = e5.grabbing || !this._numGrabbing && null != a5 && "point" !== a5 && "mesh" !== a5, "edgeManipulator" in t4 && (t4.edgeManipulator.interactive = t4.edgeManipulator.grabbing || !this._numGrabbing);
      }), this._graphicMoveManipulation.forEachManipulator((t4) => {
        t4.interactive = t4.grabbing || !this._numGrabbing;
      }));
    }
  }
  _clearSelection() {
    for (const t3 of this._manipulatorInfos)
      t3.manipulator.grabbing || (t3.manipulator.selected = false);
  }
  _updateSelection(t3) {
    t3.grabbing && !t3.selected && t3.selectable && (this._clearSelection(), t3.selected = true, this.emit("manipulators-changed"));
  }
  _removeManipulator(t3) {
    null != t3 && (t3.manipulator.metadata.deleting = true, this.manipulators.remove(t3.manipulator), this._manipulatorHandles.remove(t3.manipulator), z$5(this._manipulatorInfos, t3), this.emit("manipulators-changed"));
  }
  _getManipulatorInfoFromHandle(t3) {
    if (t3) {
      for (const e4 of this._manipulatorInfos)
        if (t3 === e4.handle)
          return e4;
    }
    return null;
  }
  _updateManipulatorPosition(t3) {
    if (null == t3)
      return;
    const e4 = this._editGeometryOperations;
    if ("vertex" === t3.type)
      t3.manipulator.location = e4.data.coordinateHelper.vectorToDehydratedPoint(t3.handle.pos, zt), t3.manipulator.grabbing && null != this._vertexLaserLineVisualElement && (this._vertexLaserLineVisualElement.visualElement.intersectsWorldUpAtLocation = t3.manipulator.renderLocation);
    else if ("edge" === t3.type) {
      const i2 = this._getManipulatorInfoFromHandle(t3.handle.leftVertex), a4 = this._getManipulatorInfoFromHandle(t3.handle.rightVertex);
      if (null == i2 || null == a4)
        return;
      const n2 = i2.manipulator, o2 = a4.manipulator;
      if (null != t3.manipulator.elevationInfo && "on-the-ground" === t3.manipulator.elevationInfo.mode) {
        const i3 = n2.location, a5 = o2.location, r3 = 0.5, s2 = i3.x + r3 * (a5.x - i3.x), l2 = i3.y + r3 * (a5.y - i3.y), p4 = i3.hasZ && a5.hasZ ? 0 : void 0;
        t3.manipulator.location = e$7(s2, l2, p4, e4.data.spatialReference);
      } else
        A$8(Xt, n2.renderLocation, o2.renderLocation, 0.5), t3.manipulator.renderLocation = Xt;
    }
  }
  _splitEdgeManipulator(t3, e4 = 0.5) {
    const i2 = this._editGeometryOperations, a4 = i2.splitEdge(t3.handle, e4).createdVertex;
    t3.locationUpdateHandle = l$5(t3.locationUpdateHandle);
    const n2 = s$5(this.graphic);
    let o2;
    this.enableEdgeOffset ? (this._removeManipulator(t3), o2 = this._createVertexOrEdgeManipulator(a4)) : (o2 = t3, o2.handle = a4, o2.type = "vertex", this._setTypeSpecificManipulatorSettings(t3.manipulator, t3.handle, n2)), a4.leftEdge && this._createVertexOrEdgeManipulator(a4.leftEdge), a4.rightEdge && this._createVertexOrEdgeManipulator(a4.rightEdge), this.outputGeometry = i2.data.geometry, this._updateManipulatorPosition(o2), this.enableEdgeOffset || this._updateTranslateVertexTooltip(o2.manipulator, c$1.XY), this._updateSelection(t3.manipulator);
    const r3 = this._updateEventState(qt.RESHAPING), s2 = i2.data.coordinateHelper.vectorToArray(o2.handle.pos), l2 = i2.data.components.indexOf(a4.component);
    return this.emit("vertex-add", { type: "vertex-add", vertices: [{ coordinates: s2, componentIndex: l2, vertexIndex: a4.index }], added: s2 }), r3 && this._updateEventState(qt.NONE), o2;
  }
  _updateMoveManipulationPosition() {
    const t3 = o$5(Xt, 0, 0, 0);
    let e4 = 0, i2 = false, a4 = null, n2 = null;
    for (const o2 of this._manipulatorInfos)
      "vertex" === o2.type && (o2.manipulator.selected ? (e4++, u$6(t3, t3, o2.manipulator.renderLocation), null == a4 || o2.selectedIndex > a4.selectedIndex ? (n2 = a4, a4 = o2) : (null == n2 || o2.selectedIndex > n2.selectedIndex) && (n2 = o2)) : i2 = true);
    if (0 === e4) {
      const t4 = this._graphicState.displaying && this.enableMoveGraphic;
      this._moveManipulation.xyManipulation.available = t4, this._moveManipulation.xyAxisManipulation.available = t4, this._moveManipulation.xyAxisManipulation.orthogonalAvailable = t4, this._moveManipulation.zManipulation.available = t4 && this.enableZShape && n$6(this.graphic), this._moveManipulation.angle = r$3(this.graphic.geometry), this._moveManipulation.radius = u$1.radiusForSymbol(this.graphic.symbol);
    } else {
      const t4 = this._graphicState.displaying;
      this._moveManipulation.xyManipulation.available = t4, this._moveManipulation.xyAxisManipulation.available = t4, this._moveManipulation.zManipulation.available = t4 && this.enableZVertex && n$6(this.graphic), this._moveManipulation.xyAxisManipulation.orthogonalAvailable = t4 && 1 !== e4;
      let i3 = 0;
      if (null != a4) {
        const t5 = a4.handle.pos, e5 = null != n2 ? n2.handle.pos : a4.handle.leftEdge && a4.handle.leftEdge.leftVertex ? a4.handle.leftEdge.leftVertex.pos : null, o2 = null == n2 && a4.handle.rightEdge && a4.handle.rightEdge.rightVertex ? a4.handle.rightEdge.rightVertex.pos : null;
        e5 && o2 ? this._moveManipulation.xyAxisManipulation.available = false : e5 ? i3 = Rt$1(e5, t5) : o2 && (i3 = Rt$1(t5, o2));
      }
      this._moveManipulation.angle = i3, this._moveManipulation.radius = o$1;
    }
    0 !== e4 && i2 ? (g$3(t3, t3, 1 / e4), zt.spatialReference = this._editGeometryOperations.data.spatialReference, zt.hasZ = true, this.view.renderCoordsHelper.fromRenderCoords(t3, zt), this._moveManipulation.elevationAlignedLocation = zt) : null == this._outlineVisualElement || this._graphicState.isDraped || null == this._outlineVisualElement.attachmentOrigin ? v$5(this.view, this._moveManipulation, this.graphic) : this._moveManipulation.elevationAlignedLocation = this._outlineVisualElement.attachmentOrigin;
  }
  _removeVertices(t3) {
    const e4 = new Array(), i2 = this._editGeometryOperations;
    for (const a4 of t3)
      if ("vertex" === a4.type && i2.canRemoveVertex(a4.handle.component)) {
        e4.push(a4.handle), this._removeManipulator(a4), this._removeManipulator(this._getManipulatorInfoFromHandle(a4.handle.leftEdge)), this._removeManipulator(this._getManipulatorInfoFromHandle(a4.handle.rightEdge));
        const t4 = i2.removeVertices([a4.handle]), n2 = t4.removedVertices?.[0].createdEdge;
        n2 && this._createVertexOrEdgeManipulator(n2);
      }
    if (e4.length > 0) {
      const t4 = e4.map((t5) => {
        const e5 = i2.data.components.indexOf(t5.component);
        return { coordinates: i2.data.coordinateHelper.vectorToArray(t5.pos), componentIndex: e5, vertexIndex: t5.index };
      });
      this.outputGeometry = i2.data.geometry;
      const a4 = this._updateEventState(qt.RESHAPING);
      if (this.destroyed)
        return;
      if (this.emit("vertex-remove", { type: "vertex-remove", removed: t4.map((t5) => t5.coordinates), vertices: t4 }), this.destroyed)
        return;
      if (a4 && (this._updateEventState(qt.NONE), this.destroyed))
        return;
      this._updateMoveManipulationPosition();
    }
  }
  _moveVertices(t3, e4, i2 = "start" === e4.action ? E$3.NEW_STEP : E$3.ACCUMULATE_STEPS) {
    const a4 = this._editGeometryOperations;
    a4.moveVertices(t3.map((t4) => t4.handle), e4.mapDeltaX, e4.mapDeltaY, e4.mapDeltaZ, i2), this.outputGeometry = a4.data.geometry;
    for (const n2 of t3)
      this._updateManipulatorPosition(n2);
  }
  _offsetEdge(t3, e4) {
    if (null == e4.operation || null == e4.signedDistance)
      return;
    const i2 = this._editGeometryOperations, a4 = e4.operation.clone();
    a4.distance = e4.signedDistance, i2.updateVertices([t3.handle.leftVertex, t3.handle.rightVertex], a4), this.outputGeometry = i2.data.geometry, this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(t3.handle.leftVertex)), this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(t3.handle.rightVertex));
  }
  _manipulatorClickCallback(t3, e4) {
    t3.shiftKey || this._clearSelection(), "vertex" === e4.type && (e4.manipulator.selected = !e4.manipulator.selected, t3.button === t$b.Right && this._removeVertices([e4])), "edge" === e4.type && t3.button === t$b.Left && this._splitEdgeManipulator(e4), t3.stopPropagation();
  }
  _updateTranslateTooltip(t3, e4) {
    const i2 = this._manipulatorInfos.filter((t4) => "vertex" === t4.type && t4.manipulator.selected);
    1 === i2.length ? this._updateTranslateVertexTooltip(i2[0].manipulator, t3, e4) : this._updateTranslateGraphicTooltip(t3, e4);
  }
  _updateTranslateGraphicTooltip(t3, e4) {
    const { _tooltipOptions: i2, _tooltip: a4 } = this;
    if (!i2.enabled)
      return;
    const n2 = this._graphicState.isDraped ? "on-the-ground" : "absolute-height";
    switch (t3) {
      case c$1.XY:
        a4.info = this._translateGraphicTooltipInfo ??= new r$c({ tooltipOptions: i2 }), this._updateTranslateTooltipDistance(a4.info, e4, (t4, e5) => s$6(t4, e5, n2));
        break;
      case c$1.XY_AXIS:
        a4.info = this._translateGraphicXYTooltipInfo ??= new l$8({ tooltipOptions: i2 }), this._updateTranslateTooltipDistance(a4.info, e4, (t4, i3) => {
          const a5 = s$6(t4, i3, n2);
          return m$4(a5, a$2(e4));
        });
        break;
      case c$1.Z:
        a4.info = this._translateGraphicZTooltipInfo ??= new a$b({ tooltipOptions: i2 }), this._updateTranslateTooltipDistance(a4.info, e4, y$3);
    }
    a4.info.tooltipOptions = i2;
  }
  _updateTranslateVertexTooltip(t3, e4, i2) {
    const { _tooltipOptions: a4, _tooltip: n2 } = this;
    if (!a4.enabled)
      return;
    const o2 = this._graphicState.isDraped ? "on-the-ground" : "absolute-height";
    switch (e4) {
      case c$1.XY:
        n2.info = this._translateVertexTooltipInfo ??= new p$7({ tooltipOptions: a4 }), this._updateTranslateTooltipDistance(n2.info, i2, (t4, e5) => s$6(t4, e5, o2)), this._updateTooltipAreaOrTotalLength(n2.info);
        break;
      case c$1.XY_AXIS:
        n2.info = this._translateVertexXYTooltipInfo ??= new c$c({ tooltipOptions: a4 }), this._updateTranslateTooltipDistance(n2.info, i2, (t4, e5) => {
          const a5 = s$6(t4, e5, o2);
          return m$4(a5, a$2(i2));
        }), this._updateTooltipAreaOrTotalLength(n2.info);
        break;
      case c$1.Z:
        n2.info = this._translateVertexZTooltipInfo ??= new n$7({ tooltipOptions: a4 }), this._updateTranslateTooltipDistance(n2.info, i2, y$3);
    }
    const r3 = R$6(t3.elevationAlignedLocation);
    null != r3 && (n2.info.elevation = g$6({ actual: r3 })), n2.info.tooltipOptions = a4;
  }
  _updateTranslateTooltipDistance(t3, e4, i2) {
    if (null != e4 && "end" !== e4.action) {
      const { mapStart: a4, mapEnd: n2 } = e4, o2 = i2(a4, n2);
      t3.distance = null != o2 ? o2 : h$8;
    } else
      t3.distance = h$8;
  }
  _updateTooltipAreaOrTotalLength(t3) {
    const { geometry: e4 } = this.graphic;
    if (null == e4)
      return t3.area = null, void (t3.totalLength = null);
    const i2 = this._graphicState.isDraped ? "on-the-ground" : "absolute-height";
    t3.area = "polygon" === e4.type ? o$c(e4, i2) : null, t3.totalLength = "polyline" === e4.type ? p$8(e4, i2) : null;
  }
  get test() {
    return { segmentLabels: this._segmentLabels, tooltip: this._tooltip };
  }
};
function Rt$1(t3, e4) {
  return Math.atan2(e4[1] - t3[1], e4[0] - t3[0]) + Math.PI / 2;
}
function Ft(t3, e4, i2, a4, n2) {
  if (t3) {
    const t4 = n2.toXYZ(n2.pointToVector(i2)), o2 = Y$1(a4, t4, c$9.get()), r3 = p$9(o2, t4, n2.spatialReference);
    if (null != r3)
      return i$9(r3.value * Math.sign(e4), r3.unit);
  }
  return i$9(e4 * z$2(i2.spatialReference), "meters");
}
e$4([y$1()], kt$1.prototype, "_editGeometryOperations", void 0), e$4([y$1()], kt$1.prototype, "_segmentLabels", void 0), e$4([y$1({ constructOnly: true })], kt$1.prototype, "tool", void 0), e$4([y$1()], kt$1.prototype, "_tooltip", void 0), e$4([y$1()], kt$1.prototype, "inputGeometry", null), e$4([y$1()], kt$1.prototype, "outputGeometry", void 0), e$4([y$1({ readOnly: true })], kt$1.prototype, "updating", null), e$4([y$1()], kt$1.prototype, "manipulators", null), e$4([y$1()], kt$1.prototype, "view", null), e$4([y$1()], kt$1.prototype, "graphic", null), e$4([y$1()], kt$1.prototype, "enableZShape", null), e$4([y$1()], kt$1.prototype, "enableZVertex", null), e$4([y$1()], kt$1.prototype, "enableMoveGraphic", null), e$4([y$1()], kt$1.prototype, "enableMidpoints", null), e$4([y$1()], kt$1.prototype, "enableEdgeOffset", null), e$4([y$1()], kt$1.prototype, "_labelOptions", null), e$4([y$1()], kt$1.prototype, "_tooltipOptions", null), e$4([y$1()], kt$1.prototype, "_accentColor", null), kt$1 = e$4([c$5("esri.views.3d.interactive.editingTools.reshapeGraphic.ReshapeOperation")], kt$1);
const zt = e$7(0, 0, void 0, f$b.WGS84), Xt = n$4(), Zt = 1e-6;
var Yt, qt, Wt;
!function(t3) {
  t3.Vertex = u$9.Custom1, t3.Edge = u$9.Custom2;
}(Yt || (Yt = {})), function(t3) {
  t3[t3.NONE = 0] = "NONE", t3[t3.MOVING = 1] = "MOVING", t3[t3.RESHAPING = 2] = "RESHAPING";
}(qt || (qt = {})), function(t3) {
  t3[t3.ALL = 0] = "ALL", t3[t3.SELECTED_OR_ALL = 1] = "SELECTED_OR_ALL";
}(Wt || (Wt = {}));
let u2 = class extends o$4.EventedMixin(l$7) {
  constructor(e4) {
    super(e4), this._internalGeometryUpdate = false, this.enableZShape = true, this.enableZVertex = true, this.enableMoveGraphic = true, this.enableMidpoints = true, this.enableEdgeOffset = false, this.type = "reshape-3d", this.labelOptions = new c$d(), this.tooltipOptions = new p$6(), this.snappingManager = null, this.automaticManipulatorSelection = false;
  }
  initialize() {
    const e4 = this._reshapeOperation = new kt$1({ tool: this });
    this.addHandles([e4.on("reshape", (e5) => {
      "reshape" === e5.type && this._onReshapeGeometryChanged(), this.emit("reshape", e5);
    }), e4.on("move", (e5) => {
      "move" === e5.type && this._onReshapeGeometryChanged(), this.emit("move", e5);
    }), e4.on("vertex-add", (e5) => {
      this._onReshapeGeometryChanged(), this.emit("vertex-add", e5);
    }), e4.on("vertex-remove", (e5) => {
      this._onReshapeGeometryChanged(), this.emit("vertex-remove", e5);
    }), e4.on("immediate-click", (e5) => this.emit("immediate-click", e5)), this.view.on("pointer-down", ["Shift"], (e5) => e5.stopPropagation()), d$3(() => this.graphic, () => this._updateGraphic(), A$7)]), this.finishToolCreation();
  }
  destroy() {
    this._reshapeOperation = u$7(this._reshapeOperation);
  }
  get updating() {
    return this._reshapeOperation?.updating ?? false;
  }
  _updateGeometry() {
    const e4 = l$9(this.graphic);
    this._reshapeOperation.inputGeometry = null != e4 ? e4.clone() : null;
  }
  _updateGraphic() {
    if (this.removeHandles("onGraphicGeometryChange"), this._updateGeometry(), n$8(this.graphic) !== P$9.SUPPORTED)
      return;
    const e4 = d$3(() => this.graphic?.geometry, () => {
      false === this._internalGeometryUpdate && this._updateGeometry();
    }, C$6);
    this.addHandles(e4, "onGraphicGeometryChange");
  }
  onManipulatorSelectionChanged() {
    this._reshapeOperation && this._reshapeOperation.onManipulatorSelectionChanged();
  }
  _updateGeometryInternally(e4) {
    this._internalGeometryUpdate = true;
    const { graphic: t3 } = this, { geometry: o2 } = t3;
    "mesh" === o2?.type && "point" === e4.type ? (t3.geometry = o2.centerAt(e4), t3.notifyGeometryChanged()) : t3.geometry = e4, this._internalGeometryUpdate = false;
  }
  _onReshapeGeometryChanged() {
    const { outputGeometry: e4 } = this._reshapeOperation;
    null != this.graphic && e4 && this._updateGeometryInternally(e4.clone());
  }
  get canUndo() {
    return this._reshapeOperation.canUndo ?? false;
  }
  undo() {
    null != this.snappingManager && this.snappingManager.doneSnapping();
    const e4 = this._reshapeOperation.undo(), { outputGeometry: t3 } = this._reshapeOperation;
    e4 && t3 && this._updateGeometryInternally(t3.clone());
  }
  get canRedo() {
    return this._reshapeOperation.canRedo ?? false;
  }
  redo() {
    null != this.snappingManager && this.snappingManager.doneSnapping();
    const e4 = this._reshapeOperation.redo(), { outputGeometry: t3 } = this._reshapeOperation;
    e4 && t3 && this._updateGeometryInternally(t3.clone());
  }
  onInputEvent(e4) {
    "key-down" !== e4.type || "Delete" !== e4.key && "Backspace" !== e4.key || this._reshapeOperation.removeSelectedVertices();
  }
  reset() {
  }
  get test() {
    return { snappingManager: this.snappingManager, reshapeOperation: this._reshapeOperation };
  }
};
e$4([y$1()], u2.prototype, "_reshapeOperation", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], u2.prototype, "view", void 0), e$4([y$1({ constructOnly: true })], u2.prototype, "graphic", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], u2.prototype, "enableZShape", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], u2.prototype, "enableZVertex", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], u2.prototype, "enableMoveGraphic", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], u2.prototype, "enableMidpoints", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], u2.prototype, "enableEdgeOffset", void 0), e$4([y$1()], u2.prototype, "type", void 0), e$4([y$1({ constructOnly: true, type: c$d })], u2.prototype, "labelOptions", void 0), e$4([y$1({ constructOnly: true, type: p$6 })], u2.prototype, "tooltipOptions", void 0), e$4([y$1({ constructOnly: true })], u2.prototype, "snappingManager", void 0), e$4([y$1()], u2.prototype, "updating", null), e$4([y$1()], u2.prototype, "automaticManipulatorSelection", void 0), u2 = e$4([c$5("esri.views.3d.interactive.editingTools.graphicReshape3D.GraphicReshapeTool")], u2);
let r$1 = class r extends s$7 {
  constructor(o2) {
    super(o2), this.type = "transform-rotate", this.rotation = null, this.rotationPrecision = null, this.orientation = null, this.orientationPrecision = null, this.rotationType = "geographic";
  }
};
e$4([y$1()], r$1.prototype, "type", void 0), e$4([y$1()], r$1.prototype, "rotation", void 0), e$4([y$1()], r$1.prototype, "rotationPrecision", void 0), e$4([y$1()], r$1.prototype, "orientation", void 0), e$4([y$1()], r$1.prototype, "orientationPrecision", void 0), e$4([y$1()], r$1.prototype, "rotationType", void 0), r$1 = e$4([c$5("esri.views.interactive.tooltip.TransformRotateTooltipInfo")], r$1);
let s = class extends s$7 {
  constructor(o2) {
    super(o2), this.type = "transform-scale", this.size = null, this.sizeUnit = null, this.sizePrecision = null;
  }
};
e$4([y$1()], s.prototype, "type", void 0), e$4([y$1()], s.prototype, "scale", void 0), e$4([y$1()], s.prototype, "size", void 0), e$4([y$1()], s.prototype, "sizeUnit", void 0), e$4([y$1()], s.prototype, "sizePrecision", void 0), s = e$4([c$5("esri.views.interactive.tooltip.TransformScaleTooltipInfo")], s);
let p$1 = class p2 extends s$7 {
  constructor(o2) {
    super(o2), this.type = "transform-absolute", this.orientation = null, this.orientationPrecision = null, this.rotationType = "geographic", this.size = null, this.sizePrecision = null, this.sizeUnit = null;
  }
};
e$4([y$1()], p$1.prototype, "type", void 0), e$4([y$1()], p$1.prototype, "orientation", void 0), e$4([y$1()], p$1.prototype, "orientationPrecision", void 0), e$4([y$1()], p$1.prototype, "rotationType", void 0), e$4([y$1()], p$1.prototype, "size", void 0), e$4([y$1()], p$1.prototype, "sizePrecision", void 0), e$4([y$1()], p$1.prototype, "sizeUnit", void 0), p$1 = e$4([c$5("esri.views.interactive.tooltip.TransformAbsoluteTooltipInfo")], p$1);
var yt;
!function(t3) {
  t3.ScaleIn = u$9.Custom2, t3.ScaleOut = u$9.Custom3, t3.RotateLeft = u$9.Custom4, t3.RotateRight = u$9.Custom5, t3.Unlocked = u$9.Custom7, t3.DelayedFocused = u$9.Custom8, t3.TouchInput = u$9.Custom12;
}(yt || (yt = {}));
let Tt = class extends g$2 {
  get angle() {
    return this.adapter.angle;
  }
  get scale() {
    return this.adapter.scale;
  }
  set location(t3) {
    this._ringManipulator.location = t3;
  }
  set elevationAlignedLocation(t3) {
    this._ringManipulator.elevationAlignedLocation = t3;
  }
  get grabbing() {
    return this._ringManipulator.grabbing;
  }
  set interactive(t3) {
    this._ringManipulator.interactive = t3;
  }
  get updating() {
    return !!this._activeAnimation;
  }
  constructor(t3) {
    super(t3), this.mode = null, this._scaleRotateDragData = null, this._activeAnimation = null, this._ringIndicatorDelayMs = q$1, this._absoluteTooltipInfo = null, this._scaleTooltipInfo = null, this._rotateTooltipInfo = null, this.events = new o$4(), this.getFocused = () => this._ringManipulator.focused, this.getScale = () => "scale" === this._scaleRotateDragData?.mode ? this.adapter.scale : 1;
  }
  initialize() {
    this._tooltip = new u$8({ view: this.tool.view }), this._createManipulator(), this._updateDragState(), this._updateManipulatorTransform(), this.addHandles([p$5(() => !this.tooltipOptions.enabled, () => this._tooltip.clear(), P$4), d$3(() => {
      const { adapter: t3 } = this, { info: e4 } = this._tooltip;
      return e4 === this._absoluteTooltipInfo && this.getFocused() ? [e4, t3.size, t3.orientationClockwise] : [null];
    }, ([t3]) => {
      t3 && this._updateFocusTooltip();
    })]);
  }
  destroy() {
    this._activeAnimation?.frameTask.remove(), this._activeAnimation = null, this.tool.manipulators.remove(this._ringManipulator), this._ringManipulator = null, this._tooltip = u$7(this._tooltip);
  }
  startAnimation(t3) {
    this.cancelActiveAnimation(), t3.start();
    const e4 = v$6({ update: ({ deltaTime: e5 }) => {
      t3.update(e5) && this.cancelActiveAnimation();
    } });
    this._activeAnimation = { ...t3, frameTask: e4 };
  }
  cancelActiveAnimation() {
    this._activeAnimation?.frameTask.remove(), this._activeAnimation = u$7(this._activeAnimation);
  }
  forEachManipulator(t3) {
    t3(this._ringManipulator, A$3.SCALE_ROTATE);
  }
  _createManipulator() {
    const t3 = this._createRingManipulator();
    this._ringManipulator = t3, this.tool.manipulators.add(t3);
    const e4 = this.tool.graphicState.graphic, a4 = d$6(t3, (t4, a5, o2) => {
      this._scaleRotateDragData = null;
      const n2 = this.adapter.startInteraction(), l2 = { mode: "none", origin: t$c(t4.renderLocation), initialAngle: this.adapter.angle, angle: 0, angleDir: 0, scaleDir: 0 };
      this._scaleRotateDragData = l2, this._updateDragState();
      const c2 = c$9.get();
      this.tool.view.renderCoordsHelper.worldUpAtPosition(t4.renderLocation, c2), a5.next(H$2(this.tool.view, k$4(t4.renderLocation, c2, b$5()))).next((t5) => {
        const a6 = ot$1(t5.plane), o3 = F$1(t5.renderStart, t5.renderEnd, l2.origin, a6), c3 = r$d.shortestSignedDiff(l2.angle, o3);
        l2.angleDir = i$8(l2.angleDir + c3, -m$1, m$1), l2.angle = o3;
        const p4 = bt(l2, t5), h2 = p4 - this.adapter.scale;
        if (l2.scaleDir = i$8(l2.scaleDir + h2, -k$1, k$1), this._onScaleChanged(), "none" === l2.mode) {
          const a7 = this.mode || wt(t5, t5.plane, l2.origin, this.tool.view.state.camera);
          if (null != a7) {
            switch (a7) {
              case "rotate":
                this.tool.emit("graphic-rotate-start", { graphic: e4, angle: 0 }), this.tool.emit("record-undo", { record: this.adapter.createUndoRecord() });
                break;
              case "scale":
                this.tool.emit("graphic-scale-start", { graphic: e4, xScale: 1, yScale: 1 }), this.tool.emit("record-undo", { record: this.adapter.createUndoRecord() });
            }
            l2.mode = a7;
          }
        }
        switch (l2.mode) {
          case "rotate":
            n2.state.angle = l2.initialAngle + o3;
            break;
          case "scale":
            n2.state.scale = p4, this._onScaleChanged();
        }
        switch (this._updateDragState(), this._updateManipulatorTransform(), t5.action) {
          case "start":
          case "update":
            switch (l2.mode) {
              case "rotate":
                this.tool.emit("graphic-rotate", { graphic: e4, angle: m$6(l2.angle) });
                break;
              case "scale":
                this.tool.emit("graphic-scale", { graphic: e4, xScale: p4, yScale: p4 });
            }
            break;
          case "end":
            switch (l2.mode) {
              case "rotate":
                this.tool.emit("graphic-rotate-stop", { graphic: e4, angle: m$6(l2.angle) });
                break;
              case "scale":
                this.tool.emit("graphic-scale-stop", { graphic: e4, xScale: p4, yScale: p4 });
            }
        }
        return "end" === t5.action && (this.startAnimation(It(this, () => this._onScaleChanged())), this._scaleRotateDragData = null, this._updateDragState(), n2.done()), t5;
      }).next(this._updateTooltipPipelineStep(l2)), o2.next(() => {
        if (n2.cancel(), null != this._scaleRotateDragData) {
          switch (this._scaleRotateDragData.mode) {
            case "none":
              break;
            case "rotate":
              this.tool.emit("graphic-rotate-stop", { graphic: e4, angle: 0 });
              break;
            case "scale":
              this.tool.emit("graphic-scale-stop", { graphic: e4, xScale: 1, yScale: 1 });
          }
          this.startAnimation(It(this, () => this._onScaleChanged())), this._scaleRotateDragData = null, this._updateDragState();
        }
        this._updateFocusTooltip();
      });
    });
    this.addHandles([a4, t3.events.on("focus-changed", (t4) => {
      "focus" === t4.action ? this.startAnimation(Ot(this, () => this._updateDelayedFocusedState(), { delayMs: this._ringIndicatorDelayMs })) : this._updateDelayedFocusedState();
    }), t3.events.on("immediate-click", (t4) => {
      t4.stopPropagation();
    }), d$3(() => this.tool.graphicState?.displaying, (t4) => this._ringManipulator.available = t4, P$4)]);
  }
  _updateTooltipPipelineStep(t3) {
    return (e4) => {
      const a4 = this.tooltipOptions;
      if (!a4.enabled)
        return e4;
      if ("end" === e4.action)
        return this._updateFocusTooltip(), e4;
      const i2 = this._tooltip, o2 = this.tooltipOptions.visualVariables;
      switch (t3.mode) {
        case "scale": {
          i2.info = this._scaleTooltipInfo ??= new s({ tooltipOptions: a4 });
          const { size: t4, scale: e5 } = this.adapter, s$12 = o2?.size, r3 = i2.info;
          r3.tooltipOptions = a4, r3.scale = { value: e5 }, r3.size = null != t4 ? i$9(t4, "meters") : void 0, r3.sizePrecision = kt2(s$12?.valueType), r3.sizeUnit = s$12?.unit;
          break;
        }
        case "rotate": {
          i2.info = this._rotateTooltipInfo ??= new r$1({ tooltipOptions: a4 });
          const { orientationClockwise: t4, relativeAngleClockwise: e5 } = this.adapter, s2 = o2?.rotation, r3 = kt2(s2?.valueType), n2 = i2.info;
          n2.tooltipOptions = a4, n2.rotation = null != e5 ? o$d(e5, "radians", "geographic") : void 0, n2.rotationPrecision = r3, n2.rotationType = s2?.rotationType ?? "geographic", n2.orientation = null != t4 ? o$d(t4, "radians", "geographic") : void 0, n2.orientationPrecision = r3;
          break;
        }
      }
      return e4;
    };
  }
  _updateFocusTooltip() {
    const { tooltipOptions: t3, _tooltip: e4 } = this;
    if (!t3.enabled)
      return;
    if (this.getFocused()) {
      const a4 = t3.visualVariables, i2 = a4?.rotation, o2 = a4?.size, s2 = this.mode, { size: r3, orientationClockwise: n2 } = this.adapter, p4 = null != n2 && (null == s2 || "rotate" === s2), h2 = null != r3 && (null == s2 || "scale" === s2);
      e4.info = this._absoluteTooltipInfo ??= new p$1({ tooltipOptions: t3 });
      const u3 = e4.info;
      u3.tooltipOptions = t3, u3.orientation = p4 ? o$d(n2, "radians", "geographic") : void 0, u3.orientationPrecision = kt2(i2?.valueType), u3.rotationType = i2?.rotationType ?? "geographic", u3.size = h2 ? i$9(r3, "meters") : void 0, u3.sizeUnit = o2?.unit, u3.sizePrecision = kt2(o2?.valueType);
    } else
      e4.clear();
  }
  _onScaleChanged() {
    this.events.emit("scale-changed"), this._updateManipulatorTransform();
  }
  _updateDelayedFocusedState() {
    this._ringManipulator.updateStateEnabled(yt.DelayedFocused, this.getFocused()), this._updateFocusTooltip();
  }
  _updateDragState() {
    if (this._ringManipulator.updateStateEnabled(yt.Unlocked, !(null != this._scaleRotateDragData && "none" !== this._scaleRotateDragData?.mode)), null != this._scaleRotateDragData)
      switch (this._scaleRotateDragData.mode) {
        case "rotate":
          this._ringManipulator.updateStateEnabled(yt.ScaleIn | yt.ScaleOut, false), this._ringManipulator.updateStateEnabled(yt.RotateLeft, this._scaleRotateDragData.angleDir < 0), this._ringManipulator.updateStateEnabled(yt.RotateRight, this._scaleRotateDragData.angleDir >= 0);
          break;
        case "scale":
          this._ringManipulator.updateStateEnabled(yt.RotateLeft | yt.RotateRight, false), this._ringManipulator.updateStateEnabled(yt.ScaleIn, this._scaleRotateDragData.scaleDir < 0), this._ringManipulator.updateStateEnabled(yt.ScaleOut, this._scaleRotateDragData.scaleDir >= 0);
      }
    else
      this._ringManipulator.updateStateEnabled(yt.ScaleIn | yt.ScaleOut | yt.RotateLeft | yt.RotateRight, false);
  }
  _updateManipulatorTransform() {
    const t3 = g$5(f$6.get(), this.adapter.angle, r$b(0, 0, 1));
    if (null == t3)
      return;
    const e4 = this.getScale(), a4 = d$7(f$6.get(), o$5(c$9.get(), e4, e4, e4));
    this._ringManipulator.modelTransform = c$a(f$6.get(), a4, t3);
  }
  _createRingManipulator() {
    const t3 = (t4, e5, a5) => {
      const i3 = [], o3 = Math.ceil(t$2 * (e5 - t4) / (2 * Math.PI));
      for (let s3 = 0; s3 < o3 + 1; s3++) {
        const r4 = t4 + s3 * (e5 - t4) / o3;
        i3.push(r$b(a5 * Math.cos(r4), a5 * Math.sin(r4), 0));
      }
      return i3;
    }, e4 = (e5) => t3(0, 2 * Math.PI, e5), a4 = (t4) => [[-t4 / 2, 0], [t4 / 2, 0], [t4 / 2, P / 2], [-t4 / 2, P / 2]], i2 = this._createMaterial(1), o2 = (t4, e5, o3 = i2) => at(o3, a4(e5), t4, [], [], false), s2 = e4(I), r3 = o2(s2, i$1), n2 = { left: new Array(), right: new Array() }, l2 = [];
    for (let j2 = 0; j2 < 2; j2++) {
      const e5 = j2 * Math.PI - Math.PI / 4, a5 = Math.PI / 2 - x$1, s3 = e5 + a5, r4 = e5 + Math.PI / 2 - a5, c3 = t3(s3, r4, n$2), p5 = o2(c3, l$1);
      l2.push(c3), l2.push(t3(s3, r4, p$3 - i$1 / 2)), n2.left.push(p5), n2.right.push(p5.instantiate());
      for (let t4 = 0; t4 < 2; t4++) {
        const e6 = 0 === t4, a6 = e$d();
        if (e6) {
          f$9(a6, a6, [1, -1, 1]), b$7(a6, a6, -s3, [0, 0, 1]);
          const t5 = Math.round(f$1 * (c3.length - 1));
          a6[12] = c3[t5][0], a6[13] = c3[t5][1], a6[14] = c3[t5][2];
        } else {
          b$7(a6, a6, r4, [0, 0, 1]);
          const t5 = Math.round((1 - f$1) * (c3.length - 1));
          a6[12] = c3[t5][0], a6[13] = c3[t5][1], a6[14] = c3[t5][2];
        }
        const o3 = pt(i2, r$2, 0, s$1, P);
        it(o3, a6), (e6 ? n2.left : n2.right).push(o3);
      }
    }
    const c2 = [];
    for (let v2 = 0; v2 < 2; v2++) {
      const e5 = v2 * Math.PI - Math.PI / 4, a5 = Math.PI / 2 - b2, i3 = e5 + a5, s3 = e5 + Math.PI / 2 - a5, r4 = t3(i3, s3, p$3);
      c2.push(o2(r4, l$1));
    }
    const p4 = this._createMaterial(0.66), h2 = this._createMaterial(0.5), u3 = this._createMaterial(0.33), d2 = e4(I + g2), g$12 = e4(I + j$2), m3 = o2(d2, l$1, p4), f3 = o2(g$12, l$1, u3), _2 = e4(I - g2), D2 = e4(I - j$2), S3 = o2(_2, l$1, p4), T3 = o2(D2, l$1, u3);
    let b$12 = [new e$b(r3, yt.DelayedFocused), new e$b(r3.instantiate({ material: h2 }), t$9.None)];
    this.mode && "scale" !== this.mode || (b$12 = b$12.concat([...c2.map((t4) => new e$b(t4, yt.DelayedFocused | yt.Unlocked)), new e$b(m3, yt.DelayedFocused | yt.ScaleIn), new e$b(f3, yt.DelayedFocused | yt.ScaleIn), new e$b(S3, yt.DelayedFocused | yt.ScaleOut), new e$b(T3, yt.DelayedFocused | yt.ScaleOut)])), this.mode && "rotate" !== this.mode || (b$12 = b$12.concat([...n2.right.map((t4) => new e$b(t4.instantiate(), yt.DelayedFocused | yt.Unlocked)), ...n2.left.map((t4) => new e$b(t4, yt.DelayedFocused | yt.RotateLeft)), ...n2.right.map((t4) => new e$b(t4, yt.DelayedFocused | yt.RotateRight))]));
    const w3 = [s2, ...l2];
    return new $({ view: this.tool.view, renderObjects: b$12, autoScaleRenderObjects: false, worldOriented: true, radius: i$1, focusMultiplier: 1, touchMultiplier: 1.5, elevationInfo: s$5(this.tool.graphicState.graphic), collisionType: { type: "ribbon", paths: w3, direction: r$b(0, 0, 1) } });
  }
  _createMaterial(t3) {
    const e4 = new f$7({ cullFace: e$c.Back, renderOccluded: d$4.Transparent, isDecoration: true });
    return this.addHandles(d$3(() => ({ color: F(this.tool.view.effectiveTheme.accentColor, t3) }), (t4) => e4.setParameters(t4), P$4)), e4;
  }
  get test() {
    return { ringManipulator: this._ringManipulator, setRingIndicatorDelayMs: (t3) => this._ringIndicatorDelayMs = t3, tooltip: this._tooltip };
  }
};
function bt(t3, e4) {
  const a4 = e$e(c$9.get(), e4.renderStart, t3.origin), i2 = e$e(c$9.get(), e4.renderEnd, t3.origin), o2 = s$8(a4), s2 = s$8(i2);
  return 0 === o2 ? 0 : s2 / o2;
}
function wt(t3, e4, a4, i2) {
  const { renderStart: o2, renderEnd: s2 } = t3, r3 = jt(o2, i2, c$9.get()), n2 = jt(s2, i2, c$9.get());
  if (p$a(r3, n2) < d * d)
    return null;
  const l2 = e$e(c$9.get(), o2, a4), c2 = _$1(c$9.get(), l2, ot$1(e4)), p4 = o2, h2 = u$6(c$9.get(), p4, c2), u3 = jt(a4, i2, c$9.get()), d$12 = r3, g3 = jt(h2, i2, c$9.get()), m3 = e$e(c$9.get(), g3, d$12), f3 = e$e(c$9.get(), r3, u3), _2 = p$b(d$12, m3), D2 = p$b(u3, f3);
  return b$8(_2, n2) < b$8(D2, n2) ? "rotate" : "scale";
}
function jt(t3, e4, a4) {
  return e4.projectToScreen(t3, At), o$5(a4, At[0], At[1], 0);
}
var Rt;
function It(t3, e4) {
  let a4 = null, i2 = 1;
  const o2 = () => i2;
  return { start: () => {
    i2 = t3.getScale(), a4 = t3.getScale, t3.getScale = o2, e4();
  }, update: (t4) => (i2 += ((i2 + 1) / 2 - i2) * Math.min(t4 * u$2, 1), e4(), Math.abs(i2 - 1) < 0.01 ? Rt.STOP : Rt.CONTINUE), destroy: () => {
    a4 && (t3.getScale = a4), e4();
  } };
}
function Ot(t3, e4, a4) {
  let i2 = 0, o2 = null;
  const s2 = () => false;
  return { start: () => {
    o2 = t3.getFocused, t3.getFocused = s2, i2 = 0, e4();
  }, update: (t4) => (i2 += t4, !o2?.() || i2 >= a4.delayMs ? Rt.STOP : Rt.CONTINUE), destroy: () => {
    o2 && (t3.getFocused = o2), e4();
  } };
}
function kt2(t3) {
  switch (t3) {
    case "integer":
    case "long":
      return 0;
    default:
      return null;
  }
}
e$4([y$1({ constructOnly: true })], Tt.prototype, "tool", void 0), e$4([y$1({ constructOnly: true })], Tt.prototype, "adapter", void 0), e$4([y$1({ constructOnly: true })], Tt.prototype, "tooltipOptions", void 0), e$4([y$1()], Tt.prototype, "mode", void 0), e$4([y$1()], Tt.prototype, "_activeAnimation", void 0), e$4([y$1()], Tt.prototype, "updating", null), Tt = e$4([c$5("esri.views.3d.interactive.editingTools.transformGraphic.GraphicScaleRotateTransform")], Tt), function(t3) {
  t3[t3.CONTINUE = 0] = "CONTINUE", t3[t3.STOP = 1] = "STOP";
}(Rt || (Rt = {}));
const At = i$5();
function t2(e4) {
  return null != e4.geometry && "mesh" === e4.geometry.type ? r2(e4.geometry) : n(e4);
}
function r2(e4) {
  return e4.vertexSpace.isRelative ? o(e4, e4.transform, e4.vertexSpace) : i(e4);
}
function n(e4) {
  let t3 = e4.geometry, r3 = null;
  return { undo(e5) {
    r3 = e5.geometry, e5.geometry = t3;
  }, redo(e5) {
    t3 = e5.geometry, e5.geometry = r3;
  } };
}
function o(t3, r3, n2) {
  let o2 = r3?.clone(), i2 = t$c(n2.origin), u3 = null, s2 = null;
  return { undo: (r4) => {
    u3 = t3.transform?.clone(), s2 = t$c(n2.origin), t3.transform = o2, t3.vertexSpace.origin = i2, r4.notifyMeshTransformChanged();
  }, redo: (r4) => {
    o2 = t3.transform?.clone(), i2 = t$c(n2.origin), t3.transform = u3, t3.vertexSpace.origin = s2, r4.notifyMeshTransformChanged();
  } };
}
function i(e4) {
  let t3, r3 = e4.vertexAttributes.clonePositional();
  return { undo: (n2) => {
    t3 = e4.vertexAttributes.clonePositional(), e4.vertexAttributes = r3, n2.notifyGeometryChanged();
  }, redo: (n2) => {
    r3 = e4.vertexAttributes.clonePositional(), e4.vertexAttributes = t3, n2.notifyGeometryChanged();
  } };
}
let v = class extends g$2 {
  constructor(t3) {
    super(t3), this._interactionState = null;
  }
  initialize() {
    this.addHandles([p$5(() => {
      const t3 = this._interactionState;
      return t3 && t3.angle !== t3.previousAngle ? { interactionState: t3, angle: t3.state.angle } : null;
    }, ({ interactionState: t3 }) => {
      this._updateMeshRotation(t3);
    }, C$6), p$5(() => {
      const t3 = this._interactionState;
      return t3 && t3.scale !== t3.previousScale ? { interactionState: t3, scale: t3.state.scale } : null;
    }, ({ interactionState: t3 }) => {
      this._updateMeshSize(t3);
    }, C$6)]);
  }
  get initialAngle() {
    return this._interactionState?.initialAngle ?? 0;
  }
  get angle() {
    const t3 = this.geometry.transform;
    if (null == t3)
      return this._interactionState?.angle ?? 0;
    const e4 = l$a(t3.rotation)[2];
    return Math.abs(e4) > 0.999999 ? M$5(x$8(t3.rotation)) * Math.sign(e4) : 0;
  }
  get angleClockwise() {
    return -this.angle;
  }
  get relativeAngle() {
    return this.angle - this.initialAngle;
  }
  get relativeAngleClockwise() {
    return -this.relativeAngle;
  }
  get scale() {
    return this._interactionState?.scale ?? 1;
  }
  startInteraction() {
    const t3 = new f2({ angle: this.angle });
    this._interactionState = t3;
    const e4 = () => {
      this._interactionState = null;
    };
    return { state: t3, done: e4, cancel: () => {
      t3.cancel(), e4();
    } };
  }
  createUndoRecord() {
    return t2(this.graphic);
  }
  _updateMeshRotation(t3) {
    const { angle: e4, previousAngle: o2 } = t3;
    t3.previousAngle = e4;
    const { geometry: r3 } = this, { vertexSpace: n2 } = r3, s2 = m$6(e4 - o2);
    if (n2.isGeoreferenced) {
      const t4 = !n2.isRelative && this.viewingMode === l$b.Global, e5 = this.geometry.anchor;
      this.geometry.rotate(0, 0, s2, { origin: e5, geographic: t4 }), this.graphic.notifyGeometryChanged();
    } else {
      r3.transform ??= new N$3();
      const { transform: t4 } = r3, e5 = g$7(0, 0, s2, S$1);
      t4.rotation = U$7(t4.rotation, e5, t4.rotation), this.graphic.notifyMeshTransformChanged();
    }
  }
  _updateMeshSize(t3) {
    const { scale: e4, previousScale: o2 } = t3;
    t3.previousScale = e4;
    const { geometry: i2 } = this, { vertexSpace: r3 } = i2, n2 = e4 / o2;
    if (r3.isGeoreferenced) {
      const t4 = !r3.isRelative && this.viewingMode === l$b.Global, e5 = this.geometry.anchor;
      this.geometry.scale(n2, { origin: e5, geographic: t4 }), this.graphic.notifyGeometryChanged();
    } else {
      i2.transform ??= new N$3();
      const { transform: t4 } = i2;
      t4.scale = g$3(t4.scale, t4.scale, n2), this.graphic.notifyMeshTransformChanged();
    }
  }
};
e$4([y$1({ constructOnly: true })], v.prototype, "graphic", void 0), e$4([y$1({ constructOnly: true })], v.prototype, "geometry", void 0), e$4([y$1({ constructOnly: true })], v.prototype, "viewingMode", void 0), e$4([y$1()], v.prototype, "initialAngle", null), e$4([y$1()], v.prototype, "angle", null), e$4([y$1()], v.prototype, "angleClockwise", null), e$4([y$1()], v.prototype, "relativeAngle", null), e$4([y$1()], v.prototype, "relativeAngleClockwise", null), e$4([y$1()], v.prototype, "scale", null), e$4([y$1()], v.prototype, "_interactionState", void 0), v = e$4([c$5("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateMeshAdapter")], v);
let f2 = class extends g$2 {
  get state() {
    const { angle: t3, scale: e4 } = this;
    return { angle: t3, scale: e4 };
  }
  constructor(t3) {
    super(t3), this.angle = 0, this.initialAngle = 0, this.previousAngle = 0, this.previousScale = 1, this.scale = 1, this.initialAngle = t3.angle, this.previousAngle = t3.angle;
  }
  cancel() {
    this.angle = this.initialAngle, this.scale = 1;
  }
};
e$4([y$1()], f2.prototype, "angle", void 0), e$4([y$1()], f2.prototype, "initialAngle", void 0), e$4([y$1()], f2.prototype, "previousAngle", void 0), e$4([y$1()], f2.prototype, "previousScale", void 0), e$4([y$1()], f2.prototype, "scale", void 0), e$4([y$1()], f2.prototype, "state", null), f2 = e$4([c$5("InteractionState")], f2);
const S$1 = h$9();
let a3 = class extends g$2 {
  constructor(t3) {
    super(t3), this.sizeAxis = null, this._interactionState = null;
  }
  initialize() {
    this.addHandles(p$5(() => null != this._interactionState ? this._interactionState.state : null, (t3) => {
      this._updateSymbol(t3);
    }, C$6));
  }
  get initialAngle() {
    return this._interactionState?.initialAngle ?? 0;
  }
  get angle() {
    return null != this._interactionState ? this._interactionState.angle : null != this._orientationReferenceSymbolLayer ? c(this._orientationReferenceSymbolLayer.heading ?? 0) : 0;
  }
  get angleClockwise() {
    return -this.angle;
  }
  get orientation() {
    return this.angle;
  }
  get orientationClockwise() {
    return this.angleClockwise;
  }
  get relativeAngle() {
    return this.angle - this.initialAngle;
  }
  get relativeAngleClockwise() {
    return -this.relativeAngle;
  }
  get scale() {
    return this._interactionState?.scale ?? 1;
  }
  get size() {
    const t3 = this._sizeReferenceSymbolLayer;
    if (null == t3)
      return null;
    const e4 = this.findLayerView(), i2 = this._graphicSymbol;
    if (null == e4 || null == i2 || "point-3d" !== i2.type)
      return null;
    const l2 = e4.getSymbolLayerSize(i2, t3);
    if ("size" in l2 && null != l2.size)
      return l2.size;
    const n2 = this.sizeAxis;
    return !("width" in l2) || null == l2.width || null != n2 && "width" !== n2 && "all" !== n2 && "width-and-depth" !== n2 ? !("depth" in l2) || null == t3.depth || null != n2 && "depth" !== n2 && "all" !== n2 && "width-and-depth" !== n2 ? !("height" in l2) || null == t3.height || null != n2 && "height" !== n2 && "all" !== n2 ? null : l2.height : l2.depth : l2.width;
  }
  get _sizeReferenceSymbolLayer() {
    const t3 = this._graphicSymbol;
    return null == t3 || 0 === t3.symbolLayers.length ? null : t3.symbolLayers.find((t4) => "object" === t4.type);
  }
  get _orientationReferenceSymbolLayer() {
    const t3 = this._graphicSymbol;
    return null == t3 || 0 === t3.symbolLayers.length ? null : t3.symbolLayers.find((t4) => "object" === t4.type && null != t4.heading);
  }
  get _graphicSymbol() {
    return null != this.graphic?.symbol && "point-3d" === this.graphic.symbol.type ? this.graphic.symbol : null;
  }
  set _graphicSymbol(t3) {
    this.graphic.symbol = t3;
  }
  startInteraction() {
    const t3 = this._graphicSymbol, e4 = this.findLayerView();
    if (null != this._interactionState || null == t3 || null == e4)
      return h;
    const i2 = t3.symbolLayers.map((i3) => "object" === i3.type ? e4.getSymbolLayerSize(t3, i3) : null).toArray(), l2 = t3.clone(), n2 = this.angle, o2 = new p3({ originalSymbol: l2, angle: n2, initialSizes: i2 });
    this._interactionState = o2;
    const r3 = () => {
      this._interactionState = null;
    };
    return { state: o2, done: r3, cancel: () => {
      this._graphicSymbol = l2, r3();
    } };
  }
  createUndoRecord() {
    let t3 = this.graphic.symbol, e4 = null;
    return { undo: (i2) => {
      e4 = i2.symbol, i2.symbol = t3;
    }, redo: (i2) => {
      t3 = i2.symbol, i2.symbol = e4;
    } };
  }
  _updateSymbol({ scale: t3, angle: e4, originalSymbol: l2, initialSizes: n2 }) {
    const o2 = this._graphicSymbol;
    if (null == o2 || "point-3d" !== o2.type)
      return;
    const r3 = o2.clone(), s2 = -m$6(e4 - this.initialAngle);
    let a4 = false;
    this._forEachObjectSymbolLayerPair(l2, r3, (e5, i2, l3) => {
      const o3 = (e5.heading ?? 0) + s2;
      i2.heading !== o3 && (i2.heading = o3, a4 = true);
      const r4 = n2[l3];
      if (null != r4 && "width" in r4) {
        r4.width = this.sizeFilter(r4.width), r4.height = this.sizeFilter(r4.height), r4.depth = this.sizeFilter(r4.depth);
        const e6 = r4.width * t3;
        i2.width !== e6 && (i2.width = e6, a4 = true);
        const l4 = r4.depth * t3;
        i2.depth !== l4 && (i2.depth = l4, a4 = true);
        const n3 = r4.height * t3;
        i2.height !== n3 && (i2.height = n3, a4 = true);
      }
    }), a4 && (this._graphicSymbol = r3);
  }
  _forEachObjectSymbolLayerPair(t3, e4, i2) {
    t3.symbolLayers.forEach((t4, l2) => {
      const n2 = e4.symbolLayers.at(l2);
      "object" === t4.type && "object" === n2.type && i2(t4, n2, l2);
    });
  }
};
function c(t3) {
  return -M$5(t3);
}
e$4([y$1()], a3.prototype, "initialAngle", null), e$4([y$1()], a3.prototype, "angle", null), e$4([y$1()], a3.prototype, "angleClockwise", null), e$4([y$1()], a3.prototype, "orientation", null), e$4([y$1()], a3.prototype, "orientationClockwise", null), e$4([y$1()], a3.prototype, "relativeAngle", null), e$4([y$1()], a3.prototype, "relativeAngleClockwise", null), e$4([y$1()], a3.prototype, "scale", null), e$4([y$1()], a3.prototype, "size", null), e$4([y$1()], a3.prototype, "sizeAxis", void 0), e$4([y$1({ constructOnly: true })], a3.prototype, "graphic", void 0), e$4([y$1()], a3.prototype, "_interactionState", void 0), e$4([y$1({ constructOnly: true })], a3.prototype, "findLayerView", void 0), e$4([y$1({ constructOnly: true })], a3.prototype, "sizeFilter", void 0), e$4([y$1()], a3.prototype, "_sizeReferenceSymbolLayer", null), e$4([y$1()], a3.prototype, "_orientationReferenceSymbolLayer", null), e$4([y$1()], a3.prototype, "_graphicSymbol", null), a3 = e$4([c$5("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateObjectSymbol3DAdapter")], a3);
const h = { state: { angle: 0, scale: 0 }, done: () => {
}, cancel: () => {
} };
let p3 = class extends g$2 {
  get state() {
    const { originalSymbol: t3, angle: e4, initialAngle: i2, scale: l2, initialSizes: n2 } = this;
    return { originalSymbol: t3, angle: e4, initialAngle: i2, scale: l2, initialSizes: n2 };
  }
  constructor(t3) {
    super(t3), this.angle = 0, this.initialAngle = 0, this.scale = 1, this.initialAngle = t3.angle;
  }
};
e$4([y$1()], p3.prototype, "originalSymbol", void 0), e$4([y$1()], p3.prototype, "angle", void 0), e$4([y$1()], p3.prototype, "initialAngle", void 0), e$4([y$1()], p3.prototype, "initialSizes", void 0), e$4([y$1()], p3.prototype, "scale", void 0), e$4([y$1()], p3.prototype, "state", null), p3 = e$4([c$5("InteractionState")], p3);
let Y = class extends o$4.EventedMixin(l$7) {
  constructor(t3) {
    super(t3), this.enableZ = true, this.enableRotation = true, this.enableScaling = true, this.tooltipOptions = new p$6(), this.type = "transform-3d", this._updatingHandles = new h$7(), this._scaleRotate = null, this._tooltip = null, this._translateGraphicTooltipInfo = null, this._translateGraphicXYTooltipInfo = null, this._translateGraphicZTooltipInfo = null;
  }
  initialize() {
    const { graphic: t3, view: e4 } = this;
    this.graphicState = new e$3({ graphic: t3 }), this.addHandles(d$3(() => this.tooltipOptions.enabled, (t4) => {
      this._tooltip = t4 ? new u$8({ view: e4 }) : u$7(this._tooltip);
    }, A$7)), this._moveManipulation = new u$1({ tool: this, view: e4, snapToScene: this.snapToScene, xyAvailable: true, xyAxisAvailable: true, zAvailable: this.enableZ && n$6(t3), radius: u$1.radiusForSymbol(t3.symbol) }), this._moveManipulation.forEachManipulator((i2) => this.addHandles(i2.events.on("immediate-click", (i3) => {
      this.emit("immediate-click", { ...i3, graphic: t3 }), i3.stopPropagation();
    })));
    const n2 = (t4) => (i2) => {
      this.addHandles(i2.events.on("focus-changed", ({ action: i3 }) => {
        const e5 = this._tooltip;
        null != e5 && ("focus" === i3 ? this._updateMoveTooltip(t4) : e5.clear());
      }));
    };
    this._moveManipulation.xyManipulation.forEachManipulator(n2(c$1.XY)), this._moveManipulation.xyAxisManipulation.forEachManipulator(n2(c$1.XY_AXIS)), this._moveManipulation.zManipulation.forEachManipulator(n2(c$1.Z));
    const s2 = s$5(t3);
    this._moveManipulation.elevationInfo = s2, this.addHandles(o$3(this.graphicState));
    const { geometry: p4 } = t3;
    if (this._moveManipulation.createGraphicDragPipeline((i2, a4, o2, n3, r3) => {
      if (null != p4 && i2 === c$1.XY) {
        const { snappingStep: i3, cancelSnapping: a5 } = f$a({ snappingContext: new e$f({ elevationInfo: s2, pointer: r3, editGeometryOperations: V$5.fromGeometry(new x$9({ spatialReference: p4.spatialReference }), e4.state.viewingMode), visualizer: new O$2(), excludeFeature: t3 }), snappingManager: this.snappingManager, updatingHandles: this._updatingHandles, useZ: false });
        n3 = n3.next(a5), o2 = o2.next(O$3(this.view, s2)).next(...i3);
      }
      return { steps: o2 = o2.next((t4) => (this._updateMoveTooltip(i2, t4), t4)), cancel: n3 };
    }, this.graphicState, (t4) => {
      const { action: i2, graphic: e5, dxScreen: a4, dyScreen: o2 } = t4, n3 = { graphic: e5, dxScreen: a4, dyScreen: o2 };
      switch (i2) {
        case "start":
          this.emit("graphic-translate-start", n3), this.emit("record-undo", { record: this._createGeometryUndoRecord() });
          break;
        case "update":
          this.emit("graphic-translate", n3);
          break;
        case "end":
          this.emit("graphic-translate-stop", n3);
      }
    }), this._moveManipulation.angle = null != this._scaleRotate ? this._scaleRotate.angle : 0, this._scaleRotateAdapter = this._createScaleRotateAdapter(), this.addHandles(d$3(() => this._scaleRotateAdapter.angle, () => this._updateMoveAngle())), this.enableScaling || this.enableRotation) {
      const t4 = this.enableScaling && this.enableRotation ? null : this.enableScaling ? "scale" : "rotate";
      this._scaleRotate = new Tt({ tool: this, mode: t4, adapter: this._scaleRotateAdapter, tooltipOptions: this.tooltipOptions }), this.addHandles(this._scaleRotate.events.on("scale-changed", () => this._onScaleChanged()));
    }
    this.addHandles([i$2({ view: this.view, graphic: this.graphic, forEachManipulator: (t4) => this._forEachManipulator(t4), onManipulatorsChanged: () => e$5() }), this.graphicState.on("changed", () => this._onGeometryChanged()), this._hideManipulatorsForGraphicState(), d$3(() => e4.scale, () => this._updateMoveAngle())].filter(k$6)), this.addHandles(this.view.trackGraphicState(this.graphicState)), this._onGeometryChanged(), this._updateMoveAngle(), this._forEachManipulator((t4) => {
      t4 instanceof $ && this.addHandles(t4.events.on("grab-changed", () => this._updateManipulatorsInteractive()));
    }), this.finishToolCreation();
  }
  destroy() {
    this._tooltip = u$7(this._tooltip), this._moveManipulation.destroy(), this._scaleRotate = u$7(this._scaleRotate), this._scaleRotateAdapter = u$7(this._scaleRotateAdapter), this._updatingHandles.destroy(), this._set("view", null), this._set("graphic", null);
  }
  _updateManipulatorsInteractive() {
    null != this._scaleRotate && (this._scaleRotate.interactive = !this._moveManipulation.grabbing, this._moveManipulation.interactive = !this._scaleRotate.grabbing);
  }
  _createScaleRotateAdapter() {
    return null != this.graphic.geometry && "mesh" === this.graphic.geometry.type ? new v({ graphic: this.graphic, geometry: this.graphic.geometry, viewingMode: this.view.state.viewingMode }) : new a3({ graphic: this.graphic, sizeFilter: (t3) => this._enforceNonZeroSize(t3), findLayerView: () => this.view.allLayerViews.find((t3) => t3.layer === this.graphic.layer), sizeAxis: this.tooltipOptions?.visualVariables?.size?.axis ?? null });
  }
  _forEachManipulator(t3) {
    this._moveManipulation?.forEachManipulator(t3), this._scaleRotate?.forEachManipulator(t3);
  }
  _hideManipulatorsForGraphicState() {
    return d$3(() => this.graphicState.displaying, (t3) => {
      this._forEachManipulator((i2) => i2.available = t3), this._moveManipulation.zManipulation.available = t3 && this.enableZ && n$6(this.graphic);
    });
  }
  _createGeometryUndoRecord() {
    return t2(this.graphic);
  }
  set snapToScene(t3) {
    this._moveManipulation && (this._moveManipulation.snapToScene = t3), this._set("snapToScene", t3);
  }
  get updating() {
    return this._updatingHandles.updating || !!this._scaleRotate?.updating;
  }
  set location(t3) {
    this._moveManipulation.location = t3, this._scaleRotate && (this._scaleRotate.location = t3);
  }
  set elevationAlignedLocation(t3) {
    this._moveManipulation.elevationAlignedLocation = t3, this._scaleRotate && (this._scaleRotate.elevationAlignedLocation = t3);
  }
  reset() {
  }
  onHide() {
    this._scaleRotate?.cancelActiveAnimation();
  }
  _onScaleChanged() {
    null != this._scaleRotate && (this._moveManipulation.displayScale = this._scaleRotate.getScale());
  }
  _updateMoveAngle() {
    this.view.state.viewingMode === l$b.Local || this.view.scale < v$1 ? this._moveManipulation.angle = this._scaleRotateAdapter.angle : this._moveManipulation.angle = 0;
  }
  _onGeometryChanged() {
    v$5(this.view, this, this.graphic);
  }
  _enforceNonZeroSize(t3) {
    return t3 || this.view.state.camera.computeRenderPixelSizeAt(this._moveManipulation.renderLocation);
  }
  _updateMoveTooltip(t3, i2) {
    const { tooltipOptions: e4, _tooltip: a4 } = this;
    if (null == a4)
      return;
    a4.clear();
    const o2 = this.graphicState.isDraped ? "on-the-ground" : "absolute-height";
    switch (t3) {
      case c$1.XY:
        a4.info = this._translateGraphicTooltipInfo ??= new r$c({ tooltipOptions: e4 }), this._updateMoveTooltipDistance(a4.info, i2, (t4, i3) => s$6(t4, i3, o2));
        break;
      case c$1.XY_AXIS:
        a4.info = this._translateGraphicXYTooltipInfo ??= new l$8({ tooltipOptions: e4 }), this._updateMoveTooltipDistance(a4.info, i2, (t4, e5) => {
          const a5 = s$6(t4, e5, o2);
          return m$4(a5, a$2(i2));
        });
        break;
      case c$1.Z:
        a4.info = this._translateGraphicZTooltipInfo ??= new a$b({ tooltipOptions: e4 }), this._updateMoveTooltipDistance(a4.info, i2, y$3);
    }
    a4.info.tooltipOptions = e4;
  }
  _updateMoveTooltipDistance(t3, i2, e4) {
    if (null != i2 && "end" !== i2.action) {
      const { mapStart: a4, mapEnd: o2 } = i2, n2 = e4(a4, o2);
      t3.distance = null != n2 ? n2 : h$8;
    } else
      t3.distance = h$8;
  }
  get test() {
    return { discManipulator: this._moveManipulation.xyManipulation.test.discManipulator, zManipulator: this._moveManipulation.zManipulation.test.manipulator, ringManipulator: null != this._scaleRotate ? this._scaleRotate.test.ringManipulator : null, arrowManipulators: this._moveManipulation.xyAxisManipulation.test.arrowManipulators, setRingIndicatorDelayMs: (t3) => null != this._scaleRotate ? this._scaleRotate.test.setRingIndicatorDelayMs(t3) : null, scaleRotateAdapter: this._scaleRotateAdapter, scaleRotateTransform: this._scaleRotate, tooltip: this._tooltip };
  }
};
e$4([y$1({ constructOnly: true, nonNullable: true })], Y.prototype, "view", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], Y.prototype, "graphic", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], Y.prototype, "enableZ", void 0), e$4([y$1()], Y.prototype, "enableRotation", void 0), e$4([y$1()], Y.prototype, "enableScaling", void 0), e$4([y$1({ constructOnly: true, type: p$6 })], Y.prototype, "tooltipOptions", void 0), e$4([y$1()], Y.prototype, "graphicState", void 0), e$4([y$1({ value: false })], Y.prototype, "snapToScene", null), e$4([y$1({ constructOnly: true })], Y.prototype, "snappingManager", void 0), e$4([y$1({ readOnly: true })], Y.prototype, "type", void 0), e$4([y$1({ readOnly: true })], Y.prototype, "updating", null), Y = e$4([c$5("esri.views.3d.interactive.editingTools.graphicTransform3D.GraphicTransformTool")], Y);
let T$1 = class T {
  constructor(t3, e4, o2, i2) {
    this._tool = t3, this._graphicState = e4, this._editGeometryOperations = o2, this._bounds = i2, this._moveXYTooltipInfo = null, this._moveZTooltipInfo = null;
    const a4 = this._tool, n2 = a4.view;
    this.moveXYGraphicManipulation = new l({ view: n2, tool: a4, graphicState: this._graphicState }), a4.addHandles(this._createMoveXYGraphicDragPipeline()), this.moveZManipulator = new I$1(n2, H$3.CENTER_ON_CALLOUT), this.moveZManipulator.state |= Mi, a4.manipulators.add(this.moveZManipulator), a4.addHandles([this._createMoveZDragPipeline()]), a4.addHandles([a4.on("graphic-translate-stop", () => {
      this._moveXYTooltipInfo = null, this._moveZTooltipInfo = null;
    })]);
  }
  destroy() {
    this.moveXYGraphicManipulation.destroy(), this._tool.manipulators.remove(this.moveZManipulator), this.moveZManipulator.destroy();
  }
  forEachManipulator(t3) {
    this.moveXYGraphicManipulation.forEachManipulator(t3), t3(this.moveZManipulator, A$3.TRANSLATE_Z);
  }
  updateManipulators(t3, i2) {
    const r3 = this.moveZManipulator, s2 = x$a(f$6.get(), t3, Math.PI);
    s2[12] = 0, s2[13] = 0, s2[14] = 0, r3.modelTransform = s2, r3.renderLocation = e$e(c$9.get(), i2.origin, i2.basis1);
  }
  getUpdatedTooltipInfo() {
    return this.moveXYGraphicManipulation.grabbing || this.moveXYGraphicManipulation.dragging ? this._computeMoveXYTooltipInfo() : this.moveZManipulator.focused ? this._computeMoveZTooltipInfo() : null;
  }
  _computeMoveXYTooltipInfo() {
    const t3 = this._tool.tooltipOptions;
    return this._moveXYTooltipInfo ??= new r$c({ tooltipOptions: t3 });
  }
  _computeMoveZTooltipInfo() {
    const e4 = this._tool, o2 = e4.tooltipOptions, i2 = this._moveZTooltipInfo ??= new a$b({ tooltipOptions: o2 });
    if (this.moveZManipulator.dragging) {
      const t3 = this._bounds, e5 = t3.mapBoundsStart.origin, o3 = t3.mapBounds.origin, a4 = d$8(e5, o3, this._tool.view.spatialReference);
      if (null == a4)
        return null;
      i2.distance = a4;
    } else
      i2.distance = i$9(0, e4.moveUnit);
    return i2;
  }
  _updateMoveTooltip(t3, e4) {
    if (e4 === c$1.XY || e4 === c$1.XY_AXIS) {
      const e5 = s$6(t3.mapStart, t3.mapEnd, this._graphicState.isDraped ? "on-the-ground" : "absolute-height");
      null != e5 && null != this._moveXYTooltipInfo && (this._moveXYTooltipInfo.distance = e5);
    }
    return t3;
  }
  _createMoveXYGraphicDragPipeline() {
    return this.moveXYGraphicManipulation.createDragPipeline((t3, e4, o2) => this._applyGraphicMoveSteps(e4, o2, c$1.XY));
  }
  _createMoveZDragPipeline() {
    const t3 = this._editGeometryOperations.data.spatialReference;
    return d$6(this.moveZManipulator, (e4, o2, a4) => {
      const n2 = t$c(e4.renderLocation), r3 = o2.next(P$6(this._tool.view, n2, t3)).next(q$4());
      this._applyGraphicMoveSteps(r3, a4, c$1.Z);
    });
  }
  _applyGraphicMoveSteps(t3, e4, o2) {
    const i2 = this._tool, a4 = i2.graphic, n2 = t3.next((t4) => ("start" === t4.action && (i2.inputState = { type: "move" }, this._bounds.backupMapBounds(), i2.emit("graphic-translate-start", { graphic: a4, dxScreen: t4.screenDeltaX, dyScreen: t4.screenDeltaY })), t4)).next(P$8()).next(this._moveDragUpdateGeometry()).next((t4) => {
      const e5 = { graphic: a4, dxScreen: t4.screenDeltaX, dyScreen: t4.screenDeltaY };
      switch (t4.action) {
        case "start":
        case "update":
          (t4.mapEnd.x - t4.mapStart.x || t4.mapEnd.y - t4.mapStart.y || (t4.mapEnd.z ?? 0) - (t4.mapStart.z ?? 0)) && i2.emit("graphic-translate", e5);
          break;
        case "end":
          i2.inputState = null, i2.emit("graphic-translate-stop", e5);
      }
      return t4;
    }).next((t4) => this._updateMoveTooltip(t4, o2));
    return e4.next(() => {
      null != i2.inputState && i2.emit("graphic-translate-stop", { graphic: a4, dxScreen: 0, dyScreen: 0 }), i2.cancel();
    }), n2;
  }
  _moveDragUpdateGeometry() {
    const t3 = this._tool;
    return (e4) => {
      if (null == t3.inputState || "move" !== t3.inputState.type)
        return e4;
      const o2 = [];
      for (const t4 of this._editGeometryOperations.data.components)
        o2.push(...t4.vertices);
      const i2 = "start" === e4.action ? E$3.NEW_STEP : E$3.ACCUMULATE_STEPS, a4 = this._editGeometryOperations.moveVertices(o2, e4.mapDeltaX, e4.mapDeltaY, e4.mapDeltaZ, i2);
      return V$6(a4, this._bounds.mapBounds), t3.graphic.geometry = this._editGeometryOperations.data.geometry, e4;
    };
  }
};
class T2 {
  constructor(t3, e4, o2) {
    this._tool = t3, this._editGeometryOperations = e4, this._bounds = o2, this._rotateTooltipInfo = null, this._startAngle = 0, this._endAngle = 0;
    const r3 = this._tool, a4 = r3.view, i2 = !a4._stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result;
    this.rotateManipulator = new g$8(a4, (t4, e5) => l$c(a4.textures, { accentColor: t4, contrastColor: e5, preMultiplyAlpha: i2 })), r3.addHandles([this.rotateManipulator.events.on("grab-changed", (t4) => this._onRotateGrab(t4)), this._createRotateDragPipeline(this.rotateManipulator)]), r3.manipulators.add(this.rotateManipulator), r3.addHandles([r3.on("graphic-rotate-start", (t4) => {
      this._startAngle = t4.angle;
    }), r3.on("graphic-rotate", (t4) => {
      this._endAngle = t4.angle;
    }), r3.on("graphic-rotate-stop", () => {
      this._startAngle = 0, this._endAngle = 0;
    })]);
  }
  destroy() {
    this._tool.manipulators.remove(this.rotateManipulator), this.rotateManipulator.destroy();
  }
  forEachManipulator(t3) {
    t3(this.rotateManipulator, A$3.ROTATE);
  }
  updateManipulators(t3, r3) {
    const a4 = this._bounds.mapBounds.plane[2] < 0 ? Math.PI : 0, i2 = l$6(f$6.get(), t3, a4);
    i2[12] = 0, i2[13] = 0, i2[14] = 0, this.rotateManipulator.modelTransform = i2, this.rotateManipulator.renderLocation = u$6(c$9.get(), r3.origin, r3.basis1);
  }
  getUpdatedTooltipInfo() {
    return this.rotateManipulator.focused ? this._computeRotateTooltipInfo() : null;
  }
  _computeRotateTooltipInfo() {
    const t3 = this._tool.tooltipOptions, e4 = this._rotateTooltipInfo ??= new i$a({ tooltipOptions: t3 });
    return e4.angle = this._startAngle - this._endAngle, e4;
  }
  _onRotateGrab({ action: t3, screenPoint: e4 }) {
    const o2 = this._tool, r3 = this._bounds;
    if ("start" !== t3 || !e4)
      return;
    const a4 = ci(r3.displayBounds, o2.view.renderCoordsHelper, Ci.HEADING, b$5()), i2 = m$7(o2.view.state.camera, e4);
    B$1(a4, i2, c$9.get()) && (r3.backupMapBounds(), o2.inputState = { type: "rotate", rotatePlane: a4 });
  }
  _createRotateDragPipeline(e4) {
    const o2 = this._tool, r3 = o2.graphic;
    return d$6(e4, (e5, a4, i2) => {
      const n2 = o2.inputState;
      null != n2 && (a4.next((t3) => ("start" === t3.action && o2.emit("graphic-rotate-start", { graphic: r3, angle: 0 }), t3)).next(H$2(o2.view, n2.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(n2)).next(this._rotateDragUpdateGeometry()).next((e6) => {
        const a5 = { graphic: r3, angle: m$6(e6.rotateAngle) };
        switch (e6.action) {
          case "start":
          case "update":
            o2.emit("graphic-rotate", a5);
            break;
          case "end":
            o2.inputState = null, o2.emit("graphic-rotate-stop", a5);
        }
        return e6;
      }), i2.next(() => {
        null != o2.inputState && o2.emit("graphic-rotate-stop", { graphic: r3, angle: 0 }), o2.cancel();
      }));
    });
  }
  _rotateDragRenderPlaneToRotate(t3) {
    return (e4) => {
      const o2 = ot$1(t3.rotatePlane), r3 = F$1(e4.renderStart, e4.renderEnd, this._bounds.displayBounds.origin, o2);
      return { ...e4, rotateAxis: o2, rotateAngle: r3 };
    };
  }
  _rotateDragUpdateGeometry() {
    const t3 = this._tool, e4 = this._bounds;
    return (o2) => {
      const n2 = r$e(n$4(), e4.mapBoundsStart.origin), s2 = [];
      for (const t4 of this._editGeometryOperations.data.components)
        s2.push(...t4.vertices);
      const p4 = "start" === o2.action ? E$3.NEW_STEP : E$3.ACCUMULATE_STEPS, l2 = this._editGeometryOperations.rotateVertices(s2, n2, o2.rotateAngle, p4, e$g.REPLACE);
      return Z(e4.mapBoundsStart, e4.mapBounds), V$6(l2, e4.mapBounds), t3.graphic.geometry = this._editGeometryOperations.data.geometry, o2;
    };
  }
}
class _ {
  constructor(s2, t3, o2) {
    this._tool = s2, this._onDisplayBoundsChanged = t3, this.mapBounds = W$2(), this.mapBoundsStart = W$2(), this.displayBounds = W$2(), this._calculateMapBounds(o2);
  }
  get displayBoundsMargin() {
    const { view: s2, graphic: t3 } = this._tool, o2 = s2.pointsOfInterest?.centerOnSurfaceFrequent.location ?? t3.geometry?.extent?.center;
    return o2 ? R * s2.pixelSizeAt(o2) : 0;
  }
  backupMapBounds() {
    Z(this.mapBounds, this.mapBoundsStart);
  }
  updateDisplayBounds() {
    this._calculateDisplayBounds(), this._onDisplayBoundsChanged();
  }
  _calculateMapBounds(s2) {
    const { view: e4, attachmentOrigin: n2 } = this._tool, a4 = s2.geometry, r3 = o$2(a4);
    l$3(r3, r3, -1);
    const c2 = e4.spatialReference, l2 = a4.spatialReference, p4 = n2 ? e4.pixelSizeAt(n2) * V$7(c2) / z$2(l2) : 0;
    l$d(r3, s2, U$1 * p4, this.mapBounds);
  }
  _calculateDisplayBounds() {
    const { view: s2, attachmentOrigin: t3, graphic: o2 } = this._tool;
    if (!o2.geometry)
      return;
    const i2 = t3?.z ?? f$5(this.mapBounds.origin, s2.elevationProvider, o$6.fromElevationInfo(s$5(o2)), s2.renderCoordsHelper), e4 = Z(this.mapBounds);
    e4.origin[2] = i2 ?? 0, M(e4, s2.renderCoordsHelper, o2.geometry.spatialReference, this.displayBoundsMargin, this.displayBounds);
  }
}
const R = 10, U$1 = 80;
function M(s2, t3, o2, i2 = 0, g3) {
  g3 || (g3 = W$2()), t3.toRenderCoords(s2.origin, o2, g3.origin);
  const m3 = c$9.get();
  u$6(m3, s2.origin, s2.basis1), u$6(m3, m3, s2.basis2), t3.toRenderCoords(m3, o2, m3);
  const f3 = c$9.get();
  u$6(f3, s2.origin, s2.basis1), e$e(f3, f3, s2.basis2), t3.toRenderCoords(f3, o2, f3);
  const y2 = c$9.get();
  e$e(y2, s2.origin, s2.basis1), e$e(y2, y2, s2.basis2), t3.toRenderCoords(y2, o2, y2);
  const B2 = c$9.get();
  e$e(B2, s2.origin, s2.basis1), u$6(B2, B2, s2.basis2), t3.toRenderCoords(B2, o2, B2);
  const j2 = A$8(c$9.get(), m3, f3, 0.5);
  e$e(j2, j2, g3.origin);
  const v2 = A$8(c$9.get(), y2, B2, 0.5);
  e$e(v2, g3.origin, v2), A$8(g3.basis1, j2, v2, 0.5);
  const C5 = A$8(c$9.get(), B2, m3, 0.5);
  e$e(C5, C5, g3.origin);
  const _2 = A$8(c$9.get(), f3, y2, 0.5);
  e$e(_2, g3.origin, _2), A$8(g3.basis2, C5, _2, 0.5);
  const R2 = _$1(c$9.get(), g3.basis1, g3.basis2), U2 = _$1(R2, R2, g3.basis1);
  return z$4(U2, U2), g$3(g3.basis2, U2, P$7(g3.basis2, U2)), g$3(g3.basis1, g3.basis1, 1 + i2 / s$8(g3.basis1)), g$3(g3.basis2, g3.basis2, 1 + i2 / s$8(g3.basis2)), J(g3), g3;
}
function S2(t3, o2, i2, e4) {
  const a4 = c$9.get();
  e$e(a4, e$e(a4, t3.origin, t3.basis1), t3.basis2);
  const r3 = c$9.get();
  q$6(r3, a4, t3.basis1, 2);
  const c2 = c$9.get();
  q$6(c2, r3, t3.basis2, 2);
  const l2 = c$9.get();
  q$6(l2, a4, t3.basis2, 2), a4[2] = r3[2] = c2[2] = l2[2] = o2;
  const p4 = e4 ? "on-the-ground" : "absolute-height", u3 = p$c(a$c(a4, r3, i2, p4), a$c(l2, c2, i2, p4)), d2 = p$c(a$c(r3, c2, i2, p4), a$c(a4, l2, i2, p4));
  return null == d2 || null == u3 ? null : [u3, d2];
}
class j {
  get zMax() {
    if (!this._zMaxDirty)
      return this._zMax;
    const t3 = this._editGeometryOperations.data;
    if (t3.geometry.hasZ) {
      const e4 = t3.coordinateHelper;
      this._zMax = Number.NEGATIVE_INFINITY;
      for (const s2 of t3.components)
        for (const t4 of s2.vertices) {
          const s3 = e4.getZ(t4.pos) ?? 0;
          this._zMax = Math.max(s3, this._zMax);
        }
    } else
      this._zMax = 0;
    return this._zMaxDirty = false, this._zMax;
  }
  constructor(e4, a4, i2, r3, o2) {
    this._tool = e4, this._graphicState = a4, this._editGeometryOperations = i2, this._bounds = r3, this._preserveAspectRatioStep = o2, this._resizeHandles = [{ direction: [1, 0] }, { direction: [1, 1] }, { direction: [0, 1] }, { direction: [-1, 1] }, { direction: [-1, 0] }, { direction: [-1, -1] }, { direction: [0, -1] }, { direction: [1, -1] }], this._scaleTooltipInfo = null, this._displayBoundsStart = W$2(), this._displayBoundsMarginStart = 0, this._startScale = n$3(), this._endScale = n$3(), this._sizeStart = null, this._zMax = 0, this._zMaxDirty = true;
    const n2 = this._tool, c2 = n2.view;
    this.resizeManipulators = this._resizeHandles.map((t3) => {
      const e5 = new v$7(c2, t3);
      return n2.addHandles([e5.events.on("grab-changed", (t4) => this._onResizeGrab(t4)), this._createResizeDragPipeline(e5, t3)]), e5;
    }), n2.manipulators.addMany(this.resizeManipulators), n2.addHandles([n2.on("graphic-scale-start", (e5) => {
      r$5(this._startScale, e5.xScale, e5.yScale), r$5(this._endScale, e5.xScale, e5.yScale);
    }), n2.on("graphic-scale", (e5) => {
      r$5(this._endScale, e5.xScale, e5.yScale);
    }), n2.on("graphic-scale-stop", () => {
      r$5(this._startScale, 0, 0), r$5(this._endScale, 0, 0);
    }), this._graphicState.on("changed", () => {
      "resize" !== n2.inputState?.type && (this._zMaxDirty = true);
    })]);
  }
  destroy() {
    this.forEachManipulator((t3) => {
      this._tool.manipulators.remove(t3), t3.destroy();
    });
  }
  forEachManipulator(t3) {
    this.resizeManipulators.forEach((e4) => t3(e4, A$3.SCALE));
  }
  updateManipulators(t3, e4) {
    this.resizeManipulators.forEach((s2, a4) => {
      di(s2, this._resizeHandles[a4], t3, e4);
    });
  }
  getUpdatedTooltipInfo() {
    return this.resizeManipulators.some((t3) => t3.focused) ? this._computeScaleTooltipInfo() : null;
  }
  _computeScaleTooltipInfo() {
    const t3 = this._tool, e4 = t3.tooltipOptions, s2 = this._scaleTooltipInfo ??= new p$d({ tooltipOptions: e4 }), a4 = t3.graphic.geometry;
    if (null == a4)
      return null;
    const i2 = S2(this._bounds.mapBounds, this.zMax, a4.spatialReference, this._graphicState.isDraped);
    return null == i2 ? null : (s2.xSize = i2[0], s2.ySize = i2[1], null != this._sizeStart && this.resizeManipulators.some((t4) => t4.dragging) ? (s2.xScale = i2[0].value / this._sizeStart[0].value, s2.yScale = i2[1].value / this._sizeStart[1].value) : (s2.xScale = 1, s2.yScale = 1), s2);
  }
  _onResizeGrab({ action: t3, screenPoint: e4 }) {
    const s2 = this._tool, a4 = this._bounds;
    if ("start" !== t3 || !e4 || !s2.graphic.geometry)
      return;
    const i2 = m$7(s2.view.state.camera, e4);
    B$1(a4.displayBounds.plane, i2, c$9.get()) && (a4.backupMapBounds(), Z(a4.displayBounds, this._displayBoundsStart), this._displayBoundsMarginStart = a4.displayBoundsMargin, this._sizeStart = S2(a4.mapBoundsStart, this.zMax, s2.graphic.geometry.spatialReference, this._graphicState.isDraped), s2.inputState = { type: "resize" });
  }
  _createResizeDragPipeline(t3, e4) {
    const s2 = this._tool, a4 = s2.graphic;
    return d$6(t3, (t4, i2, r3) => {
      null != s2.inputState && (i2.next((t5) => ("start" === t5.action && s2.emit("graphic-scale-start", { graphic: a4, xScale: 1, yScale: 1 }), t5)).next(H$2(s2.view, this._displayBoundsStart.plane)).next((t5) => ({ ...t5, handle: e4 })).next(this._resizeDragRenderPlaneToFactors()).next(...this._preserveAspectRatioStep()).next(this._resizeDragUpdateGeometry()).next((t5) => {
        const e5 = { graphic: a4, xScale: t5.factor1, yScale: t5.factor2 };
        switch (t5.action) {
          case "start":
          case "update":
            s2.emit("graphic-scale", e5);
            break;
          case "end":
            s2.inputState = null, s2.emit("graphic-scale-stop", e5);
        }
        return t5;
      }), r3.next(() => {
        null != s2.inputState && s2.emit("graphic-scale-stop", { graphic: a4, xScale: 1, yScale: 1 }), s2.cancel();
      }));
    });
  }
  _resizeDragRenderPlaneToFactors() {
    const t3 = this._bounds;
    return (e4) => {
      const s2 = this._displayBoundsStart, c2 = e4.handle.direction, p4 = t3.displayBoundsMargin, l2 = this._displayBoundsMarginStart, h2 = r$e(c$9.get(), s2.origin);
      q$6(h2, h2, s2.basis1, -c2[0]), q$6(h2, h2, s2.basis2, -c2[1]);
      const u3 = e$e(c$9.get(), e4.renderEnd, h2), m3 = e$e(c$9.get(), e4.renderStart, h2), g3 = Ii(e4.handle), f3 = hi(s2), y2 = hi(t3.displayBounds) / f3, z3 = (t4, e5) => {
        if (0 === t4)
          return 1;
        let s3 = s$8(e5), a4 = 0.5 * t4 * P$7(e5, u3) / s3;
        const i2 = a4 < 0 ? -1 : 1;
        if (g3) {
          a4 += (s3 - 0.5 * t4 * P$7(e5, m3) / s3) * i2 * y2;
        }
        const r3 = s3 < 1.5 * l2 ? 1 : E;
        return s3 = Math.max(s3 - l2, E), i2 > 0 && (a4 -= p4), i2 * Math.max(i2 * (a4 / s3), r3);
      };
      return { ...e4, factor1: z3(c2[0], s2.basis1), factor2: z3(c2[1], s2.basis2) };
    };
  }
  _resizeDragUpdateGeometry() {
    const r3 = this._tool, o2 = this._bounds;
    return (n2) => {
      const p4 = r$e(n$4(), o2.mapBoundsStart.origin);
      q$6(p4, p4, o2.mapBoundsStart.basis1, -n2.handle.direction[0]), q$6(p4, p4, o2.mapBoundsStart.basis2, -n2.handle.direction[1]);
      const h2 = r$5(n$3(), o2.mapBoundsStart.basis1[0], o2.mapBoundsStart.basis1[1]);
      v$3(h2, h2);
      const d2 = [];
      for (const t3 of this._editGeometryOperations.data.components)
        d2.push(...t3.vertices);
      const u3 = "start" === n2.action ? E$3.NEW_STEP : E$3.ACCUMULATE_STEPS, m3 = this._editGeometryOperations.scaleVertices(d2, p4, h2, n2.factor1, n2.factor2, u3, e$g.REPLACE);
      return Z(o2.mapBoundsStart, o2.mapBounds), V$6(m3, o2.mapBounds), r3.graphic.geometry = this._editGeometryOperations.data.geometry, n2;
    };
  }
}
const E = 1e-6;
class e3 {
  constructor() {
    this._lastDragEvent = null, this._next = null, this._enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t3) {
    if (this._enabled !== t3 && null != this._lastDragEvent && null != this._next) {
      const a4 = { ...this._lastDragEvent, action: "update" };
      t3 && this._adjustScaleFactors(a4), this._next.execute(a4);
    }
    this._enabled = t3;
  }
  createDragEventPipelineStep() {
    this._lastDragEvent = null;
    const t3 = new U$4();
    return this._next = t3, [(t4) => (this._lastDragEvent = "end" !== t4.action ? { ...t4 } : null, this._enabled && this._adjustScaleFactors(t4), t4), t3];
  }
  _adjustScaleFactors(a4) {
    const e4 = Ii(a4.handle) ? Math.max(Math.abs(a4.factor1), Math.abs(a4.factor2)) : 0 === a4.handle.direction[0] ? Math.abs(a4.factor2) : Math.abs(a4.factor1);
    a4.factor1 = a4.factor1 < 0 ? -e4 : e4, a4.factor2 = a4.factor2 < 0 ? -e4 : e4;
  }
  get test() {
    return { _adjustScaleFactors: (t3) => this._adjustScaleFactors(t3) };
  }
}
let U = class extends o$4.EventedMixin(l$7) {
  constructor(t3) {
    super(t3), this.enableZ = true, this.enableScaling = true, this.enableRotation = true, this.tooltipOptions = new p$6(), this._preserveAspectRatio = new e3(), this.grabbing = false, this.inputState = null, this._attachmentOrigin = null, this.type = "transform-3d", this._outlineVisualElement = null;
  }
  initialize() {
    const { view: t3, graphic: e4 } = this, s2 = this._graphicState = new e$3({ graphic: e4 }), n2 = e4.geometry, r3 = this._editGeometryOperations = V$5.fromGeometry(n2, t3.state.viewingMode), l2 = this._bounds = new _(this, () => this._updateManipulators(), r3.data);
    this._extentMove = new T$1(this, s2, r3, l2), this._extentScale = new j(this, s2, r3, l2, () => this._preserveAspectRatio.createDragEventPipelineStep()), this._extentRotate = new T2(this, r3, l2), this.addHandles([d$3(() => this.enableZ, () => this._updateManipulatorAvailability(this._extentMove.moveZManipulator, A$3.TRANSLATE_Z)), d$3(() => this.enableScaling, () => this._extentScale.forEachManipulator((t4) => this._updateManipulatorAvailability(t4, A$3.SCALE))), d$3(() => this.enableRotation, () => this._updateManipulatorAvailability(this._extentRotate.rotateManipulator, A$3.ROTATE))]), this._updateAllManipulatorAvailability();
    const p4 = i$2({ view: t3, graphic: e4, forEachManipulator: (t4) => this._forEachManipulator(t4), onManipulatorsChanged: () => e$5() });
    if (null != p4) {
      const { visualElement: t4 } = p4;
      t4 instanceof w2 && (this._outlineVisualElement = t4, this.addHandles(t4.events.on("attachment-origin-changed", () => this._bounds.updateDisplayBounds()))), this.addHandles(p4);
    }
    this.addHandles([s2.on("changed", () => this._onGeometryChanged()), d$3(() => s2.displaying, () => this._updateAllManipulatorAvailability()), d$3(() => s2.isDraped, () => this._graphicDrapedChanged(), P$4), d$3(() => t3.pointsOfInterest?.centerOnSurfaceFrequent.location, () => l2.updateDisplayBounds()), t3.trackGraphicState(s2)]);
    const h2 = (t4) => {
      this.addHandles(t4.events.on("grab-changed", () => {
        this.grabbing = t4.grabbing, this._updateAllManipulatorAvailability();
      }));
    };
    this._forEachManipulator(h2);
    const c2 = (t4, i2) => {
      this.addHandles(t4.events.on("immediate-click", (t5) => {
        i2 === A$3.TRANSLATE_XY && this.emit("immediate-click", { ...t5, graphic: e4 }), t5.stopPropagation();
      }));
    };
    this._forEachManipulator(c2), this._initializeTooltip(), this.finishToolCreation();
  }
  destroy() {
    this._extentMove.destroy(), this._extentScale.destroy(), this._extentRotate.destroy(), this._editGeometryOperations.destroy(), this._tooltip.destroy(), this._set("view", null), this._set("graphic", null);
  }
  _initializeTooltip() {
    const { view: t3 } = this, e4 = this._tooltip = new u$8({ view: t3 }), i2 = () => {
      e4.info = this._getUpdatedTooltipInfo();
    };
    this.addHandles([this.on("graphic-translate-start", i2), this.on("graphic-translate", i2), this.on("graphic-translate-stop", () => {
      this._tooltip.clear();
    }), this.on("graphic-rotate-start", i2), this.on("graphic-rotate", i2), this.on("graphic-rotate-stop", i2), this.on("graphic-scale-start", i2), this.on("graphic-scale", i2), this.on("graphic-scale-stop", i2)]), this._forEachManipulator((t4) => {
      this.addHandles([t4.events.on("focus-changed", i2), t4.events.on("grab-changed", i2), t4.events.on("drag", (t5) => {
        "cancel" === t5.action ? this._tooltip.clear() : i2();
      })]);
    });
  }
  _getUpdatedTooltipInfo() {
    return this.tooltipOptions.enabled ? this._extentMove.getUpdatedTooltipInfo() ?? this._extentScale.getUpdatedTooltipInfo() ?? this._extentRotate.getUpdatedTooltipInfo() : null;
  }
  _onGeometryChanged() {
    this._bounds.updateDisplayBounds();
  }
  _graphicDrapedChanged() {
    this.removeHandles(G), this._bounds.updateDisplayBounds(), this._graphicState.isDraped && this.addHandles(this.view.elevationProvider.on("elevation-change", (t3) => {
      null != this._attachmentOrigin && w$3(t3.extent, this._attachmentOrigin.x, this._attachmentOrigin.y) && this._bounds.updateDisplayBounds();
    }), G);
  }
  _updateManipulators() {
    if (!this.visible)
      return;
    const t3 = this._bounds.displayBounds, e4 = ai(t3, f$6.get());
    this._extentMove.updateManipulators(e4, t3), this._extentScale.updateManipulators(e4, t3), this._extentRotate.updateManipulators(e4, t3);
  }
  _updateAllManipulatorAvailability() {
    this._forEachManipulator((t3, e4) => this._updateManipulatorAvailability(t3, e4));
  }
  _updateManipulatorAvailability(t3, e4) {
    const i2 = this.grabbing && !t3.grabbing;
    if (t3.interactive = !i2, t3 instanceof $) {
      const a4 = this._graphicState.displaying, o2 = this.enableZ && n$6(this.graphic);
      switch (e4) {
        case A$3.ROTATE:
          t3.available = a4 && this.enableRotation;
          break;
        case A$3.SCALE:
          t3.available = a4 && (this.enableScaling || this.enableRotation || o2), t3.interactive = !i2 && this.enableScaling, t3.state = this.enableScaling ? Ni : Hi;
          break;
        case A$3.TRANSLATE_Z:
          t3.available = a4 && o2;
          break;
        default:
          t3.available = a4;
      }
    }
  }
  _forEachManipulator(t3) {
    this._extentMove.forEachManipulator(t3), this._extentScale.forEachManipulator(t3), this._extentRotate.forEachManipulator(t3);
  }
  get preserveAspectRatio() {
    return this._preserveAspectRatio.enabled;
  }
  set preserveAspectRatio(t3) {
    this._preserveAspectRatio.enabled = t3, this._set("preserveAspectRatio", t3);
  }
  get moveUnit() {
    return se(this.view.spatialReference) ?? "meters";
  }
  get attachmentOrigin() {
    const t3 = this.graphic.geometry, e4 = this._graphicState.isDraped ? null : this._outlineVisualElement?.attachmentOrigin;
    return this._attachmentOrigin = e4 ?? k$3(this.view, this.graphic) ?? t3?.extent?.center, this._attachmentOrigin;
  }
  reset() {
  }
  cancel() {
    if (this.canUndo) {
      const t3 = this._editGeometryOperations.undo();
      x$b(t3, this._bounds.mapBounds), this.graphic.geometry = this._editGeometryOperations.data.geometry;
    }
    this.inputState = null;
  }
  get canUndo() {
    return this._editGeometryOperations.canUndo;
  }
  undo() {
    if (null != this.inputState)
      this.view.activeTool = null;
    else if (this.canUndo) {
      const t3 = this._editGeometryOperations.undo();
      x$b(t3, this._bounds.mapBounds), this.graphic.geometry = this._editGeometryOperations.data.geometry;
    }
  }
  get canRedo() {
    return this._editGeometryOperations.canRedo;
  }
  redo() {
    if (this.canRedo) {
      const t3 = this._editGeometryOperations.redo();
      V$6(t3, this._bounds.mapBounds), this.graphic.geometry = this._editGeometryOperations.data.geometry;
    }
  }
  get test() {
    return { moveZManipulator: this._extentMove.moveZManipulator, resizeManipulators: this._extentScale.resizeManipulators, rotateManipulator: this._extentRotate.rotateManipulator, tooltip: this._tooltip };
  }
};
e$4([y$1({ constructOnly: true, nonNullable: true })], U.prototype, "view", void 0), e$4([y$1({ constructOnly: true, nonNullable: true })], U.prototype, "graphic", void 0), e$4([y$1()], U.prototype, "enableZ", void 0), e$4([y$1()], U.prototype, "enableScaling", void 0), e$4([y$1()], U.prototype, "enableRotation", void 0), e$4([y$1({ constructOnly: true, type: p$6 })], U.prototype, "tooltipOptions", void 0), e$4([y$1()], U.prototype, "preserveAspectRatio", null), e$4([y$1()], U.prototype, "moveUnit", null), e$4([y$1()], U.prototype, "grabbing", void 0), e$4([y$1()], U.prototype, "inputState", void 0), e$4([y$1({ readOnly: true })], U.prototype, "type", void 0), U = e$4([c$5("esri.views.3d.interactive.editingTools.transformGraphic.ExtentTransformTool")], U);
const G = "draped-elevation-changes";
export {
  z2 as DrawGraphicTool3D,
  U as ExtentTransformTool,
  q as GraphicMoveTool,
  u2 as GraphicReshapeTool,
  Y as GraphicTransformTool
};
