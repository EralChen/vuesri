import{ai as T,_ as D,a1 as C,ah as F,lh as S,A as _,bY as R,b7 as K,aL as E}from"./chunk-8J0p1hu6.js";import{i as P}from"./chunk-HUuvQ7TL.js";import{p as $}from"./chunk-Ll0OLjFE.js";import{x as L,o as w,a as A,E as O,n as U}from"./chunk-EImeEInu.js";import{p as z}from"./chunk-Wkv4NQPx.js";import"./chunk-EUQwHdIv.js";import"./chunk-8z8MVveq.js";import"./chunk-stayn4kD.js";import"./chunk-CEMOhUyj.js";import"./chunk-pT1ASav_.js";import"./chunk-pcBJnprf.js";import"./chunk-IrzVJFiS.js";import"./chunk-gG12UYPH.js";class B{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,r){const s=this._resourceMap,a=s.get(e);if(a)return a;let i=this._inFlightResourceMap.get(e);if(i)return i;try{i=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...r}),this._inFlightResourceMap.set(e,i),i.then(n=>(this._inFlightResourceMap.delete(e),s.set(e,n),n))}catch(n){return T(n)?null:{width:0,height:0}}return i}getResource(e){return this._resourceMap.get(e)??null}loadFont(e){return Promise.resolve(null)}}function I(t,e){const r=e-e/4,s=e+e/2;return(!t.minScale||t.minScale>=r)&&(!t.maxScale||t.maxScale<=s)}function x(t){const e=t.message,r={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const s in e.data){const a=s,i=e.data[a];if(r.message.data[a]=null,i!=null){const n=i.stride,o=i.indices.slice(0),l=i.vertices.slice(0),d=i.records.slice(0),c=i.metrics?.slice(0),h={stride:n,indices:o,vertices:l,records:d,metrics:c};r.transferList.push(o,l,d),r.message.data[a]=h}}return r}let M=class extends z{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.addHandles([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new B(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach(e=>{e.forEach(t)})}async update(t,e){const r=e.schema.processors[0];if(r.type!=="symbol")return;const s=F(this._schema,r);(S(s,"mesh")||S(s,"target"))&&(t.mesh=!0,t.why?.mesh.push("Symbology changed"),this._schema=r,this._factory=this._createFactory(r),this._factory.update(r,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,r,s){return _(s),this._onTileData(t,e,r,s)}onTileClear(t,e){const r={clear:!0,end:e};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:r})}onTileError(t,e,r){const s=r.signal,a={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",a,{signal:s})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach(r=>{for(const s of r)s.message.tileKey===e.id&&this._updateTileMesh("append",e,x(s),[],!1,!1,null)})}_addBufferData(t,e){this._bufferData.has(t)||this._bufferData.set(t,[]),this._bufferData.get(t)?.push(x(e))}_createFactory(t){const{geometryType:e,objectIdField:r,fields:s}=this.service,a=(d,c)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",d,c),i={geometryType:e,fields:s,spatialReference:R.fromJSON(this.spatialReference)},n=new L(a,this.tileStore.tileScheme.tileInfo),{matcher:o,aggregateMatcher:l}=t.mesh;return this._store=n,this._matchers.feature=w(o,n,i,this._resourceManagerProxy),this._matchers.aggregate=l?w(l,n,i,this._resourceManagerProxy):null,new A(e,r,n)}async _onTileData(t,e,r,s){_(s);const{type:a,addOrUpdate:i,remove:n,clear:o,end:l}=e,d=!!this._schema.mesh.sortKey;if(!i){const h={type:a,addOrUpdate:null,remove:n,clear:o,end:l,sort:d};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:h},s)}const c=this._processFeatures(t,i,r,s,e.status?.version);try{const h=await c;if(h==null){const u={type:a,addOrUpdate:null,remove:n,clear:o,end:l,sort:d};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:u},s)}const f=[];for(const u of h){let m=!1;const p=u.message.bufferIds,g=t.key.id,b=u.message.tileKey;if(g!==b&&p!=null){if(!this.tileStore.get(b)){this._addBufferData(g,u),f.push(u);continue}let y=this._bufferIds.get(b);y||(y=new Set,this._bufferIds.set(b,y));const k=Array.from(p);for(const v of k){if(y.has(v)){m=!0;break}y.add(v)}}m||(this._addBufferData(g,u),f.push(u))}await Promise.all(f.map(u=>{const m=t.key.id===u.message.tileKey,p=m?e.remove:[],g=m&&e.end;return this._updateTileMesh(a,t,u,p,g,!!e.clear,s.signal)}))}catch(h){this._handleError(t,h,s)}}async _updateTileMesh(t,e,r,s,a,i,n){const o=t,l=r.message.tileKey,d=!!this._schema.mesh.sortKey;l!==e.key.id&&(a=!1);const c=r?.message,h={type:o,addOrUpdate:c,remove:s,clear:i,end:a,sort:d},f={transferList:r?.transferList??[],signal:n};return _(f),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:l,data:h},f)}async _processFeatures(t,e,r,s,a){if(e==null||!e.hasFeatures)return null;const i={transform:t.transform,hasZ:!1,hasM:!1},n=this._factory,o={viewingMode:"",scale:t.scale},l=await this._matchers.feature,d=await this._matchers.aggregate;_(s);const c=this._getLabelInfos(t,e);return await n.analyze(e.getCursor(),this._resourceManagerProxy,l,d,i,o),_(s),this._writeFeatureSet(t,e,i,c,n,r,a)}_writeFeatureSet(t,e,r,s,a,i,n){const o=e.getSize(),l=this._schema.mesh.matcher.symbologyType,d=new O(t.key.id,{features:o,records:o,metrics:0},l,i,l!==K.HEATMAP,n),c={viewingMode:"",scale:t.scale},h=e.getCursor();for(;h.next();)try{const u=h.getDisplayId(),m=s!=null?s.get(u):null;a.writeCursor(d,h,r,c,t.level,m,this._resourceManagerProxy)}catch{}const f=t.tileInfoView.tileInfo.isWrappable;return d.serialize(f)}_handleError(t,e,r){if(!T(e)){const s={tileKey:t.id,error:e.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:r.signal})}return Promise.resolve()}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(e==null)return null;if(e.type==="subtype"){const s={type:"subtype",classes:{}};let a=!1;for(const i in e.classes){const n=e.classes[i].filter(o=>I(o,t.scale));a=a||!!n.length,s.classes[i]=n}return a?s:null}const r=e.classes.filter(s=>I(s,t.scale));return r.length?{type:"simple",classes:r}:null}_getLabels(t,e){if(e.type==="subtype"){const r=this.service.subtypeField;E(r,"Expected to find subtype Field");const s=t.readAttribute(r);return s==null?[]:e.classes[s]??[]}return e.classes}_getLabelInfos(t,e){const r=this._getLabelingSchemaForScale(t);if(r==null)return null;const s=new Map,a=e.getCursor();for(;a.next();){const i=a.getDisplayId(),n=[],o=$(i),l=o&&a.readAttribute("cluster_count")!==1?"aggregate":"feature",d=this._getLabels(a,r);for(const c of d){if(c.target!==l)continue;const h=a.getStorage(),f=o&&l==="feature"?h.getComputedStringAtIndex(a.readAttribute("referenceId"),c.fieldIndex):h.getComputedStringAtIndex(i,c.fieldIndex);if(!f)continue;const u=P(f.toString()),m=u[0],p=u[1];this._store.getMosaicItem(c.symbol,U(m)).then(g=>{n[c.index]={glyphs:g.glyphMosaicItems??[],rtl:p,index:c.index}})}s.set(i,n)}return s}};M=D([C("esri.views.2d.layers.features.processors.SymbolProcessor")],M);const te=M;export{te as default};
