import{jP as O,bY as D,jQ as q,jR as E,A as z,jS as G,jT as $,jU as A,jV as J,jW as W,cJ as B}from"./chunk-8J0p1hu6.js";async function N(a,d,l,m,o){const{elevationProvider:f,renderCoordsHelper:i}=a,{elevationInfo:u}=d,{pointsInFeatures:R,spatialReference:g}=m,h=D.fromJSON(g),y=q(u,!0),j=await E(y,h,o);z(o);const c=[],e=new Set,t=new Set;p.spatialReference=h;const s=a.elevationProvider.spatialReference??a.spatialReference;for(const{objectId:n,points:r}of R){const I=l(n);if(I==null){for(const S of r)c.push(S.z??0);e.add(n);continue}I.isDraped&&t.add(n);const P=I.graphic.geometry;b.setFromElevationInfo(G(P,u)),b.updateFeatureExpressionInfoContext(j,I.graphic,d);for(const{x:S,y:C,z:F}of r)p.x=S,p.y=C,p.z=F??0,await $(p,v,s,0,{signal:o}),A(v,f,b,i,w),c.push(w.z)}return{elevations:c,drapedObjectIds:t,failedObjectIds:e}}const b=new J,p=O(0,0,0,D.WGS84),w=new W,v=[0,0,0];async function Q(a,d,l){if(a==null||d.candidates.length===0)return x;const m=a.graphics3DGraphicsByObjectID??a.graphics3DGraphics,o=[],f=[],{renderer:i}=a,u=i!=null&&"arcadeRequired"in i&&i.arcadeRequired?B():null,R=async(e,{graphic:t,graphics3DSymbol:s})=>{const n=await u,r=await a.getRenderingInfoAsync(t,i,n,{signal:l});return r==null?[]:s.queryForSnapping(e,h,r,l)},{candidates:g,spatialReference:h}=d;for(let e=0;e<g.length;++e){const t=g[e],{objectId:s}=t,n=typeof s=="number"?m?.get(s):void 0;if(n==null)continue;const{graphics3DSymbol:r}=n;r.symbologySnappingSupported&&(o.push(R(t,n)),f.push(e))}if(o.length===0)return x;const y=await Promise.all(o);z(l);const j=[],c=[];for(let e=0;e<y.length;++e){const t=y[e],s=f[e];for(const n of t)j.push(n),c.push(s)}return{candidates:j,sourceCandidateIndices:c}}const x={candidates:[],sourceCandidateIndices:[]};export{N as c,Q as r};
