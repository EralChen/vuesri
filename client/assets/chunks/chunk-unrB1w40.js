import{km as z,ko as E,dA as U,kt as J,y as W,sM as V,dl as H,bS as L,bw as N,oJ as B,bo as F,eZ as T,ai as G,sN as O,sO as K,sP as j,sQ as Q,sR as P,sS as Z,nr as X,sT as C,eW as Y,ct as tt}from"./chunk-8J0p1hu6.js";import{t as w}from"./chunk-pT1ASav_.js";import{e as et}from"./chunk-gj-n8J5I.js";let k=class{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new w(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new w;let e=null,i=-1;for(let r=0;r<this._free.length;++r){const o=this._free[r];t<=o.width&&s<=o.height&&(e===null||o.y<=e.y&&o.x<=e.x)&&(e=o,i=r)}return e===null?new w:(this._free.splice(i,1),e.width<e.height?(e.width>t&&this._free.push(new w(e.x+t,e.y,e.width-t,s)),e.height>s&&this._free.push(new w(e.x,e.y+s,e.width,e.height-s))):(e.width>t&&this._free.push(new w(e.x+t,e.y,e.width-t,e.height)),e.height>s&&this._free.push(new w(e.x,e.y+s,t,e.height-s))),new w(e.x,e.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const e=this._free[s];if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)e.width+=t.width;else if(e.x===t.x&&e.width===t.width&&e.y+e.height===t.y)e.height+=t.height;else if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)e.x=t.x,e.width+=t.width;else{if(t.x!==e.x||t.width!==e.width||t.y+t.height!==e.y)continue;e.y=t.y,e.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}},A=class{constructor(t,s,e){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=e,this._binPack=new k(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const e=[],i=this._glyphSource,r=new Set,o=1/256;for(const l of s){const h=Math.floor(l*o);r.add(h)}const n=[];return r.forEach(l=>{const h=t+l;if(this._rangePromises.has(h))n.push(this._rangePromises.get(h));else{const c=i.getRange(t,l).then(()=>{this._rangePromises.delete(h)},()=>{this._rangePromises.delete(h)});this._rangePromises.set(h,c),n.push(c)}}),Promise.all(n).then(()=>{let l=this._glyphIndex[t];l||(l={},this._glyphIndex[t]=l);for(const h of s){const c=l[h];if(c){e[h]={sdf:!0,rect:c.rect,metrics:c.metrics,page:c.page,code:h};continue}const _=i.getGlyph(t,h);if(!_?.metrics)continue;const u=_.metrics;let a;if(u.width===0)a=new w(0,0,0,0);else{const g=u.width+6,p=u.height+2*3;let d=g%4?4-g%4:4,m=p%4?4-p%4:4;d===1&&(d=5),m===1&&(m=5),a=this._binPack.allocate(g+d,p+m),a.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new k(this.width-4,this.height-4),a=this._binPack.allocate(g+d,p+m));const b=this._glyphData[this._currentPage],S=_.bitmap;let v,I;if(S)for(let x=0;x<p;x++){v=g*x,I=this.width*(a.y+x+1)+a.x;for(let M=0;M<g;M++)b[I+M+1]=S.at(v+M)}}l[h]={rect:a,metrics:u,tileIDs:null,page:this._currentPage},e[h]={sdf:!0,rect:a,metrics:u,page:this._currentPage,code:h},this._dirties[this._currentPage]=!0}return e})}removeGlyphs(t){for(const s in this._glyphIndex){const e=this._glyphIndex[s];if(!e)continue;let i;for(const r in e)if(i=e[r],i.tileIDs.delete(t),i.tileIDs.size===0){const o=this._glyphData[i.page],n=i.rect;let l,h;for(let c=0;c<n.height;c++)for(l=this.width*(n.y+c)+n.x,h=0;h<n.width;h++)o[l+h]=0;delete e[r],this._dirties[i.page]=!0}}}bind(t,s,e,i=0){if(!this._textures[e]){const o=new z;o.pixelFormat=E.ALPHA,o.wrapMode=U.CLAMP_TO_EDGE,o.width=this.width,o.height=this.height,this._textures[e]=new J(t,o,new Uint8Array(this.width*this.height))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(this._glyphData[e]),t.bindTexture(r,i),this._dirties[e]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}};class R{constructor(t){if(this._metrics=[],!t)return void(this._allBitmaps=null);const s=new Map;let e=0;for(;t.next();)switch(t.tag()){case 1:{const o=t.getMessage();for(;o.next();)switch(o.tag()){case 3:{const n=o.getMessage();let l,h,c,_,u,a,y;for(;n.next();)switch(n.tag()){case 1:l=n.getUInt32();break;case 2:h=n.getBytes();break;case 3:c=n.getUInt32();break;case 4:_=n.getUInt32();break;case 5:u=n.getSInt32();break;case 6:a=n.getSInt32();break;case 7:y=n.getUInt32();break;default:n.skip()}if(n.release(),l){const g=h?.length??0;this._metrics[l]={width:c,height:_,left:u,top:a,advance:y,startOffset:e,length:g},s.set(l,h),e+=g}break}default:o.skip()}o.release();break}default:t.skip()}const i=new Uint8Array(e),r=this._metrics;for(const[o,n]of s){const{startOffset:l,length:h}=r[o];if(n)for(let c=0;c<h;++c)i[l+c]=n[c]}this._allBitmaps=i}getMetrics(t){return this._metrics[t]}getBitmap(t){if(!this._allBitmaps)return;const s=this._metrics[t];if(s===void 0)return;const{startOffset:e,length:i}=s;return i!==0?new it(this._allBitmaps,e,i):void 0}}class st{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}let D=class{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(t,s){const e=this._getFontStack(t);if(e.getRange(s))return Promise.resolve();const i=256*s,r=i+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",t).replace("{range}",i+"-"+r);return W(o,{responseType:"array-buffer"}).then(n=>{e.addRange(s,new R(new V(new Uint8Array(n.data),new DataView(n.data))))}).catch(()=>{e.addRange(s,new R)})}return e.addRange(s,new R),Promise.resolve()}getGlyph(t,s){const e=this._getFontStack(t);if(!e)return;const i=Math.floor(s/256),r=e.getRange(i);return r?{metrics:r.getMetrics(s),bitmap:r.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new st),s}};class it{constructor(t,s,e){this._array=t,this._start=s,this.length=e}at(t){return 0<=t&&t<this.length?this._array[this._start+t]:void 0}}const rt="dasharray-";let q=class ${constructor(t,s,e=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(t<=0||s<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,e>0&&(this._maxItemSize=e),this._binPack=new k(t-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new k(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),e=Math.floor(this._pageHeight),i=new Uint32Array(s*e);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let e,i,r=this._mosaicRects[t];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(t&&t.startsWith(rt)?([e,i]=this._rasterizeDash(t),s=!0):e=this._sprites.getSpriteInfo(t),!e?.width||!e.height||e.width<0||e.height<0))return null;const o=e.width,n=e.height,[l,h,c]=this._allocateImage(o,n);return l.width<=0?null:(this._copy(l,e,h,c,s,i),r={rect:l,width:o,height:n,sdf:e.sdf,simplePattern:!1,pixelRatio:e.pixelRatio,page:h},this._mosaicRects[t]=r,r)}getSpriteItems(t){const s={};for(const e of t)s[e.name]=this.getSpriteItem(e.name,e.repeat);return s}getMosaicItemPosition(t,s){const e=this.getSpriteItem(t,s),i=e&&e.rect;if(!i)return null;i.width=e.width,i.height=e.height;const r=e.width,o=e.height,n=2;return{tl:[i.x+n,i.y+n],br:[i.x+n+r,i.y+n+o],page:e.page}}bind(t,s,e=0,i=0){if(e>=this._size.length||e>=this._mosaicsData.length)return;if(!this._textures[e]){const o=new z;o.wrapMode=U.CLAMP_TO_EDGE,o.width=this._size[e][0],o.height=this._size[e][1],this._textures[e]=new J(t,o,new Uint8Array(this._mosaicsData[e].buffer))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(new Uint8Array(this._mosaicsData[e].buffer)),t.bindTexture(r,i),this._dirties[e]=!1}static _copyBits(t,s,e,i,r,o,n,l,h,c,_){let u=i*s+e,a=l*o+n;if(_){a-=o;for(let y=-1;y<=c;y++,u=((y+c)%c+i)*s+e,a+=o)for(let g=-1;g<=h;g++)r[a+g]=t[u+(g+h)%h]}else for(let y=0;y<c;y++){for(let g=0;g<h;g++)r[a+g]=t[u+g];u+=s,a+=o}}_copy(t,s,e,i,r,o){if(!this._sprites||this._sprites.loadStatus!=="loaded"||e>=this._mosaicsData.length)return;const n=new Uint32Array(o?o.buffer:this._sprites.image.buffer),l=this._mosaicsData[e];l&&n||console.error("Source or target images are uninitialized!");const h=2,c=o?s.width:this._sprites.width;$._copyBits(n,c,s.x,s.y,l,i[0],t.x+h,t.y+h,s.width,s.height,r),this._dirties[e]=!0}_allocateImage(t,s){t+=2,s+=2;const e=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<e){const n=new w(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[n,this._mosaicsData.length-1,[t,s]]}let i=t%4?4-t%4:4,r=s%4?4-s%4:4;i===1&&(i=5),r===1&&(r=5);const o=this._binPack.allocate(t+i,s+r);return o.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new k(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[o,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=/\[(.*?)\]/,e=t.match(s);if(!e)return null;const i=e[1].split(",").map(Number),r=t.slice(t.lastIndexOf("-")+1),[o,n,l]=et(i,r);return[{x:0,y:0,width:n,height:l,sdf:!0,pixelRatio:1},new Uint8Array(o.buffer)]}};class mt{constructor(t,s,e){this._layer=t,this._styleRepository=s,this.devicePixelRatio=e,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=H(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const s=this._layer.currentStyleInfo.glyphsUrl,e=new D(s?L(s,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new A(1024,1024,e),this._broadcastPromise=N("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then(i=>{if(this._layer&&(this._connection?.close(),this._connection=i,this._layer&&!this._connection.closed)){const r=i.broadcast("setStyle",this._layer.currentStyleInfo.style,t);Promise.all(r).catch(o=>B(o))}})}_requestSprite(t){this._spriteSourceAbortController?.abort();const s=new AbortController;this._spriteSourceAbortController=s;const e=t?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,e&&(this._inputSignalEventListener=ot(s),e.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:i}=s,r={...t,signal:i};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,r),this._spriteSourcePromise.then(o=>{F(i),this._spriteMosaic=new q(1024,1024,250),this._spriteMosaic.setSpriteSource(o)})}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(t){const s=new q(1024,1024,250);return s.setSpriteSource(t),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,s}async setStyle(t,s){await this._broadcastPromise,this._styleRepository=t,this._requestSprite();const e=new D(this._layer.currentStyleInfo.glyphsUrl?L(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new A(1024,1024,e),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",s)),this._broadcastPromise}fetchTileData(t,s){return this._getRefKeys(t,s).then(e=>{const i=this._layer.sourceNameToSource,r=[];for(const o in i)r.push(o);return this._getSourcesData(r,e,s)})}parseTileData(t,s){const e=t&&t.data;if(!e)return Promise.resolve(null);const{sourceName2DataAndRefKey:i,transferList:r}=e;return Object.keys(i).length===0?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:r}))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,s,e){const i=T.pool.acquire(t.id),r=this._layer.sourceNameToSource[s],{level:o,row:n,col:l}=i;T.pool.release(i);try{return{protobuff:await r.requestTile(o,n,l,e),sourceName:s}}catch(h){if(G(h))throw h;return{protobuff:null,sourceName:s}}}_getRefKeys(t,s){const e=this._layer.sourceNameToSource,i=new Array;for(const r in e){const o=e[r].getRefKey(t,s);i.push(o)}return Promise.allSettled(i)}_getSourcesData(t,s,e){const i=[];for(let r=0;r<s.length;r++){const o=s[r],n=o.status==="fulfilled"?o.value:null;if(n==null||t[r]==null)i.push(null);else{const l=this._getTilePayload(n,t[r],e);i.push(l)}}return Promise.allSettled(i).then(r=>{const o={},n=[];for(let l=0;l<r.length;l++){const h=r[l],c=h.status==="fulfilled"?h.value:null,_=c?.protobuff;if(!c||!_?.byteLength)continue;const u=s[l],a=u.status==="fulfilled"?u.value:null;if(a){const y=a.id;o[c.sourceName]={refKey:y,protobuff:_},n.push(_)}}return{sourceName2DataAndRefKey:o,transferList:n}})}}function ot(f){return()=>f.abort()}function nt(f,t,s,e,i,r){const{iconRotationAlignment:o,textRotationAlignment:n,iconTranslate:l,iconTranslateAnchor:h,textTranslate:c,textTranslateAnchor:_}=e;let u=0;for(const a of f.colliders){const[y,g]=a.partIndex===0?l:c,p=a.partIndex===0?h:_,d=a.minLod<=r&&r<=a.maxLod;u+=d?0:1,a.enabled=d,a.xScreen=a.xTile*i[0]+a.yTile*i[3]+i[6],a.yScreen=a.xTile*i[1]+a.yTile*i[4]+i[7],p===Z.MAP?(a.xScreen+=s*y-t*g,a.yScreen+=t*y+s*g):(a.xScreen+=y,a.yScreen+=g),P.VIEWPORT===(a.partIndex===0?o:n)?(a.dxScreen=a.dxPixels,a.dyScreen=a.dyPixels):(a.dxScreen=s*(a.dxPixels+a.width/2)-t*(a.dyPixels+a.height/2)-a.width/2,a.dyScreen=t*(a.dxPixels+a.width/2)+s*(a.dyPixels+a.height/2)-a.height/2)}f.colliders.length>0&&u===f.colliders.length&&(f.unique.show=!1)}let bt=class{constructor(t,s,e,i,r,o){this._symbols=t,this._styleRepository=i,this._zoom=r,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new O(s,e,K),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const n of t)for(const l of n.symbols)this._allNeededMatrices.has(l.tile)||this._allNeededMatrices.set(l.tile,j(l.tile.transforms.tileUnitsToPixels))}work(t){const s=this._gridIndex;function e(r){const o=r.xScreen+r.dxScreen,n=r.yScreen+r.dyScreen,l=o+r.width,h=n+r.height,[c,_,u,a]=s.getCellSpan(o,n,l,h);for(let y=_;y<=a;y++)for(let g=c;g<=u;g++){const p=s.cells[y][g];for(const d of p){const m=d.xScreen+d.dxScreen,b=d.yScreen+d.dyScreen,S=m+d.width,v=b+d.height;if(!(l<m||o>S||h<b||n>v))return!0}}return!1}const i=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const r=this._symbols[this._currentLayerCursor],o=this._getProperties(r.styleLayerUID);for(;this._currentSymbolCursor<r.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-i>t)return!1;const n=r.symbols[this._currentSymbolCursor];if(!n.unique.show)continue;nt(n,this._si,this._co,o,this._allNeededMatrices.get(n.tile),this._zoom);const l=n.unique;if(!l.show)continue;const{iconAllowOverlap:h,iconIgnorePlacement:c,textAllowOverlap:_,textIgnorePlacement:u}=o;for(const a of n.colliders){if(!a.enabled)continue;const y=l.parts[a.partIndex];y.show&&!(a.partIndex?_:h)&&e(a)&&(a.hard?l.show=!1:y.show=!1)}if(l.show)for(const a of n.colliders){if(!a.enabled||(a.partIndex?u:c)||!l.parts[a.partIndex].show)continue;const y=a.xScreen+a.dxScreen,g=a.yScreen+a.dyScreen,p=y+a.width,d=g+a.height,[m,b,S,v]=this._gridIndex.getCellSpan(y,g,p,d);for(let I=b;I<=v;I++)for(let x=m;x<=S;x++)this._gridIndex.cells[I][x].push(a)}}}return!0}_getProperties(t){const s=this._styleProps.get(t);if(s)return s;const e=this._zoom,i=this._styleRepository.getStyleLayerByUID(t),r=i.getLayoutValue("symbol-placement",e)!==Q.POINT;let o=i.getLayoutValue("icon-rotation-alignment",e);o===P.AUTO&&(o=r?P.MAP:P.VIEWPORT);let n=i.getLayoutValue("text-rotation-alignment",e);n===P.AUTO&&(n=r?P.MAP:P.VIEWPORT);const l=i.getPaintValue("icon-translate",e),h=i.getPaintValue("icon-translate-anchor",e),c=i.getPaintValue("text-translate",e),_=i.getPaintValue("text-translate-anchor",e),u={iconAllowOverlap:i.getLayoutValue("icon-allow-overlap",e),iconIgnorePlacement:i.getLayoutValue("icon-ignore-placement",e),textAllowOverlap:i.getLayoutValue("text-allow-overlap",e),textIgnorePlacement:i.getLayoutValue("text-ignore-placement",e),iconRotationAlignment:o,textRotationAlignment:n,iconTranslateAnchor:h,iconTranslate:l,textTranslateAnchor:_,textTranslate:c};return this._styleProps.set(t,u),u}};function lt(f,t){if(f.priority-t.priority)return f.priority-t.priority;const s=f.tile.key,e=t.tile.key;return s.world-e.world?s.world-e.world:s.level-e.level?s.level-e.level:s.row-e.row?s.row-e.row:s.col-e.col?s.col-e.col:f.xTile-t.xTile?f.xTile-t.xTile:f.yTile-t.yTile}class St{get running(){return this._running}constructor(t,s,e,i,r,o){this._visibleTiles=t,this._symbolRepository=s,this._createCollisionJob=e,this._assignTileSymbolsOpacity=i,this._symbolLayerSorter=r,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(t,s){this._screenWidth===t&&this._screenHeight===s||this.restart(),this._screenWidth=t,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(t){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(t)||(this._selectionJobCompleted=!0,(t=Math.max(0,t-(performance.now()-s)))===0))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(t)||(this._collisionJobCompleted=!0,(t=Math.max(0,t-(performance.now()-s)))===0))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(t)||(this._opacityJobCompleted=!0,(t=Math.max(0,t-(performance.now()-s)))===0))return!1}return this._running=!1,!0}_createSelectionJob(){const t=this._symbolRepository.uniqueSymbols;for(let l=0;l<t.length;l++){const h=t[l];for(let c=0;c<h.uniqueSymbols.length;c++){const _=h.uniqueSymbols[c];for(const u of _.tileSymbols)u.selectedForRendering=!1}}const s=[];let e=0,i=0;const r=this._isLayerVisible;function o(l){let h;const c=performance.now();for(;i<t.length;i++,e=0){const _=t[i],u=_.styleLayerUID;if(!r(u)){s[i]||(s[i]={styleLayerUID:u,symbols:[]});continue}s[i]=s[i]||{styleLayerUID:u,symbols:[]};const a=s[i];for(;e<_.uniqueSymbols.length;e++){if(h=_.uniqueSymbols[e],e%100==99&&performance.now()-c>l)return!1;let y=null,g=!1,p=!1;for(const d of h.tileSymbols)if(!p||!g){const m=d.tile;(!y||m.isCoverage||m.neededForCoverage&&!g)&&(y=d,(m.neededForCoverage||m.isCoverage)&&(p=!0),m.isCoverage&&(g=!0))}if(y.selectedForRendering=!0,p){a.symbols.push(y),h.show=!0;for(const d of h.parts)d.show=!0}else h.show=!1}}for(const _ of s)_.symbols.sort(lt);return!0}const n=this._symbolLayerSorter;return{work:o,get sortedSymbols(){return s.sort(n)}}}_createOpacityJob(){const t=this._assignTileSymbolsOpacity,s=this._visibleTiles;let e=0;function i(r,o){const n=r.symbols;for(const[l,h]of n)at(h,o);t(r,o);for(const l of r.childrenTiles)i(l,o)}return{work(r){const o=performance.now();for(;e<s.length;e++){if(performance.now()-o>r)return!1;const n=s[e];n.parentTile==null&&i(n,performance.now())}return!0}}}}function at(f,t){for(const s of f){const e=s.unique;for(const i of e.parts){const r=i.targetOpacity>.5?1:-1;i.startOpacity+=r*((t-i.startTime)/X),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=t,i.targetOpacity=e.show&&i.show?1:0}}}const ht=32,ct=8,ut=64;class xt{constructor(t,s,e){this.tileCoordRange=t,this._visibleTiles=s,this._createUnique=e,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return this._uniqueSymbolLayerArray==null&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(t,s){this._uniqueSymbolLayerArray=null;let e=this._tiles.get(t.id);e||(e={symbols:new Map},this._tiles.set(t.id,e));const i=new Map;if(s)for(const n of s)e.symbols.has(n)&&(i.set(n,e.symbols.get(n)),e.symbols.delete(n));else for(const[n,l]of t.layerData)e.symbols.has(n)&&(i.set(n,e.symbols.get(n)),e.symbols.delete(n));this._removeSymbols(i);const r=t.symbols,o=new Map;for(const[n,l]of r){let h=l.length;if(h>=ht){let c=this.tileCoordRange;do c/=2,h/=4;while(h>ct&&c>ut);const _=new O(this.tileCoordRange,this.tileCoordRange,c);o.set(n,{flat:l,index:_}),e.symbols.set(n,{flat:l,index:_});for(const u of l)_.getCell(u.xTile,u.yTile).push(u)}else o.set(n,{flat:l}),e.symbols.set(n,{flat:l})}this._addSymbols(t.key,r)}deleteStyleLayers(t){this._uniqueSymbolLayerArray=null;for(const[s,e]of this._tiles){const i=new Map;for(const r of t)e.symbols.has(r)&&(i.set(r,e.symbols.get(r)),e.symbols.delete(r));this._removeSymbols(i),e.symbols.size===0&&this._tiles.delete(s)}}removeTile(t){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(t.id);if(!s)return;const e=new Map;for(const[i,r]of t.symbols)s.symbols.has(i)&&(e.set(i,s.symbols.get(i)),s.symbols.delete(i));this._removeSymbols(e),s.symbols.size===0&&this._tiles.delete(t.id)}_removeSymbols(t){for(const[s,{flat:e}]of t)for(const i of e){const r=i.unique,o=r.tileSymbols,n=o.length-1;for(let l=0;l<n;l++)if(o[l]===i){o[l]=o[n];break}if(o.length=n,n===0){const l=this._uniqueSymbolsReferences.get(s);l.delete(r),l.size===0&&this._uniqueSymbolsReferences.delete(s)}i.unique=null}}_addSymbols(t,s){if(s.size===0)return;const e=this._visibleTiles;for(const i of e)i.parentTile||i.key.world!==t.world||i.key.level===t.level&&!i.key.equals(t)||this._matchSymbols(i,t,s);for(const[i,r]of s)for(const o of r)if(o.unique==null){const n=this._createUnique();o.unique=n,n.tileSymbols.push(o);let l=this._uniqueSymbolsReferences.get(i);l||(l=new Set,this._uniqueSymbolsReferences.set(i,l)),l.add(n)}}_matchSymbols(t,s,e){if(t.key.level>s.level){const r=t.key.level-s.level;if(t.key.row>>r!==s.row||t.key.col>>r!==s.col)return}if(s.level>t.key.level){const r=s.level-t.key.level;if(s.row>>r!==t.key.row||s.col>>r!==t.key.col)return}if(s.equals(t.key)){for(const r of t.childrenTiles)this._matchSymbols(r,s,e);return}const i=new Map;for(const[r,o]of e){const n=[];for(const _ of o){const u=C(this.tileCoordRange,_.xTile,s.level,s.col,t.key.level,t.key.col),a=C(this.tileCoordRange,_.yTile,s.level,s.row,t.key.level,t.key.row);u>=0&&u<this.tileCoordRange&&a>=0&&a<this.tileCoordRange&&n.push({symbol:_,xTransformed:u,yTransformed:a})}const l=[],h=t.key.level<s.level?1:1<<t.key.level-s.level,c=this._tiles.get(t.id).symbols.get(r);if(c){const _=c.flat;for(const u of n){let a,y=!1;const g=u.xTransformed,p=u.yTransformed;a=c.index!=null?c.index.getCell(g,p):_;const d=u.symbol,m=d.hash;for(const b of a)if(m===b.hash&&Math.abs(g-b.xTile)<=h&&Math.abs(p-b.yTile)<=h){const S=b.unique;d.unique=S,S.tileSymbols.push(d),y=!0;break}y||l.push(d)}}l.length>0&&i.set(r,l)}for(const r of t.childrenTiles)this._matchSymbols(r,s,i)}_createUniqueSymbolLayerArray(){const t=this._uniqueSymbolsReferences,s=new Array(t.size);let e,i=0;for(const[r,o]of t){const n=new Array(o.size);e=0;for(const l of o)n[e++]=l;s[i]={styleLayerUID:r,uniqueSymbols:n},i++}return s}}class Pt extends Y{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(t){const s=T.pool.acquire(t),e=s.level===0?null:T.getId(s.level-1,s.row>>1,s.col>>1,s.world);return T.pool.release(s),e}getTileCoverage(t,s,e=!0,i){const r=super.getTileCoverage(t,s,e,i);if(!r)return r;const o=1<<r.lodInfo.level;return r.spans=r.spans.filter(n=>n.row>=0&&n.row<o),r}scaleToLevel(t){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[t])return this._levelByScale[t];{const s=this._fullCacheLodInfos;if(t>s[0].scale)return s[0].level;let e,i;for(let r=0;r<s.length-1;r++)if(i=s[r+1],t>i.scale)return e=s[r],e.level+(e.scale-t)/(e.scale-i.scale);return s[s.length-1].level}}_initializeFullCacheLODs(t){let s;if(t[0].level===0)s=t.map(e=>({level:e.level,resolution:e.resolution,scale:e.scale}));else{const e=this.tileInfo.size[0],i=this.tileInfo.spatialReference;s=tt.create({size:e,spatialReference:i}).lods.map(r=>({level:r.level,resolution:r.resolution,scale:r.scale}))}for(let e=0;e<s.length;e++)this._levelByScale[s[e].scale]=s[e].level;this._fullCacheLodInfos=s}}export{St as e,xt as i,bt as l,Pt as t,mt as u};
